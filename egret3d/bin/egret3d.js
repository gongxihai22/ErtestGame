var __reflect = (this && this.__reflect) || function (p, c, t) {
    p.__class__ = c, t ? t.push(c) : t = [c], p.__types__ = p.__types__ ? t.concat(p.__types__) : t;
};
var __extends = this && this.__extends || function __extends(t, e) { 
 function r() { 
 this.constructor = t;
}
for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
r.prototype = e.prototype, t.prototype = new r();
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
// type int = number;
// type uint = number;
var paper;
(function (paper) {
    /**
     *
     */
    var BaseRelease = (function () {
        function BaseRelease() {
        }
        /**
         * 在本帧末尾释放。
         */
        BaseRelease.prototype.release = function () {
            if (!this._released) {
                paper.DisposeCollecter._releases.push(this);
                this._released = true;
            }
            return this;
        };
        return BaseRelease;
    }());
    paper.BaseRelease = BaseRelease;
    __reflect(BaseRelease.prototype, "paper.BaseRelease");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    function registerClass(baseClass) {
        baseClass.__onRegister();
    }
    paper.registerClass = registerClass;
    function serializedField(classPrototypeOrKey, key) {
        if (key) {
            var baseClass = classPrototypeOrKey.constructor;
            registerClass(baseClass);
            baseClass.__serializeKeys[key] = null;
        }
        else {
            return function (classPrototype, key) {
                var baseClass = classPrototype.constructor;
                registerClass(baseClass);
                baseClass.__serializeKeys[key] = classPrototypeOrKey;
            };
        }
    }
    paper.serializedField = serializedField;
    /**
     * 通过装饰器标记反序列化时需要忽略的属性。
     */
    function deserializedIgnore(classPrototype, key) {
        var baseClass = classPrototype.constructor;
        registerClass(baseClass);
        var keys = baseClass.__deserializeIgnore;
        if (keys.indexOf(key) < 0) {
            keys.push(key);
        }
    }
    paper.deserializedIgnore = deserializedIgnore;
    /**
     * 通过装饰器标记组件是否允许在同一实体上添加多个实例。
     */
    function allowMultiple(componentClass) {
        registerClass(componentClass);
        if (!componentClass.__isSingleton) {
            componentClass.allowMultiple = true;
        }
        else {
            console.warn("Singleton component cannot allow multiple.");
        }
    }
    paper.allowMultiple = allowMultiple;
    /**
     * 通过装饰器标记组件依赖的其他组件。
     */
    function requireComponent(requireComponentClass) {
        return function (componentClass) {
            var requireComponents = componentClass.requireComponents;
            if (requireComponents.indexOf(requireComponentClass) < 0) {
                requireComponents.push(requireComponentClass);
            }
        };
    }
    paper.requireComponent = requireComponent;
    // executionOrder: number;
    // /**
    //  * 通过装饰器标记脚本组件的生命周期优先级。（默认：0）
    //  */
    // export function executionOrder(order: number = 0) {
    //     return function (componentClass: ComponentClass<Behaviour>) {
    //         registerClass(componentClass);
    //         componentClass.executionOrder = order;
    //     }
    // }
    /**
     * 通过装饰器标记脚本组件是否在编辑模式也拥有生命周期。
     */
    function executeInEditMode(componentClass) {
        registerClass(componentClass);
        componentClass.executeInEditMode = true;
    }
    paper.executeInEditMode = executeInEditMode;
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Vector2 = (function (_super) {
        __extends(Vector2, _super);
        /**
         * 请使用 `egret3d.Vector2.create()` 创建实例。
         * @see egret3d.Vector2.create()
         * @deprecated
         * @private
         */
        function Vector2(x, y) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            return _this;
        }
        Vector2.create = function (x, y) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y);
                instance._released = false;
                return instance;
            }
            return new Vector2().set(x, y);
        };
        Vector2.prototype.serialize = function () {
            return [this.x, this.y];
        };
        Vector2.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            return this;
        };
        Vector2.prototype.copy = function (value) {
            this.x = value.x;
            this.y = value.y;
            return this;
        };
        Vector2.prototype.clone = function () {
            var value = new Vector2();
            value.copy(this);
            return value;
        };
        Vector2.prototype.set = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        Vector2.prototype.normalize = function () {
            var l = this.length;
            if (l > Number.MIN_VALUE) {
                this.x /= l;
                this.y /= l;
            }
            else {
                this.x = 1.0;
                this.y = 0.0;
            }
            return this;
        };
        Object.defineProperty(Vector2.prototype, "length", {
            get: function () {
                return Math.sqrt(this.sqrtLength);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector2.prototype, "sqrtLength", {
            get: function () {
                return this.x * this.x + this.y * this.y;
            },
            enumerable: true,
            configurable: true
        });
        Vector2.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            return out;
        };
        Vector2.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            return out;
        };
        Vector2.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            return out;
        };
        Vector2.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        };
        Vector2.scale = function (v, scaler) {
            v.x = v.x * scaler;
            v.y = v.y * scaler;
            return v;
        };
        Vector2.getLength = function (v) {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        };
        Vector2.getDistance = function (v1, v2) {
            this.subtract(v1, v2, _helpVector2A);
            return this.getLength(_helpVector2A);
        };
        Vector2.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            return true;
        };
        Vector2.lerp = function (v1, v2, value, out) {
            out.x = v1.x * (1 - value) + v2.x * value;
            out.y = v1.y * (1 - value) + v2.y * value;
            return out;
        };
        Vector2.ZERO = new Vector2(0.0, 0.0);
        Vector2.ONE = new Vector2(1.0, 1.0);
        Vector2._instances = [];
        return Vector2;
    }(paper.BaseRelease));
    egret3d.Vector2 = Vector2;
    __reflect(Vector2.prototype, "egret3d.Vector2", ["egret3d.IVector2", "paper.ICCS", "paper.ISerializable"]);
    var _helpVector2A = new Vector2();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**属性信息 */
        var PropertyInfo = (function () {
            function PropertyInfo(name, editType, option) {
                this.name = name;
                this.editType = editType;
                this.option = option;
            }
            return PropertyInfo;
        }());
        editor.PropertyInfo = PropertyInfo;
        __reflect(PropertyInfo.prototype, "paper.editor.PropertyInfo");
        /**编辑类型 */
        var EditType;
        (function (EditType) {
            /**数字输入 */
            EditType[EditType["UINT"] = 0] = "UINT";
            EditType[EditType["INT"] = 1] = "INT";
            EditType[EditType["FLOAT"] = 2] = "FLOAT";
            /**文本输入 */
            EditType[EditType["TEXT"] = 3] = "TEXT";
            /**选中框 */
            EditType[EditType["CHECKBOX"] = 4] = "CHECKBOX";
            /**vertor2 */
            EditType[EditType["VECTOR2"] = 5] = "VECTOR2";
            /**vertor3 */
            EditType[EditType["VECTOR3"] = 6] = "VECTOR3";
            /**vertor4 */
            EditType[EditType["VECTOR4"] = 7] = "VECTOR4";
            /**Quaternion */
            EditType[EditType["QUATERNION"] = 8] = "QUATERNION";
            /**颜色选择器 */
            EditType[EditType["COLOR"] = 9] = "COLOR";
            /**下拉 */
            EditType[EditType["LIST"] = 10] = "LIST";
            /**Rect */
            EditType[EditType["RECT"] = 11] = "RECT";
            /**材质 */
            EditType[EditType["MATERIAL"] = 12] = "MATERIAL";
            /**材质数组 */
            EditType[EditType["MATERIAL_ARRAY"] = 13] = "MATERIAL_ARRAY";
            /**游戏对象 */
            EditType[EditType["GAMEOBJECT"] = 14] = "GAMEOBJECT";
            /**变换 TODO 不需要*/
            EditType[EditType["TRANSFROM"] = 15] = "TRANSFROM";
            /**组件 */
            EditType[EditType["COMPONENT"] = 16] = "COMPONENT";
            /**声音 */
            EditType[EditType["SOUND"] = 17] = "SOUND";
            /**Mesh */
            EditType[EditType["MESH"] = 18] = "MESH";
            /**shader */
            EditType[EditType["SHADER"] = 19] = "SHADER";
            /**数组 */
            EditType[EditType["ARRAY"] = 20] = "ARRAY";
        })(EditType = editor.EditType || (editor.EditType = {}));
        var customMap = {};
        /**
         * 装饰器:自定义
         */
        function custom() {
            return function (target) {
                customMap[target.name] = true;
            };
        }
        editor.custom = custom;
        var propertyMap = {};
        /**
         * 装饰器:属性
         * @param editType 编辑类型
         */
        function property(editType, option) {
            return function (target, property) {
                if (!propertyMap[target.constructor.name]) {
                    propertyMap[target.constructor.name] = {
                        extends: target.__proto__.constructor.name,
                        propertyList: [],
                    };
                }
                if (editType !== undefined) {
                    propertyMap[target.constructor.name].propertyList.push(new PropertyInfo(property, editType, option));
                }
                else {
                    //TODO:自动分析编辑类型
                }
            };
        }
        editor.property = property;
        /**
         * 检测一个实例对象是否为已被自定义
         * @param classInstance 实例对象
         */
        function isCustom(classInstance) {
            return customMap[classInstance.constructor.name] ? true : false;
        }
        editor.isCustom = isCustom;
        /**
         * 从枚举中生成装饰器列表项。
         */
        function getItemsFromEnum(enumObject) {
            var items = [];
            for (var k in enumObject) {
                if (!isNaN(Number(k))) {
                    continue;
                }
                items.push({ label: k, value: enumObject[k] });
            }
            return items;
        }
        editor.getItemsFromEnum = getItemsFromEnum;
        /**
         * 获取一个实例对象的编辑信息
         * @param classInstance 实例对象
         */
        function getEditInfo(classInstance) {
            var whileInsance = classInstance.__proto__;
            var retrunList = [];
            var className;
            while (whileInsance) {
                className = whileInsance.constructor.name;
                var classInfo = propertyMap[className];
                if (classInfo) {
                    retrunList = retrunList.concat(classInfo.propertyList);
                }
                whileInsance = whileInsance.__proto__;
            }
            return retrunList;
        }
        editor.getEditInfo = getEditInfo;
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var _hashCount = 1;
    /**
     * 生成 uuid 的方式。
     * @internal
     */
    paper.createUUID = function () {
        return (_hashCount++).toString();
    };
    /**
     * 基础对象。
     */
    var BaseObject = (function () {
        function BaseObject() {
            this.uuid = paper.createUUID();
        }
        /**
         * @internal
         */
        BaseObject.__onRegister = function () {
            if (this.__owner && this.__owner === this) {
                return false;
            }
            this.__deserializeIgnore = [];
            this.__serializeKeys = {};
            this.__owner = this;
            return true;
        };
        __decorate([
            paper.serializedField
        ], BaseObject.prototype, "uuid", void 0);
        return BaseObject;
    }());
    paper.BaseObject = BaseObject;
    __reflect(BaseObject.prototype, "paper.BaseObject", ["paper.IUUID"]);
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var EulerOrder;
    (function (EulerOrder) {
        EulerOrder[EulerOrder["XYZ"] = 0] = "XYZ";
        EulerOrder[EulerOrder["XZY"] = 1] = "XZY";
        EulerOrder[EulerOrder["YXZ"] = 2] = "YXZ";
        EulerOrder[EulerOrder["YZX"] = 3] = "YZX";
        EulerOrder[EulerOrder["ZXY"] = 4] = "ZXY";
        EulerOrder[EulerOrder["ZYX"] = 5] = "ZYX";
    })(EulerOrder = egret3d.EulerOrder || (egret3d.EulerOrder = {}));
    /**
     * 三维向量
     */
    var Vector3 = (function (_super) {
        __extends(Vector3, _super);
        /**
         * 请使用 `egret3d.Vector3.create()` 创建实例。
         * @see egret3d.Vector3.create()
         * @deprecated
         * @private
         */
        function Vector3(x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.z = z;
            return _this;
        }
        Vector3.create = function (x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, z);
                instance._released = false;
                return instance;
            }
            return new Vector3().set(x, y, z);
        };
        Vector3.prototype.serialize = function () {
            return [this.x, this.y, this.z];
        };
        Vector3.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Vector3.prototype.copy = function (value) {
            return this.set(value.x, value.y, value.z);
        };
        Vector3.prototype.clone = function () {
            return Vector3.create(this.x, this.y, this.z);
        };
        Vector3.prototype.equal = function (value, threshold) {
            if (threshold === void 0) { threshold = 0.000001; }
            if (Math.abs(this.x - value.x) > threshold) {
                return false;
            }
            if (Math.abs(this.y - value.y) > threshold) {
                return false;
            }
            if (Math.abs(this.z - value.z) > threshold) {
                return false;
            }
            return true;
        };
        Vector3.prototype.set = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        Vector3.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = value[offset];
            this.y = value[offset + 1];
            this.z = value[offset + 2];
            return this;
        };
        Vector3.prototype.fromPlaneProjection = function (plane, source) {
            if (!source) {
                source = this;
            }
            return this.add(egret3d.helpVector3A.multiplyScalar(-plane.getDistance(source), plane.normal));
        };
        Vector3.prototype.applyMatrix3 = function (matrix, source) {
            if (!source) {
                source = this;
            }
            // const x = source.x, y = source.y, z = source.z;
            // const rawData = matrix.rawData;
            // const w = 1.0 / (rawData[3] * x + rawData[7] * y + rawData[11] * z + rawData[15]);
            // this.x = (rawData[0] * x + rawData[4] * y + rawData[8] * z + rawData[12]) * w;
            // this.y = (rawData[1] * x + rawData[5] * y + rawData[9] * z + rawData[13]) * w;
            // this.z = (rawData[2] * x + rawData[6] * y + rawData[10] * z + rawData[14]) * w;
            var x = source.x, y = source.y, z = source.z;
            var e = matrix.rawData;
            this.x = e[0] * x + e[3] * y + e[6] * z;
            this.y = e[1] * x + e[4] * y + e[7] * z;
            this.z = e[2] * x + e[5] * y + e[8] * z;
            return this;
        };
        Vector3.prototype.applyMatrix = function (matrix, source) {
            if (!source) {
                source = this;
            }
            var x = source.x, y = source.y, z = source.z;
            var rawData = matrix.rawData;
            var w = 1.0 / (rawData[3] * x + rawData[7] * y + rawData[11] * z + rawData[15]);
            this.x = (rawData[0] * x + rawData[4] * y + rawData[8] * z + rawData[12]) * w;
            this.y = (rawData[1] * x + rawData[5] * y + rawData[9] * z + rawData[13]) * w;
            this.z = (rawData[2] * x + rawData[6] * y + rawData[10] * z + rawData[14]) * w;
            return this;
        };
        Vector3.prototype.applyDirection = function (matrix, source) {
            if (!source) {
                source = this;
            }
            var x = source.x, y = source.y, z = source.z;
            var rawData = matrix.rawData;
            this.x = rawData[0] * x + rawData[4] * y + rawData[8] * z;
            this.y = rawData[1] * x + rawData[5] * y + rawData[9] * z;
            this.z = rawData[2] * x + rawData[6] * y + rawData[10] * z;
            return this;
        };
        Vector3.prototype.applyQuaternion = function (quaternion, source) {
            if (!source) {
                source = this;
            }
            var x = source.x, y = source.y, z = source.z;
            var qx = quaternion.x, qy = quaternion.y, qz = quaternion.z, qw = quaternion.w;
            // calculate quat * vector
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;
            // calculate result * inverse quat
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
        };
        Vector3.prototype.normalize = function (source, defaultAxis) {
            if (!source) {
                source = this;
            }
            var l = Math.sqrt(source.x * source.x + source.y * source.y + source.z * source.z);
            if (l > egret3d.EPSILON) {
                l = 1.0 / l;
                this.x *= l;
                this.y *= l;
                this.z *= l;
            }
            else {
                if (!defaultAxis) {
                    defaultAxis = Vector3.FORWARD;
                }
                this.copy(defaultAxis);
            }
            return this;
        };
        Vector3.prototype.negate = function (source) {
            if (!source) {
                source = this;
            }
            this.x = source.x * -1.0;
            this.y = source.y * -1.0;
            this.z = source.z * -1.0;
            return this;
        };
        Vector3.prototype.addScalar = function (add, source) {
            if (source) {
                this.x = source.x + add;
                this.y = source.y + add;
                this.z = source.z + add;
            }
            else {
                this.x += add;
                this.y += add;
                this.z += add;
            }
            return this;
        };
        Vector3.prototype.add = function (valueA, valueB) {
            if (valueB) {
                this.x = valueA.x + valueB.x;
                this.y = valueA.y + valueB.y;
                this.z = valueA.z + valueB.z;
            }
            else {
                this.x += valueA.x;
                this.y += valueA.y;
                this.z += valueA.z;
            }
            return this;
        };
        Vector3.prototype.subtract = function (valueA, valueB) {
            if (valueB) {
                this.x = valueA.x - valueB.x;
                this.y = valueA.y - valueB.y;
                this.z = valueA.z - valueB.z;
            }
            else {
                this.x -= valueA.x;
                this.y -= valueA.y;
                this.z -= valueA.z;
            }
            return this;
        };
        Vector3.prototype.multiplyScalar = function (scale, source) {
            if (source) {
                this.x = scale * source.x;
                this.y = scale * source.y;
                this.z = scale * source.z;
            }
            else {
                this.x *= scale;
                this.y *= scale;
                this.z *= scale;
            }
            return this;
        };
        Vector3.prototype.multiply = function (valueA, valueB) {
            if (valueB) {
                this.x = valueA.x * valueB.x;
                this.y = valueA.y * valueB.y;
                this.z = valueA.z * valueB.z;
            }
            else {
                this.x *= valueA.x;
                this.y *= valueA.y;
                this.z *= valueA.z;
            }
            return this;
        };
        Vector3.prototype.dot = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            return valueA.x * valueB.x + valueA.y * valueB.y + valueA.z * valueB.z;
        };
        Vector3.prototype.cross = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            var x = valueA.x;
            var y = valueA.y;
            var z = valueA.z;
            this.x = y * valueB.z - z * valueB.y;
            this.y = z * valueB.x - x * valueB.z;
            this.z = x * valueB.y - y * valueB.x;
            return this;
        };
        Vector3.prototype.lerp = function (t, valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            var p = 1.0 - t;
            this.x = valueA.x * p + valueB.x * t;
            this.y = valueA.y * p + valueB.y * t;
            this.z = valueA.z * p + valueB.z * t;
            return this;
        };
        Vector3.prototype.min = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.min(valueA.x, valueB.x);
            this.y = Math.min(valueA.y, valueB.y);
            this.z = Math.min(valueA.z, valueB.z);
            return this;
        };
        Vector3.prototype.max = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.max(valueA.x, valueB.x);
            this.y = Math.max(valueA.y, valueB.y);
            this.z = Math.max(valueA.z, valueB.z);
            return this;
        };
        Vector3.prototype.clamp = function (min, max, source) {
            if (!source) {
                source = this;
            }
            // assumes min < max, componentwise
            this.x = Math.max(min.x, Math.min(max.x, source.x));
            this.y = Math.max(min.y, Math.min(max.y, source.y));
            this.z = Math.max(min.z, Math.min(max.z, source.z));
            return this;
        };
        Vector3.prototype.divide = function (source) {
            if (!source) {
                source = this;
            }
            this.x /= source.x;
            this.y /= source.y;
            this.z /= source.z;
            return this;
        };
        Vector3.prototype.getAngle = function (value) {
            var theta = this.dot(value) / (Math.sqrt(this.squaredLength * Vector3.getSqrLength(value)));
            // clamp, to handle numerical problems
            return Math.acos(Math.max(-1, Math.min(1, theta)));
        };
        Vector3.prototype.getSquaredDistance = function (value) {
            return helpVector.subtract(value, this).squaredLength;
        };
        Vector3.prototype.getDistance = function (value) {
            return helpVector.subtract(value, this).length;
        };
        Vector3.prototype.closestToTriangle = function (triangle, value) {
            if (!value) {
                value = this;
            }
            var vab = egret3d.helpVector3A;
            var vac = egret3d.helpVector3B;
            var vbc = egret3d.helpVector3C;
            var vap = egret3d.helpVector3D;
            var vbp = egret3d.helpVector3E;
            var vcp = egret3d.helpVector3F;
            var a = triangle.a, b = triangle.b, c = triangle.c;
            var v, w;
            // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
            // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
            // under the accompanying license; see chapter 5.1.5 for detailed explanation.
            // basically, we're distinguishing which of the voronoi regions of the triangle
            // the point lies in with the minimum amount of redundant computation.
            vab.subtract(b, a);
            vac.subtract(c, a);
            vap.subtract(value, a);
            var d1 = vab.dot(vap);
            var d2 = vac.dot(vap);
            if (d1 <= 0 && d2 <= 0) {
                // vertex region of A; barycentric coords (1, 0, 0)
                return this.copy(a);
            }
            vbp.subtract(value, b);
            var d3 = vab.dot(vbp);
            var d4 = vac.dot(vbp);
            if (d3 >= 0 && d4 <= d3) {
                // vertex region of B; barycentric coords (0, 1, 0)
                return this.copy(b);
            }
            var vc = d1 * d4 - d3 * d2;
            if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                v = d1 / (d1 - d3);
                // edge region of AB; barycentric coords (1-v, v, 0)
                return this.multiplyScalar(v, vab).add(a);
            }
            vcp.subtract(value, c);
            var d5 = vab.dot(vcp);
            var d6 = vac.dot(vcp);
            if (d6 >= 0 && d5 <= d6) {
                // vertex region of C; barycentric coords (0, 0, 1)
                return this.copy(c);
            }
            var vb = d5 * d2 - d1 * d6;
            if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                w = d2 / (d2 - d6);
                // edge region of AC; barycentric coords (1-w, 0, w)
                return this.multiplyScalar(w, vac).add(a);
            }
            var va = d3 * d6 - d5 * d4;
            if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
                vbc.subtract(c, b);
                w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                // edge region of BC; barycentric coords (0, 1-w, w)
                return this.multiplyScalar(w, vbc).add(b); // edge region of BC
            }
            // face region
            var denom = 1 / (va + vb + vc);
            // u = va * denom
            v = vb * denom;
            w = vc * denom;
            return this.add(a, vac.multiplyScalar(w).add(vab.multiplyScalar(v)));
        };
        Vector3.prototype.toArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            value[0 + offset] = this.x;
            value[1 + offset] = this.y;
            value[2 + offset] = this.z;
            return value;
        };
        Object.defineProperty(Vector3.prototype, "length", {
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3.prototype, "squaredLength", {
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Vector3.set = function (x, y, z, out) {
            out.x = x;
            out.y = y;
            out.z = z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.normalize = function (v) {
            var num = Vector3.getLength(v);
            if (num > Number.MIN_VALUE) {
                v.x = v.x / num;
                v.y = v.y / num;
                v.z = v.z / num;
            }
            else {
                v.x = 1.0;
                v.y = 0.0;
                v.z = 0.0;
            }
            return v;
        };
        /**
         * @deprecated
         */
        Vector3.copy = function (v, out) {
            out.x = v.x;
            out.y = v.y;
            out.z = v.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            out.z = v1.z + v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            out.z = v1.z * v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.scale = function (v, scale) {
            v.x = v.x * scale;
            v.y = v.y * scale;
            v.z = v.z * scale;
            return v;
        };
        /**
         * @deprecated
         */
        Vector3.cross = function (lhs, rhs, out) {
            out.x = lhs.y * rhs.z - lhs.z * rhs.y;
            out.y = lhs.z * rhs.x - lhs.x * rhs.z;
            out.z = lhs.x * rhs.y - lhs.y * rhs.x;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
        };
        /**
         * @deprecated
         */
        Vector3.lerp = function (v1, v2, v, out) {
            out.x = v1.x * (1 - v) + v2.x * v;
            out.y = v1.y * (1 - v) + v2.y * v;
            out.z = v1.z * (1 - v) + v2.z * v;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            if (Math.abs(v1.z - v2.z) > threshold) {
                return false;
            }
            return true;
        };
        /**
         * @deprecated
         */
        Vector3.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            out.z = v1.z - v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.getSqrLength = function (v) {
            return v.x * v.x + v.y * v.y + v.z * v.z;
        };
        /**
         * @deprecated
         */
        Vector3.getLength = function (v) {
            return Math.sqrt(this.getSqrLength(v));
        };
        /**
         * @deprecated
         */
        Vector3.getDistance = function (a, b) {
            return this.getLength(this.subtract(a, b, helpVector));
        };
        /**
         * 零
         */
        Vector3.ZERO = new Vector3(0.0, 0.0, 0.0);
        /**
         * 三方向均为一的向量
         */
        Vector3.ONE = new Vector3(1.0, 1.0, 1.0);
        /**
         * 三方向均为负一的向量
         */
        Vector3.MINUS_ONE = new Vector3(-1.0, -1.0, -1.0);
        /**
         * 上
         */
        Vector3.UP = new Vector3(0.0, 1.0, 0.0);
        /**
         * 下
         */
        Vector3.DOWN = new Vector3(0.0, -1.0, 0.0);
        /**
         * 左
         */
        Vector3.LEFT = new Vector3(-1.0, 0.0, 0.0);
        /**
         * 右
         */
        Vector3.RIGHT = new Vector3(1.0, 0.0, 0.0);
        /**
         * 前
         */
        Vector3.FORWARD = new Vector3(0.0, 0.0, 1.0);
        /**
         * 后
         */
        Vector3.BACK = new Vector3(0.0, 0.0, -1.0);
        Vector3._instances = [];
        return Vector3;
    }(paper.BaseRelease));
    egret3d.Vector3 = Vector3;
    __reflect(Vector3.prototype, "egret3d.Vector3", ["egret3d.IVector3", "egret3d.IVector2", "paper.ICCS", "paper.ISerializable"]);
    var helpVector = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3A = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3B = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3C = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3D = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3E = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3F = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3G = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3H = Vector3.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 资源基类。
     */
    var Asset = (function (_super) {
        __extends(Asset, _super);
        function Asset(name) {
            if (name === void 0) { name = ""; }
            var _this = _super.call(this) || this;
            /**
             * @readonly
             */
            _this.name = "";
            /**
             * @internal
             */
            _this._isBuiltin = false;
            _this.name = name;
            return _this;
        }
        /**
         * @private
         */
        Asset.register = function (asset) {
            if (!this._assets[asset.name]) {
                this._assets[asset.name] = asset;
            }
            else if (this._assets[asset.name] !== asset) {
                console.warn("Replace existing asset.", asset.name);
                this._assets[asset.name] = asset;
            }
        };
        /**
         * 查找已加载的指定资源。
         */
        Asset.find = function (name) {
            var result = this._assets[name];
            if (!result) {
                return RES.getRes(name);
            }
            return result;
        };
        /**
         * 释放资源。
         */
        Asset.prototype.dispose = function (disposeChildren) {
            if (this._isBuiltin) {
                console.warn("Cannot dispose builtin asset.", this.name);
                return false;
            }
            delete Asset._assets[this.name];
            this.name = "";
            return true;
        };
        /**
         * @internal
         */
        Asset._assets = {};
        return Asset;
    }(paper.BaseObject));
    paper.Asset = Asset;
    __reflect(Asset.prototype, "paper.Asset");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 组件基类。
     */
    var BaseComponent = (function (_super) {
        __extends(BaseComponent, _super);
        /**
         * 禁止实例化组件。
         * @protected
         */
        function BaseComponent() {
            var _this = _super.call(this) || this;
            /**
             * 该组件的实体。
             */
            _this.gameObject = null;
            /**
             * 仅保存在编辑器环境的额外数据，项目发布该数据将被移除。
             */
            _this.extras = paper.Application.playerMode === 2 /* Editor */ ? {} : undefined;
            _this._enabled = true;
            if (!BaseComponent._createEnabled) {
                throw new Error("Component instantiation through constructor is not allowed.");
            }
            _this.gameObject = BaseComponent._createEnabled;
            BaseComponent._createEnabled = null;
            return _this;
        }
        /**
         * @internal
         */
        BaseComponent.__onRegister = function () {
            if (!paper.BaseObject.__onRegister.call(this)) {
                return false;
            }
            if ((this.__isSingleton ? this._allSingletonComponents : this._allComponents).indexOf(this) >= 0) {
                console.warn("Register component class again.", egret.getQualifiedClassName(this));
                return false;
            }
            if (this.requireComponents) {
                this.requireComponents = this.requireComponents.concat();
            }
            else {
                this.requireComponents = [];
            }
            if (this.__isSingleton) {
                this.__index = this._allSingletonComponents.length + 300; // This means that a maximum of 300 non-singleton components can be added.
                this._allSingletonComponents.push(this);
            }
            else {
                this.__index = this._allComponents.length;
                this._allComponents.push(this);
            }
            return true;
        };
        /**
         * @internal
         */
        BaseComponent.create = function (componentClass, gameObject) {
            this._createEnabled = gameObject;
            return new componentClass();
        };
        /**
         * 添加组件后，组件内部初始化。
         * - 重载此方法时，必须调用 `super.initialize()`。
         */
        BaseComponent.prototype.initialize = function (config) {
        };
        /**
         * 移除组件后，组件内部卸载。
         * - 重载此方法时，必须调用 `super.uninitialize()`。
         */
        BaseComponent.prototype.uninitialize = function () {
        };
        Object.defineProperty(BaseComponent.prototype, "isDestroyed", {
            /**
             * 该组件是否已被销毁。
             */
            get: function () {
                return !this.gameObject;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "enabled", {
            /**
             * 该组件自身的激活状态。
             */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._enabled === value) {
                    return;
                }
                // if (!value && this.constructor === egret3d.Transform) { TODO
                //     console.warn("Cannot disable transform compnent.");
                //     return;
                // }
                var prevEnabled = this.isActiveAndEnabled;
                this._enabled = value;
                var currentEnabled = this.isActiveAndEnabled;
                if (currentEnabled !== prevEnabled) {
                    paper.EventPool.dispatchEvent(currentEnabled ? "__enabled__" /* Enabled */ : "__disabled__" /* Disabled */, this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "isActiveAndEnabled", {
            /**
             * 该组件在场景的激活状态。
             */
            get: function () {
                // return this._enabled && this.gameObject.activeInHierarchy;
                return this._enabled && (this.gameObject._activeDirty ? this.gameObject.activeInHierarchy : this.gameObject._activeInHierarchy);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "transform", {
            /**
             * 该组件实体的变换组件。
             */
            get: function () {
                return this.gameObject.transform;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "renderer", {
            /**
             * 该组件实体的渲染组件。
             */
            get: function () {
                return this.gameObject.renderer;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该组件的实例是否在编辑模式拥有生命周期。
         */
        BaseComponent.executeInEditMode = false;
        /**
         * 是否允许在同一实体上添加多个该组件的实例。
         */
        BaseComponent.allowMultiple = false;
        /**
         * 该组件实例依赖的其他前置组件。
         */
        BaseComponent.requireComponents = null;
        // TODO 基类标记，以阻止注册基类。
        /**
         * @internal
         */
        BaseComponent.__isSingleton = false;
        /**
         * @internal
         */
        BaseComponent.__index = -1;
        BaseComponent._allComponents = [];
        BaseComponent._allSingletonComponents = [];
        BaseComponent._createEnabled = null;
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "extras", void 0);
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "_enabled", void 0);
        __decorate([
            paper.editor.property(4 /* CHECKBOX */)
        ], BaseComponent.prototype, "enabled", null);
        return BaseComponent;
    }(paper.BaseObject));
    paper.BaseComponent = BaseComponent;
    __reflect(BaseComponent.prototype, "paper.BaseComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 射线。
     */
    var Ray = (function (_super) {
        __extends(Ray, _super);
        /**
         * 请使用 `egret3d.Ray.create()` 创建实例。
         * @see egret3d.Ray.create()
         */
        function Ray() {
            var _this = _super.call(this) || this;
            /**
             * 射线起始点
             */
            _this.origin = egret3d.Vector3.create();
            /**
             * 射线的方向向量
             */
            _this.direction = egret3d.Vector3.create();
            return _this;
        }
        /**
         *
         * @param origin
         * @param direction
         */
        Ray.create = function (origin, direction) {
            if (origin === void 0) { origin = egret3d.Vector3.ZERO; }
            if (direction === void 0) { direction = egret3d.Vector3.FORWARD; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(origin, direction);
                instance._released = false;
                return instance;
            }
            return new Ray().set(origin, direction);
        };
        Ray.prototype.serialize = function () {
            return [this.origin.x, this.origin.y, this.origin.z, this.direction.x, this.direction.y, this.direction.z];
        };
        Ray.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Ray.prototype.copy = function (value) {
            return this.set(value.origin, value.direction);
        };
        Ray.prototype.clone = function () {
            return Ray.create(this.origin, this.direction);
        };
        Ray.prototype.set = function (origin, direction) {
            this.origin.copy(origin);
            this.direction.copy(direction);
            return this;
        };
        Ray.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.origin.fromArray(value, offset);
            this.direction.fromArray(value, offset + 3);
            return this;
        };
        Ray.prototype.applyMatrix = function (value, ray) {
            this.origin.applyMatrix(value, (ray || this).origin);
            this.direction.applyDirection(value, (ray || this).direction).normalize();
            return this;
        };
        Ray.prototype.getSquaredDistance = function (value) {
            var directionDistance = egret3d.helpVector3A.subtract(value, this.origin).dot(this.direction);
            // point behind the ray
            if (directionDistance < 0.0) {
                return this.origin.getSquaredDistance(value);
            }
            return this.at(directionDistance, egret3d.helpVector3A).getSquaredDistance(value);
        };
        Ray.prototype.getDistance = function (value) {
            return Math.sqrt(this.getSquaredDistance(value));
        };
        Ray.prototype.getDistanceToPlane = function (value) {
            var denominator = value.normal.dot(this.direction);
            if (denominator === 0.0) {
                // line is coplanar, return origin
                if (value.getDistance(this.origin) === 0.0) {
                    return 0.0;
                }
                // Null is preferable to undefined since undefined means.... it is undefined
                return -1.0;
            }
            var t = -(this.origin.dot(value.normal) + value.constant) / denominator;
            // Return if the ray never intersects the plane
            return t >= 0.0 ? t : -1.0;
        };
        Ray.prototype.at = function (value, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            out.multiplyScalar(value, this.direction).add(this.origin);
            return out;
        };
        Ray.prototype.intersectTriangle = function (p1, p2, p3, p4, p5) {
            // // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
            // const edge1 = helpVector3A;
            // const edge2 = helpVector3B;
            // const diff = helpVector3C;
            // const normal = helpVector3D;
            // edge1.subtract(p2, p1);
            // edge2.subtract(p3, p1);
            // normal.cross(edge1, edge2);
            // // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            // //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            // //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            // //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            // let DdN = this.direction.dot(normal);
            // let sign = 1.0;
            // if (DdN > 0.0) {
            //     if (backfaceCulling) return null;
            // }
            // else if (DdN < 0.0) {
            //     sign = -1.0;
            //     DdN = -DdN;
            // }
            // else {
            //     return null;
            // }
            // diff.subtract(this.origin, p1);
            // const DdQxE2 = sign * this.direction.dot(edge2.cross(diff, edge2));
            // // b1 < 0, no intersection
            // if (DdQxE2 < 0.0) {
            //     return null;
            // }
            // const DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
            // // b2 < 0, no intersection
            // if (DdE1xQ < 0.0) {
            //     return null;
            // }
            // // b1+b2 > 1, no intersection
            // if (DdQxE2 + DdE1xQ > DdN) {
            //     return null;
            // }
            // // Line intersects triangle, check if ray does.
            // const QdN = - sign * diff.dot(normal);
            // // t < 0, no intersection
            // if (QdN < 0) {
            //     return null;
            // }
            // const pickInfo = new PickInfo();
            // pickInfo.distance = QdN / DdN;
            // pickInfo.position.multiplyScalar(pickInfo.distance, this.direction).add(this.origin);
            // pickInfo.textureCoordA.x = DdQxE2;
            // pickInfo.textureCoordA.y = DdE1xQ;
            // return pickInfo;
            // TODO
            var isA = p1 instanceof egret3d.Triangle;
            var edge1 = egret3d.helpVector3A;
            var edge2 = egret3d.helpVector3B;
            var pvec = egret3d.helpVector3C;
            var tvec = egret3d.helpVector3D;
            var qvec = egret3d.helpVector3E;
            var pA = isA ? p1.a : p1;
            var pB = isA ? p1.b : p2;
            var pC = isA ? p1.c : p3;
            edge1.subtract(pB, pA);
            edge2.subtract(pC, pA);
            pvec.cross(this.direction, edge2);
            var det = pvec.dot(edge1);
            if (det === 0.0) {
                return false;
            }
            var invdet = 1.0 / det;
            tvec.subtract(this.origin, pA);
            var bu = pvec.dot(tvec) * invdet;
            if (bu < 0.0 || bu > 1.0) {
                return false;
            }
            qvec.cross(tvec, edge1);
            var bv = qvec.dot(this.direction) * invdet;
            if (bv < 0.0 || bu + bv > 1.0) {
                return false;
            }
            var raycastInfo = isA ? p3 : p5;
            if (raycastInfo) {
                raycastInfo.textureCoordA.x = bu;
                raycastInfo.textureCoordA.y = bv;
                this.at(raycastInfo.distance = qvec.dot(edge2) * invdet, raycastInfo.position);
            }
            return true;
        };
        Ray._instances = [];
        return Ray;
    }(paper.BaseRelease));
    egret3d.Ray = Ray;
    __reflect(Ray.prototype, "egret3d.Ray", ["paper.ICCS", "paper.ISerializable"]);
    /**
     * 射线检测信息。
     */
    var RaycastInfo = (function (_super) {
        __extends(RaycastInfo, _super);
        function RaycastInfo() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.subMeshIndex = -1;
            _this.triangleIndex = -1;
            _this.distance = 0.0;
            _this.position = new egret3d.Vector3();
            _this.textureCoordA = new egret3d.Vector2();
            _this.textureCoordB = new egret3d.Vector2();
            _this.transform = null;
            _this.collider = null;
            return _this;
        }
        RaycastInfo.create = function () {
            if (this._instances.length > 0) {
                return this._instances.pop();
            }
            return new RaycastInfo();
        };
        RaycastInfo.prototype.clear = function () {
            this.subMeshIndex = -1;
            this.triangleIndex = -1;
            this.distance = 0.0;
            // TODO
            this.transform = null;
            this.collider = null;
        };
        RaycastInfo._instances = [];
        return RaycastInfo;
    }(paper.BaseRelease));
    egret3d.RaycastInfo = RaycastInfo;
    __reflect(RaycastInfo.prototype, "egret3d.RaycastInfo");
    /**
     * @internal
     */
    egret3d.helpRay = Ray.create();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _array = [
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
    ];
    /**
     * 4x4 矩阵。
     */
    var Matrix4 = (function (_super) {
        __extends(Matrix4, _super);
        /**
         * 请使用 `egret3d.Matrix4.create()` 创建实例。
         * @see egret3d.Matrix4.create()
         * @deprecated
         */
        function Matrix4(rawData, offsetOrByteOffset) {
            if (offsetOrByteOffset === void 0) { offsetOrByteOffset = 0; }
            var _this = _super.call(this) || this;
            /**
             * 矩阵原始数据
             * @readonly
             */
            _this.rawData = null;
            if (rawData && rawData instanceof ArrayBuffer) {
                _this.fromBuffer(rawData, offsetOrByteOffset);
            }
            else {
                _this.rawData = new Float32Array(16);
                _this.fromArray(rawData || _array);
            }
            return _this;
        }
        /**
         *
         * @param rawData
         * @param offsetOrByteOffset
         */
        Matrix4.create = function (rawData, offsetOrByteOffset) {
            if (offsetOrByteOffset === void 0) { offsetOrByteOffset = 0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                if (rawData) {
                    if (rawData instanceof ArrayBuffer) {
                        instance.fromBuffer(rawData, offsetOrByteOffset);
                    }
                    else {
                        instance.fromArray(rawData, offsetOrByteOffset);
                    }
                }
                else {
                    instance.identity();
                }
                return instance;
            }
            return new Matrix4(rawData, offsetOrByteOffset);
        };
        /**
         * 序列化
         * @returns 序列化后的数据
         */
        Matrix4.prototype.serialize = function () {
            return this.rawData;
        };
        /**
         * 反序列化
         * @param value 序列化后的数据
         */
        Matrix4.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Matrix4.prototype.copy = function (value) {
            this.fromArray(value.rawData);
            return this;
        };
        Matrix4.prototype.clone = function () {
            return Matrix4.create(this.rawData);
        };
        Matrix4.prototype.identity = function () {
            this.rawData[0] = 1.0;
            this.rawData[1] = 0.0;
            this.rawData[2] = 0.0;
            this.rawData[3] = 0.0;
            this.rawData[4] = 0.0;
            this.rawData[5] = 1.0;
            this.rawData[6] = 0.0;
            this.rawData[7] = 0.0;
            this.rawData[8] = 0.0;
            this.rawData[9] = 0.0;
            this.rawData[10] = 1.0;
            this.rawData[11] = 0.0;
            this.rawData[12] = 0.0;
            this.rawData[13] = 0.0;
            this.rawData[14] = 0.0;
            this.rawData[15] = 1.0;
            return this;
        };
        Matrix4.prototype.set = function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var rawData = this.rawData;
            rawData[0] = n11;
            rawData[4] = n12;
            rawData[8] = n13;
            rawData[12] = n14;
            rawData[1] = n21;
            rawData[5] = n22;
            rawData[9] = n23;
            rawData[13] = n24;
            rawData[2] = n31;
            rawData[6] = n32;
            rawData[10] = n33;
            rawData[14] = n34;
            rawData[3] = n41;
            rawData[7] = n42;
            rawData[11] = n43;
            rawData[15] = n44;
            return this;
        };
        Matrix4.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            for (var i = 0; i < 16; ++i) {
                this.rawData[i] = value[i + offset];
            }
            return this;
        };
        Matrix4.prototype.fromBuffer = function (value, byteOffset) {
            if (byteOffset === void 0) { byteOffset = 0; }
            this.rawData = new Float32Array(value, byteOffset, 16);
            return this;
        };
        Matrix4.prototype.fromTranslate = function (value, rotationAndScaleStays) {
            if (rotationAndScaleStays === void 0) { rotationAndScaleStays = false; }
            if (!rotationAndScaleStays) {
                this.identity();
            }
            this.rawData[12] = value.x;
            this.rawData[13] = value.y;
            this.rawData[14] = value.z;
            return this;
        };
        Matrix4.prototype.fromRotation = function (rotation, translateStays) {
            if (translateStays === void 0) { translateStays = false; }
            return this.compose(translateStays ? _helpVector3A.fromArray(this.rawData, 12) : egret3d.Vector3.ZERO, rotation, egret3d.Vector3.ONE);
        };
        Matrix4.prototype.fromEuler = function (value, order, translateStays) {
            // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m
            if (order === void 0) { order = 2 /* YXZ */; }
            if (translateStays === void 0) { translateStays = false; }
            var cos = Math.cos;
            var sin = Math.sin;
            var x = value.x, y = value.y, z = value.z;
            var a = cos(x), b = sin(x);
            var c = cos(y), d = sin(y);
            var e = cos(z), f = sin(z);
            var rawData = this.rawData;
            switch (order) {
                case 0 /* XYZ */: {
                    var ae = a * e, af = a * f, be = b * e, bf = b * f;
                    rawData[0] = c * e;
                    rawData[4] = -c * f;
                    rawData[8] = d;
                    rawData[1] = af + be * d;
                    rawData[5] = ae - bf * d;
                    rawData[9] = -b * c;
                    rawData[2] = bf - ae * d;
                    rawData[6] = be + af * d;
                    rawData[10] = a * c;
                    break;
                }
                case 1 /* XZY */: {
                    var ac_1 = a * c, ad_1 = a * d, bc_1 = b * c, bd_1 = b * d;
                    rawData[0] = c * e;
                    rawData[4] = -f;
                    rawData[8] = d * e;
                    rawData[1] = ac_1 * f + bd_1;
                    rawData[5] = a * e;
                    rawData[9] = ad_1 * f - bc_1;
                    rawData[2] = bc_1 * f - ad_1;
                    rawData[6] = b * e;
                    rawData[10] = bd_1 * f + ac_1;
                    break;
                }
                case 2 /* YXZ */: {
                    var ce = c * e, cf = c * f, de = d * e, df = d * f;
                    rawData[0] = ce + df * b;
                    rawData[4] = de * b - cf;
                    rawData[8] = a * d;
                    rawData[1] = a * f;
                    rawData[5] = a * e;
                    rawData[9] = -b;
                    rawData[2] = cf * b - de;
                    rawData[6] = df + ce * b;
                    rawData[10] = a * c;
                    break;
                }
                case 3 /* YZX */: {
                    var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                    rawData[0] = c * e;
                    rawData[4] = bd - ac * f;
                    rawData[8] = bc * f + ad;
                    rawData[1] = f;
                    rawData[5] = a * e;
                    rawData[9] = -b * e;
                    rawData[2] = -d * e;
                    rawData[6] = ad * f + bc;
                    rawData[10] = ac - bd * f;
                    break;
                }
                case 4 /* ZXY */: {
                    var ce = c * e, cf = c * f, de = d * e, df = d * f;
                    rawData[0] = ce - df * b;
                    rawData[4] = -a * f;
                    rawData[8] = de + cf * b;
                    rawData[1] = cf + de * b;
                    rawData[5] = a * e;
                    rawData[9] = df - ce * b;
                    rawData[2] = -a * d;
                    rawData[6] = b;
                    rawData[10] = a * c;
                    break;
                }
                case 5 /* ZYX */: {
                    var ae = a * e, af = a * f, be = b * e, bf = b * f;
                    rawData[0] = c * e;
                    rawData[4] = be * d - af;
                    rawData[8] = ae * d + bf;
                    rawData[1] = c * f;
                    rawData[5] = bf * d + ae;
                    rawData[9] = af * d - be;
                    rawData[2] = -d;
                    rawData[6] = b * c;
                    rawData[10] = a * c;
                    break;
                }
            }
            // bottom row
            rawData[3] = 0.0;
            rawData[7] = 0.0;
            rawData[11] = 0.0;
            if (!translateStays) {
                // last column
                rawData[12] = 0.0;
                rawData[13] = 0.0;
                rawData[14] = 0.0;
                rawData[15] = 1.0;
            }
            return this;
        };
        Matrix4.prototype.fromScale = function (x, y, z, translateStays) {
            if (translateStays === void 0) { translateStays = false; }
            if (translateStays) {
                _helpVector3A.fromArray(this.rawData, 12);
            }
            this.identity();
            this.rawData[0] = x;
            this.rawData[5] = y;
            this.rawData[10] = z;
            if (translateStays) {
                this.rawData[12] = _helpVector3A.x;
                this.rawData[13] = _helpVector3A.y;
                this.rawData[14] = _helpVector3A.z;
            }
            return this;
        };
        Matrix4.prototype.fromAxis = function (axis, radian) {
            if (radian === void 0) { radian = 0.0; }
            // Based on http://www.gamedev.net/reference/articles/article1199.asp
            var c = Math.cos(radian);
            var s = Math.sin(radian);
            var t = 1.0 - c;
            var x = axis.x, y = axis.y, z = axis.z;
            var tx = t * x, ty = t * y;
            this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0.0, tx * y + s * z, ty * y + c, ty * z - s * x, 0.0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0.0, 0.0, 0.0, 0.0, 1.0);
            return this;
        };
        Matrix4.prototype.fromAxises = function (axisX, axisY, axisZ) {
            this.set(axisX.x, axisY.x, axisZ.x, 0.0, axisX.y, axisY.y, axisZ.y, 0.0, axisX.z, axisY.z, axisZ.z, 0.0, 0.0, 0.0, 0.0, 1.0);
            return this;
        };
        Matrix4.prototype.fromRotationX = function (radian) {
            var c = Math.cos(radian), s = Math.sin(radian);
            this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.fromRotationY = function (radian) {
            var c = Math.cos(radian), s = Math.sin(radian);
            this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.fromRotationZ = function (radian) {
            var c = Math.cos(radian), s = Math.sin(radian);
            this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.determinant = function () {
            var rawData = this.rawData;
            var n11 = rawData[0], n12 = rawData[4], n13 = rawData[8], n14 = rawData[12];
            var n21 = rawData[1], n22 = rawData[5], n23 = rawData[9], n24 = rawData[13];
            var n31 = rawData[2], n32 = rawData[6], n33 = rawData[10], n34 = rawData[14];
            var n41 = rawData[3], n42 = rawData[7], n43 = rawData[11], n44 = rawData[15];
            //TODO: make this more efficient
            //( based on https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js )
            return (n41 * (+n14 * n23 * n32
                - n13 * n24 * n32
                - n14 * n22 * n33
                + n12 * n24 * n33
                + n13 * n22 * n34
                - n12 * n23 * n34) +
                n42 * (+n11 * n23 * n34
                    - n11 * n24 * n33
                    + n14 * n21 * n33
                    - n13 * n21 * n34
                    + n13 * n24 * n31
                    - n14 * n23 * n31) +
                n43 * (+n11 * n24 * n32
                    - n11 * n22 * n34
                    - n14 * n21 * n32
                    + n12 * n21 * n34
                    + n14 * n22 * n31
                    - n12 * n24 * n31) +
                n44 * (-n13 * n22 * n31
                    - n11 * n23 * n32
                    + n11 * n22 * n33
                    + n13 * n21 * n32
                    - n12 * n21 * n33
                    + n12 * n23 * n31));
        };
        Matrix4.prototype.compose = function (translation, rotation, scale) {
            var rawData = this.rawData;
            var x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;
            var x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2;
            var yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2;
            var sx = scale.x, sy = scale.y, sz = scale.z;
            rawData[0] = (1.0 - (yy + zz)) * sx;
            rawData[1] = (xy + wz) * sx;
            rawData[2] = (xz - wy) * sx;
            rawData[3] = 0.0;
            rawData[4] = (xy - wz) * sy;
            rawData[5] = (1.0 - (xx + zz)) * sy;
            rawData[6] = (yz + wx) * sy;
            rawData[7] = 0.0;
            rawData[8] = (xz + wy) * sz;
            rawData[9] = (yz - wx) * sz;
            rawData[10] = (1.0 - (xx + yy)) * sz;
            rawData[11] = 0.0;
            rawData[12] = translation.x;
            rawData[13] = translation.y;
            rawData[14] = translation.z;
            rawData[15] = 1.0;
            return this;
        };
        Matrix4.prototype.decompose = function (translation, rotation, scale) {
            if (translation === void 0) { translation = null; }
            if (rotation === void 0) { rotation = null; }
            if (scale === void 0) { scale = null; }
            var rawData = this.rawData;
            if (translation) {
                translation.x = rawData[12];
                translation.y = rawData[13];
                translation.z = rawData[14];
            }
            if (rotation || scale) {
                var sx = _helpVector3A.set(rawData[0], rawData[1], rawData[2]).length;
                var sy = _helpVector3A.set(rawData[4], rawData[5], rawData[6]).length;
                var sz = _helpVector3A.set(rawData[8], rawData[9], rawData[10]).length;
                // if determine is negative, we need to invert one scale
                var det = this.determinant();
                if (det < 0.0)
                    sx = -sx;
                if (rotation) {
                    // scale the rotation part
                    _helpMatrix.copy(this);
                    var invSX = 1.0 / sx;
                    var invSY = 1.0 / sy;
                    var invSZ = 1.0 / sz;
                    _helpMatrix.rawData[0] *= invSX;
                    _helpMatrix.rawData[1] *= invSX;
                    _helpMatrix.rawData[2] *= invSX;
                    _helpMatrix.rawData[4] *= invSY;
                    _helpMatrix.rawData[5] *= invSY;
                    _helpMatrix.rawData[6] *= invSY;
                    _helpMatrix.rawData[8] *= invSZ;
                    _helpMatrix.rawData[9] *= invSZ;
                    _helpMatrix.rawData[10] *= invSZ;
                    rotation.fromMatrix(_helpMatrix);
                }
                if (scale) {
                    scale.x = sx;
                    scale.y = sy;
                    scale.z = sz;
                }
            }
            return this;
        };
        Matrix4.prototype.transpose = function (source) {
            if (!source) {
                source = this;
            }
            var valueRawData = source.rawData;
            var rawData = this.rawData;
            var temp = 0.0;
            temp = valueRawData[1];
            rawData[1] = valueRawData[4];
            rawData[4] = temp;
            temp = valueRawData[2];
            rawData[2] = valueRawData[8];
            rawData[8] = temp;
            temp = valueRawData[6];
            rawData[6] = valueRawData[9];
            rawData[9] = temp;
            temp = valueRawData[3];
            rawData[3] = valueRawData[12];
            rawData[12] = temp;
            temp = valueRawData[7];
            rawData[7] = valueRawData[13];
            rawData[13] = temp;
            temp = valueRawData[11];
            rawData[11] = valueRawData[14];
            rawData[14] = temp;
            return this;
        };
        Matrix4.prototype.inverse = function (source) {
            if (!source) {
                source = this;
            }
            var valueRawData = source.rawData;
            var rawData = this.rawData;
            var n11 = valueRawData[0], n21 = valueRawData[1], n31 = valueRawData[2], n41 = valueRawData[3], n12 = valueRawData[4], n22 = valueRawData[5], n32 = valueRawData[6], n42 = valueRawData[7], n13 = valueRawData[8], n23 = valueRawData[9], n33 = valueRawData[10], n43 = valueRawData[11], n14 = valueRawData[12], n24 = valueRawData[13], n34 = valueRawData[14], n44 = valueRawData[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
            var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (det === 0.0) {
                console.warn("Cannot invert matrix, determinant is 0.");
                return this.identity();
            }
            var detInv = 1.0 / det;
            rawData[0] = t11 * detInv;
            rawData[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
            rawData[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
            rawData[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
            rawData[4] = t12 * detInv;
            rawData[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
            rawData[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
            rawData[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
            rawData[8] = t13 * detInv;
            rawData[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
            rawData[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
            rawData[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
            rawData[12] = t14 * detInv;
            rawData[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
            rawData[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
            rawData[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
            return this;
        };
        Matrix4.prototype.multiplyScalar = function (value, source) {
            if (!source) {
                source = this;
            }
            var sourceRawData = source.rawData;
            var rawData = this.rawData;
            rawData[0] = sourceRawData[0] * value;
            rawData[1] = sourceRawData[1] * value;
            rawData[2] = sourceRawData[2] * value;
            rawData[3] = sourceRawData[3] * value;
            rawData[4] = sourceRawData[4] * value;
            rawData[5] = sourceRawData[5] * value;
            rawData[6] = sourceRawData[6] * value;
            rawData[7] = sourceRawData[7] * value;
            rawData[8] = sourceRawData[8] * value;
            rawData[9] = sourceRawData[9] * value;
            rawData[10] = sourceRawData[10] * value;
            rawData[11] = sourceRawData[11] * value;
            rawData[12] = sourceRawData[12] * value;
            rawData[13] = sourceRawData[13] * value;
            rawData[14] = sourceRawData[14] * value;
            rawData[15] = sourceRawData[15] * value;
        };
        Matrix4.prototype.multiply = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            var rawDataA = valueA.rawData;
            var rawDataB = valueB.rawData;
            var rawData = this.rawData;
            var a11 = rawDataA[0], a12 = rawDataA[4], a13 = rawDataA[8], a14 = rawDataA[12];
            var a21 = rawDataA[1], a22 = rawDataA[5], a23 = rawDataA[9], a24 = rawDataA[13];
            var a31 = rawDataA[2], a32 = rawDataA[6], a33 = rawDataA[10], a34 = rawDataA[14];
            var a41 = rawDataA[3], a42 = rawDataA[7], a43 = rawDataA[11], a44 = rawDataA[15];
            var b11 = rawDataB[0], b12 = rawDataB[4], b13 = rawDataB[8], b14 = rawDataB[12];
            var b21 = rawDataB[1], b22 = rawDataB[5], b23 = rawDataB[9], b24 = rawDataB[13];
            var b31 = rawDataB[2], b32 = rawDataB[6], b33 = rawDataB[10], b34 = rawDataB[14];
            var b41 = rawDataB[3], b42 = rawDataB[7], b43 = rawDataB[11], b44 = rawDataB[15];
            rawData[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            rawData[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            rawData[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            rawData[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            rawData[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            rawData[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            rawData[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            rawData[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            rawData[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            rawData[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            rawData[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            rawData[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            rawData[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            rawData[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            rawData[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            rawData[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            return this;
        };
        Matrix4.prototype.premultiply = function (value) {
            this.multiply(value, this);
            return this;
        };
        Matrix4.prototype.lerp = function (t, value, source) {
            if (!source) {
                source = this;
            }
            var p = 1.0 - t;
            for (var i = 0; i < 16; i++) {
                this.rawData[i] = source.rawData[i] * p + value.rawData[i] * t;
            }
            return this;
        };
        /**
         *
         * - 两点位置不重合。
         * @param eye
         * @param target
         * @param up
         */
        Matrix4.prototype.lookAt = function (eye, target, up) {
            this.lookRotation(_helpVector3C.subtract(target, eye).normalize(), up); // left-hand coordinates system.
            return this;
        };
        /**
         *
         */
        Matrix4.prototype.lookRotation = function (value, up) {
            var x = _helpVector3A.cross(up, value).normalize(undefined, egret3d.Vector3.RIGHT);
            var y = _helpVector3B.cross(value, x);
            var rawData = this.rawData;
            rawData[0] = x.x;
            rawData[4] = y.x;
            rawData[8] = value.x;
            rawData[1] = x.y;
            rawData[5] = y.y;
            rawData[9] = value.y;
            rawData[2] = x.z;
            rawData[6] = y.z;
            rawData[10] = value.z;
            return this;
        };
        Matrix4.prototype.getMaxScaleOnAxis = function () {
            var rawData = this.rawData;
            var scaleXSq = rawData[0] * rawData[0] + rawData[1] * rawData[1] + rawData[2] * rawData[2];
            var scaleYSq = rawData[4] * rawData[4] + rawData[5] * rawData[5] + rawData[6] * rawData[6];
            var scaleZSq = rawData[8] * rawData[8] + rawData[9] * rawData[9] + rawData[10] * rawData[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        };
        Matrix4.prototype.toArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            if (!value) {
                value = [];
            }
            for (var i = 0; i < 16; ++i) {
                value[i + offset] = this.rawData[i];
            }
            return value;
        };
        Matrix4.prototype.toEuler = function (value, order) {
            if (order === void 0) { order = 2 /* YXZ */; }
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var rawData = this.rawData;
            var m11 = rawData[0], m12 = rawData[4], m13 = rawData[8];
            var m21 = rawData[1], m22 = rawData[5], m23 = rawData[9];
            var m31 = rawData[2], m32 = rawData[6], m33 = rawData[10];
            switch (order) {
                case 0 /* XYZ */: {
                    value.y = Math.asin(egret3d.floatClamp(m13, -1.0, 1.0));
                    if (Math.abs(m13) < 0.999999) {
                        value.x = Math.atan2(-m23, m33);
                        value.z = Math.atan2(-m12, m11);
                    }
                    else {
                        value.x = Math.atan2(m32, m22);
                        value.z = 0.0;
                    }
                    break;
                }
                case 1 /* XZY */: {
                    value.z = Math.asin(-egret3d.floatClamp(m12, -1.0, 1.0));
                    if (Math.abs(m12) < 0.999999) {
                        value.x = Math.atan2(m32, m22);
                        value.y = Math.atan2(m13, m11);
                    }
                    else {
                        value.x = Math.atan2(-m23, m33);
                        value.y = 0.0;
                    }
                    break;
                }
                case 2 /* YXZ */: {
                    value.x = Math.asin(-egret3d.floatClamp(m23, -1.0, 1.0));
                    if (Math.abs(m23) < 0.999999) {
                        value.y = Math.atan2(m13, m33);
                        value.z = Math.atan2(m21, m22);
                    }
                    else {
                        value.y = Math.atan2(-m31, m11);
                        value.z = 0.0;
                    }
                    break;
                }
                case 3 /* YZX */: {
                    value.z = Math.asin(egret3d.floatClamp(m21, -1.0, 1.0));
                    if (Math.abs(m21) < 0.999999) {
                        value.x = Math.atan2(-m23, m22);
                        value.y = Math.atan2(-m31, m11);
                    }
                    else {
                        value.x = 0.0;
                        value.y = Math.atan2(m13, m33);
                    }
                    break;
                }
                case 4 /* ZXY */: {
                    value.x = Math.asin(egret3d.floatClamp(m32, -1.0, 1.0));
                    if (Math.abs(m32) < 0.999999) {
                        value.y = Math.atan2(-m31, m33);
                        value.z = Math.atan2(-m12, m22);
                    }
                    else {
                        value.y = 0.0;
                        value.z = Math.atan2(m21, m11);
                    }
                    break;
                }
                case 5 /* ZYX */: {
                    value.y = Math.asin(-egret3d.floatClamp(m31, -1.0, 1.0));
                    if (Math.abs(m31) < 0.999999) {
                        value.x = Math.atan2(m32, m33);
                        value.z = Math.atan2(m21, m11);
                    }
                    else {
                        value.x = 0.0;
                        value.z = Math.atan2(-m12, m22);
                    }
                    break;
                }
            }
            return value;
        };
        /**
         * @deprecated
         */
        Matrix4.prototype.transformVector3 = function (value, out) {
            var x = (value.x * this.rawData[0]) + (value.y * this.rawData[4]) + (value.z * this.rawData[8]) + this.rawData[12];
            var y = (value.x * this.rawData[1]) + (value.y * this.rawData[5]) + (value.z * this.rawData[9]) + this.rawData[13];
            var z = (value.x * this.rawData[2]) + (value.y * this.rawData[6]) + (value.z * this.rawData[10]) + this.rawData[14];
            var w = (value.x * this.rawData[3]) + (value.y * this.rawData[7]) + (value.z * this.rawData[11]) + this.rawData[15];
            if (!out) {
                out = value;
            }
            out.x = x / w;
            out.y = y / w;
            out.z = z / w;
            return out;
        };
        /**
         * @deprecated
         */
        Matrix4.prototype.transformNormal = function (value, out) {
            var x = (value.x * this.rawData[0]) + (value.y * this.rawData[4]) + (value.z * this.rawData[8]);
            var y = (value.x * this.rawData[1]) + (value.y * this.rawData[5]) + (value.z * this.rawData[9]);
            var z = (value.x * this.rawData[2]) + (value.y * this.rawData[6]) + (value.z * this.rawData[10]);
            if (!out) {
                out = value;
            }
            out.x = x;
            out.y = y;
            out.z = z;
            return out;
        };
        /**
         * @deprecated
         */
        Matrix4.prototype.scale = function (scaler) {
            var rawData = this.rawData;
            rawData[0] *= scaler;
            rawData[1] *= scaler;
            rawData[2] *= scaler;
            rawData[3] *= scaler;
            rawData[4] *= scaler;
            rawData[5] *= scaler;
            rawData[6] *= scaler;
            rawData[7] *= scaler;
            rawData[8] *= scaler;
            rawData[9] *= scaler;
            rawData[10] *= scaler;
            rawData[11] *= scaler;
            rawData[12] *= scaler;
            rawData[13] *= scaler;
            rawData[14] *= scaler;
            rawData[15] *= scaler;
            return this;
        };
        /**
         * @deprecated
         */
        Matrix4.prototype.add = function (left, right) {
            if (!right) {
                right = left;
                left = this;
            }
            this.rawData[0] = left.rawData[0] + right.rawData[0];
            this.rawData[1] = left.rawData[1] + right.rawData[1];
            this.rawData[2] = left.rawData[2] + right.rawData[2];
            this.rawData[3] = left.rawData[3] + right.rawData[3];
            this.rawData[4] = left.rawData[4] + right.rawData[4];
            this.rawData[5] = left.rawData[5] + right.rawData[5];
            this.rawData[6] = left.rawData[6] + right.rawData[6];
            this.rawData[7] = left.rawData[7] + right.rawData[7];
            this.rawData[8] = left.rawData[8] + right.rawData[8];
            this.rawData[9] = left.rawData[9] + right.rawData[9];
            this.rawData[10] = left.rawData[10] + right.rawData[10];
            this.rawData[11] = left.rawData[11] + right.rawData[11];
            this.rawData[12] = left.rawData[12] + right.rawData[12];
            this.rawData[13] = left.rawData[13] + right.rawData[13];
            this.rawData[14] = left.rawData[14] + right.rawData[14];
            this.rawData[15] = left.rawData[15] + right.rawData[15];
            return this;
        };
        /**
         * @deprecated
         */
        Matrix4.perspectiveProjectLH = function (fov, aspect, znear, zfar, out) {
            var tan = 1.0 / (Math.tan(fov * 0.5));
            out.rawData[0] = tan / aspect;
            out.rawData[1] = out.rawData[2] = out.rawData[3] = 0.0;
            out.rawData[4] = out.rawData[6] = out.rawData[7] = 0.0;
            out.rawData[5] = tan;
            out.rawData[8] = out.rawData[9] = 0.0;
            out.rawData[10] = (zfar + znear) / (zfar - znear);
            out.rawData[11] = 1.0;
            out.rawData[12] = out.rawData[13] = out.rawData[15] = 0.0;
            out.rawData[14] = -2 * (znear * zfar) / (zfar - znear);
            return out;
        };
        /**
         * @deprecated
         */
        Matrix4.orthoProjectLH = function (width, height, znear, zfar, out) {
            var hw = 2.0 / width;
            var hh = 2.0 / height;
            var id = 2.0 / (zfar - znear);
            var nid = (znear + zfar) / (znear - zfar);
            out.rawData[0] = hw;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = hh;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = id;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = nid;
            out.rawData[15] = 1;
            return out;
        };
        Matrix4.IDENTITY = new Matrix4();
        Matrix4._instances = [];
        return Matrix4;
    }(paper.BaseRelease));
    egret3d.Matrix4 = Matrix4;
    __reflect(Matrix4.prototype, "egret3d.Matrix4", ["paper.ICCS", "paper.ISerializable"]);
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpVector3C = egret3d.Vector3.create();
    var _helpMatrix = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixA = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixB = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixC = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixD = Matrix4.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var BaseObjectAsset = (function (_super) {
        __extends(BaseObjectAsset, _super);
        function BaseObjectAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._raw = null;
            return _this;
        }
        /**
         * @internal
         */
        BaseObjectAsset.prototype.$parse = function (json) {
            this._raw = json;
        };
        BaseObjectAsset.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            this._raw = null;
            return true;
        };
        BaseObjectAsset.prototype.caclByteLength = function () {
            return 0;
        };
        return BaseObjectAsset;
    }(paper.Asset));
    paper.BaseObjectAsset = BaseObjectAsset;
    __reflect(BaseObjectAsset.prototype, "paper.BaseObjectAsset");
    /**
     * scene asset
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 场景数据资源
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var RawScene = (function (_super) {
        __extends(RawScene, _super);
        function RawScene() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @internal
         */
        RawScene.prototype.createInstance = function (keepUUID) {
            if (keepUUID === void 0) { keepUUID = false; }
            if (!this._raw) {
                return null;
            }
            var isEditor = paper.Application.playerMode === 2 /* Editor */;
            var deserializer = new paper.Deserializer();
            var scene = deserializer.deserialize(this._raw, keepUUID);
            if (scene && isEditor) {
            }
            return scene;
        };
        return RawScene;
    }(BaseObjectAsset));
    paper.RawScene = RawScene;
    __reflect(RawScene.prototype, "paper.RawScene");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @private
     */
    var RendererEventType;
    (function (RendererEventType) {
        RendererEventType["Materials"] = "materials";
    })(RendererEventType = paper.RendererEventType || (paper.RendererEventType = {}));
    /**
     * 基础渲染器。
     */
    var BaseRenderer = (function (_super) {
        __extends(BaseRenderer, _super);
        function BaseRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 是否开启视锥剔除。
             */
            _this.frustumCulled = true;
            /**
             * @internal
             */
            _this._aabbDirty = true;
            /**
             * @internal
             */
            _this._boundingSphereDirty = true;
            _this._receiveShadows = false;
            _this._castShadows = false;
            _this._lightmapIndex = -1;
            _this._boundingSphere = egret3d.Sphere.create();
            _this._aabb = egret3d.AABB.create();
            return _this;
        }
        BaseRenderer.prototype._recalculateSphere = function () {
            var aabb = this.aabb; // Update aabb.
            var worldMatrix = this.gameObject.transform.getWorldMatrix();
            this._boundingSphere.set(aabb.center, aabb.boundingSphereRadius);
            this._boundingSphere.center.applyMatrix(worldMatrix);
            this._boundingSphere.radius *= worldMatrix.getMaxScaleOnAxis();
        };
        Object.defineProperty(BaseRenderer.prototype, "receiveShadows", {
            /**
             * 该渲染器是否接收投影。
             */
            get: function () {
                return this._receiveShadows;
            },
            set: function (value) {
                if (value === this._receiveShadows) {
                    return;
                }
                this._receiveShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "castShadows", {
            /**
             * 该渲染器是否产生投影。
             */
            get: function () {
                return this._castShadows;
            },
            set: function (value) {
                if (value === this._castShadows) {
                    return;
                }
                this._castShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "lightmapIndex", {
            /**
             * 该渲染器的光照图的索引。
             */
            get: function () {
                return this._lightmapIndex;
            },
            set: function (value) {
                if (value === this._lightmapIndex) {
                    return;
                }
                this._lightmapIndex = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "aabb", {
            /**
             *
             */
            get: function () {
                if (this._aabbDirty) {
                    this.recalculateAABB();
                    this._aabbDirty = false;
                }
                return this._aabb;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "boundingSphere", {
            /**
             *
             */
            get: function () {
                if (this._boundingSphereDirty) {
                    this._recalculateSphere();
                    this._boundingSphereDirty = false;
                }
                return this._boundingSphere;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField,
            paper.editor.property(4 /* CHECKBOX */)
        ], BaseRenderer.prototype, "frustumCulled", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_receiveShadows", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_castShadows", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_lightmapIndex", void 0);
        __decorate([
            paper.editor.property(4 /* CHECKBOX */)
        ], BaseRenderer.prototype, "receiveShadows", null);
        __decorate([
            paper.editor.property(4 /* CHECKBOX */)
        ], BaseRenderer.prototype, "castShadows", null);
        __decorate([
            paper.editor.property(1 /* INT */, { minimum: -1 })
        ], BaseRenderer.prototype, "lightmapIndex", null);
        return BaseRenderer;
    }(paper.BaseComponent));
    paper.BaseRenderer = BaseRenderer;
    __reflect(BaseRenderer.prototype, "paper.BaseRenderer", ["egret3d.IRaycast"]);
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Vector4 = (function (_super) {
        __extends(Vector4, _super);
        /**
         * 请使用 `egret3d.Vector4.create(); egret3d.Quaternion.create()` 创建实例。
         * @see egret3d.Quaternion.create()
         * @see egret3d.Vector4.create()
         * @deprecated
         */
        function Vector4(x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.z = z;
            _this.w = w;
            return _this;
        }
        /**
         *
         */
        Vector4.create = function (x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, z, w);
                instance._released = false;
                return instance;
            }
            return new Vector4().set(x, y, z, w);
        };
        Vector4.prototype.serialize = function () {
            return [this.x, this.y, this.z, this.w];
        };
        Vector4.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Vector4.prototype.copy = function (value) {
            return this.set(value.x, value.y, value.z, value.w);
        };
        Vector4.prototype.clone = function () {
            return Vector4.create(this.x, this.y, this.z, this.w);
        };
        Vector4.prototype.set = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        Vector4.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = value[offset];
            this.y = value[offset + 1];
            this.z = value[offset + 2];
            this.w = value[offset + 3];
            return this;
        };
        Vector4.prototype.normalize = function (source) {
            if (!source) {
                source = this;
            }
            var l = Math.sqrt(source.x * source.x + source.y * source.y + source.z * source.z + source.w * source.w);
            if (l > egret3d.EPSILON) {
                l = 1.0 / l;
                this.x *= l;
                this.y *= l;
                this.z *= l;
                this.w *= l;
            }
            else {
                this.x = 0.0;
                this.y = 0.0;
                this.z = 0.0;
                this.w = 1.0;
            }
            return this;
        };
        Vector4.prototype.toArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            value[0 + offset] = this.x;
            value[1 + offset] = this.y;
            value[2 + offset] = this.z;
            value[3 + offset] = this.w;
            return value;
        };
        Object.defineProperty(Vector4.prototype, "length", {
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector4.prototype, "squaredLength", {
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            },
            enumerable: true,
            configurable: true
        });
        Vector4._instances = [];
        return Vector4;
    }(paper.BaseRelease));
    egret3d.Vector4 = Vector4;
    __reflect(Vector4.prototype, "egret3d.Vector4", ["egret3d.IVector4", "egret3d.IVector3", "egret3d.IVector2", "paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * glTF 资源。
     */
    var GLTFAsset = (function (_super) {
        __extends(GLTFAsset, _super);
        function GLTFAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Buffer 列表。
             */
            _this.buffers = [];
            /**
             * 配置。
             */
            _this.config = null;
            return _this;
        }
        /**
         *
         */
        GLTFAsset._createConfig = function () {
            var config = {
                version: "4",
                asset: {
                    version: "2.0"
                },
                extensions: {},
                extensionsRequired: ["paper"],
                extensionsUsed: ["paper"],
            };
            return config;
        };
        /**
         * 从二进制数据中解析。
         */
        GLTFAsset.parseFromBinary = function (array) {
            var index = 0;
            var result = { config: {}, buffers: [] };
            if (array[index++] !== 0x46546C67 ||
                array[index++] !== 2) {
                console.assert(false, "Nonsupport glTF data.");
                return;
            }
            if (array[index++] !== array.byteLength) {
                console.assert(false, "Error glTF data.");
                return;
            }
            var chunkLength = 0;
            var chunkType = 0;
            while (index < array.length) {
                chunkLength = array[index++];
                chunkType = array[index++];
                if (chunkLength % 4) {
                    console.assert(false, "Error glTF data.");
                }
                if (chunkType === 0x4E4F534A) {
                    var jsonArray = new Uint8Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint8Array.BYTES_PER_ELEMENT);
                    var jsonString = egret3d.io.BinReader.utf8ArrayToString(jsonArray);
                    result.config = JSON.parse(jsonString);
                }
                else if (chunkType === 0x004E4942) {
                    var buffer = new Uint32Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint32Array.BYTES_PER_ELEMENT);
                    result.buffers.push(buffer);
                }
                else {
                    console.assert(false, "Nonsupport glTF data.");
                    return;
                }
                index += chunkLength / 4;
            }
            return result;
        };
        /**
         *
         */
        GLTFAsset.createMeshConfig = function () {
            var config = this._createConfig();
            config.buffers = [{ byteLength: 0 }];
            config.bufferViews = [{ buffer: 0, byteOffset: 0, byteLength: 0, target: 34962 /* ArrayBuffer */ }]; // VBO
            config.accessors = [];
            config.meshes = [{
                    primitives: [{ attributes: {} }],
                    extensions: { paper: {} },
                }];
            return config;
        };
        /**
         *
         */
        GLTFAsset.createGLTFExtensionsConfig = function () {
            var config = this._createConfig();
            config.materials = [];
            config.extensions = {
                KHR_techniques_webgl: {
                    shaders: [],
                    techniques: [],
                    programs: [],
                },
                paper: {},
            };
            return config;
        };
        GLTFAsset.createTechnique = function (source) {
            var target = { name: source.name, attributes: {}, uniforms: {} }; // , states: { enable: [], functions: {} }
            for (var key in source.attributes) {
                var attribute = source.attributes[key];
                target.attributes[key] = { semantic: attribute.semantic };
            }
            for (var key in source.uniforms) {
                var uniform = source.uniforms[key];
                var value = void 0;
                if (uniform.type === 35678 /* SAMPLER_2D */ && !uniform.value) {
                    value = egret3d.DefaultTextures.WHITE; // Default texture.
                }
                else if (Array.isArray(uniform.value)) {
                    value = uniform.value ? uniform.value.concat() : [];
                }
                else {
                    value = uniform.value ? uniform.value : [];
                }
                var targetUniform = target.uniforms[key] = { type: uniform.type, value: value };
                if (uniform.semantic) {
                    targetUniform.semantic = uniform.semantic;
                }
            }
            // if (source.states) {
            //     const states = GLTFAsset.copyTechniqueStates(source.states);
            //     if (states) {
            //         target.states = states;
            //     }
            // }
            return target;
        };
        GLTFAsset.copyTechniqueStates = function (source, target) {
            if (source.enable && source.enable.length > 0) {
                if (!target) {
                    target = {};
                }
                target.enable = source.enable.concat();
            }
            if (source.functions) {
                for (var k in source.functions) {
                    if (!target) {
                        target = {};
                    }
                    if (!target.functions) {
                        target.functions = {};
                    }
                    if (Array.isArray(source.functions[k])) {
                        target.functions[k] = source.functions[k].concat();
                    }
                    else {
                        target.functions[k] = source.functions[k];
                    }
                }
            }
            return target;
        };
        GLTFAsset.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            this.buffers.length = 0; // TODO clear buffer.
            this.config = null;
            return true;
        };
        GLTFAsset.prototype.caclByteLength = function () {
            return 0;
        };
        /**
         * 根据指定 BufferView 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromBufferView = function (bufferView, componentType) {
            var buffer = this.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0);
            // assert.config.buffers[bufferView.buffer];
            switch (componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int8Array.BYTES_PER_ELEMENT);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint8Array.BYTES_PER_ELEMENT);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int16Array.BYTES_PER_ELEMENT);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                case 5124 /* Int */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int32Array.BYTES_PER_ELEMENT);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint32Array.BYTES_PER_ELEMENT);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Float32Array.BYTES_PER_ELEMENT);
                default:
                    throw new Error();
            }
        };
        /**
         * 根据指定 Accessor 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromAccessor = function (accessor, offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            var accessorTypeCount = this.getAccessorTypeCount(accessor.type);
            var bufferCount = accessorTypeCount * Math.min(accessor.count - offset, count || accessor.count);
            var bufferView = this.getBufferView(accessor);
            var buffer = this.buffers[bufferView.buffer];
            // assert.config.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
            if (offset > 0) {
                bufferOffset += offset * accessorTypeCount * this.getComponentTypeCount(accessor.componentType);
            }
            switch (accessor.componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5124 /* Int */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferCount);
                default:
                    throw new Error();
            }
        };
        /**
         *
         */
        GLTFAsset.prototype.getComponentTypeCount = function (type) {
            switch (type) {
                case 5120 /* Byte */:
                case 5121 /* UnsignedByte */:
                    return 1;
                case 5122 /* Short */:
                case 5123 /* UnsignedShort */:
                    return 2;
                case 5124 /* Int */:
                case 5125 /* UnsignedInt */:
                    return 4;
                case 5126 /* Float */:
                    return 4;
                default:
                    throw new Error();
            }
        };
        /**
         *
         */
        GLTFAsset.prototype.getAccessorTypeCount = function (type) {
            switch (type) {
                case "SCALAR" /* SCALAR */:
                    return 1;
                case "VEC2" /* VEC2 */:
                    return 2;
                case "VEC3" /* VEC3 */:
                    return 3;
                case "VEC4" /* VEC4 */:
                case "MAT2" /* MAT2 */:
                    return 4;
                case "MAT3" /* MAT3 */:
                    return 9;
                case "MAT4" /* MAT4 */:
                    return 16;
                default:
                    throw new Error();
            }
        };
        /**
         * 自定义 Mesh 的属性枚举。
         */
        GLTFAsset.prototype.getMeshAttributeType = function (type) {
            switch (type) {
                case "POSITION" /* POSITION */:
                case "NORMAL" /* NORMAL */:
                    return "VEC3" /* VEC3 */;
                case "TEXCOORD_0" /* TEXCOORD_0 */:
                case "TEXCOORD_1" /* TEXCOORD_1 */:
                    return "VEC2" /* VEC2 */;
                case "TANGENT" /* TANGENT */:
                case "COLOR_0" /* COLOR_0 */:
                case "COLOR_1" /* COLOR_1 */:
                case "JOINTS_0" /* JOINTS_0 */:
                case "WEIGHTS_0" /* WEIGHTS_0 */:
                    return "VEC4" /* VEC4 */;
                default:
                    throw new Error();
            }
        };
        /**
         * 通过 Accessor 获取指定 BufferLength。
         */
        GLTFAsset.prototype.getBufferLength = function (accessor) {
            return this.getAccessorTypeCount(accessor.type) * this.getComponentTypeCount(accessor.componentType) * accessor.count;
        };
        /**
         * 通过 Accessor 获取指定 BufferOffset。
         */
        GLTFAsset.prototype.getBufferOffset = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // const buffer = this.buffers[bufferView.buffer];
            return (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
        };
        /**
         * 通过 Accessor 获取指定 Buffer。
         */
        GLTFAsset.prototype.getBuffer = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // this.config.buffers[bufferView.buffer];
            return this.buffers[bufferView.buffer];
        };
        /**
         * 通过 Accessor 获取指定 BufferView。
         */
        GLTFAsset.prototype.getBufferView = function (accessor) {
            return this.config.bufferViews[accessor.bufferView || 0];
        };
        /**
         * 通过 Accessor 索引，获取指定 Accessor。
         */
        GLTFAsset.prototype.getAccessor = function (index) {
            return this.config.accessors[index];
        };
        /**
         * 获取节点。
         */
        GLTFAsset.prototype.getNode = function (index) {
            return this.config.nodes[index];
        };
        /*
         * 获取动画剪辑。
         */
        GLTFAsset.prototype.getAnimationClip = function (name) {
            if (!this.config.animations ||
                this.config.animations.length === 0) {
                return null;
            }
            var animation = this.config.animations[0];
            if (animation.extensions.paper.clips.length === 0) {
                return null;
            }
            if (!name) {
                return animation.extensions.paper.clips[0];
            }
            for (var _i = 0, _a = this.config.animations; _i < _a.length; _i++) {
                var animation_1 = _a[_i];
                for (var _b = 0, _c = animation_1.extensions.paper.clips; _b < _c.length; _b++) {
                    var animationClip = _c[_b];
                    if (animationClip.name === name) {
                        return animationClip;
                    }
                }
            }
            return null;
        };
        return GLTFAsset;
    }(paper.Asset));
    egret3d.GLTFAsset = GLTFAsset;
    __reflect(GLTFAsset.prototype, "egret3d.GLTFAsset");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 纹理资源。
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Texture.prototype.caclByteLength = function () {
            return 0;
        };
        return Texture;
    }(paper.Asset));
    egret3d.Texture = Texture;
    __reflect(Texture.prototype, "egret3d.Texture");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpVector3C = egret3d.Vector3.create();
    var _helpMatrix = egret3d.Matrix4.create();
    var _helpRaycastInfo = egret3d.RaycastInfo.create();
    var _attributeNames = [
        "POSITION" /* POSITION */,
        "NORMAL" /* NORMAL */,
        "TEXCOORD_0" /* TEXCOORD_0 */,
    ];
    /**
     * 网格基类。
     */
    var BaseMesh = (function (_super) {
        __extends(BaseMesh, _super);
        function BaseMesh(vertexCountOrConfig, indexCountOrBuffers, attributeNamesOrName, attributeTypes, drawMode) {
            var _this = _super.call(this, typeof attributeNamesOrName === "string" ? attributeNamesOrName : "") || this;
            _this._drawMode = 35044 /* Static */;
            _this._vertexCount = 0;
            _this._attributeNames = [];
            _this._customAttributeTypes = {};
            _this._glTFMesh = null;
            _this._helpVertices = null;
            if (typeof vertexCountOrConfig === "number") {
                vertexCountOrConfig = vertexCountOrConfig || 3;
                indexCountOrBuffers = indexCountOrBuffers || 0;
                _this.config = egret3d.GLTFAsset.createMeshConfig();
                //
                var buffer = _this.config.buffers[0];
                var vertexBufferView = _this.config.bufferViews[0];
                var accessors = _this.config.accessors;
                var attributes = _this.config.meshes[0].primitives[0].attributes;
                //
                var hasCustomAttributeType = false;
                if (attributeTypes) {
                    for (var k in attributeTypes) {
                        hasCustomAttributeType = true;
                        _this._customAttributeTypes[k] = attributeTypes[k];
                    }
                }
                for (var _i = 0, _a = (attributeNamesOrName || _attributeNames); _i < _a.length; _i++) {
                    var attributeName = _a[_i];
                    var attributeType = hasCustomAttributeType ? _this._customAttributeTypes[attributeName] || _this.getMeshAttributeType(attributeName) : _this.getMeshAttributeType(attributeName);
                    var byteOffset = vertexBufferView.byteLength;
                    vertexBufferView.byteLength += vertexCountOrConfig * _this.getAccessorTypeCount(attributeType) * Float32Array.BYTES_PER_ELEMENT;
                    attributes[attributeName] = accessors.length;
                    accessors.push({
                        bufferView: 0,
                        byteOffset: byteOffset,
                        count: vertexCountOrConfig,
                        normalized: attributeName === "NORMAL" /* NORMAL */ || attributeName === "TANGENT" /* TANGENT */,
                        componentType: 5126 /* Float */,
                        type: attributeType,
                    });
                }
                buffer.byteLength = vertexBufferView.byteLength;
                _this.buffers[0] = new Float32Array(vertexBufferView.byteLength / Float32Array.BYTES_PER_ELEMENT);
                _this._drawMode = drawMode || 35044 /* Static */;
                if (indexCountOrBuffers > 0) {
                    _this.addSubMesh(indexCountOrBuffers, 0);
                }
                else {
                    _this.config.meshes[0].primitives[0].material = 0;
                }
            }
            else {
                _this.config = vertexCountOrConfig;
                for (var _b = 0, _c = indexCountOrBuffers; _b < _c.length; _b++) {
                    var buffer = _c[_b];
                    _this.buffers.push(buffer);
                }
                _this.name = attributeNamesOrName;
            }
            _this._glTFMesh = _this.config.meshes[0];
            _this._vertexCount = _this.getAccessor(_this._glTFMesh.primitives[0].attributes.POSITION || 0).count;
            for (var k in _this._glTFMesh.primitives[0].attributes) {
                _this._attributeNames.push(k);
            }
            return _this;
        }
        /**
         *
         */
        BaseMesh.prototype.clone = function () {
            var value = new egret3d.Mesh(this.vertexCount, 0, this._attributeNames, this._customAttributeTypes, this.drawMode);
            for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                if (primitive.indices !== undefined) {
                    var accessor = this.getAccessor(primitive.indices);
                    value.addSubMesh(accessor.count, primitive.material, primitive.mode);
                }
            }
            var index = 0;
            for (var _b = 0, _c = this.config.bufferViews; _b < _c.length; _b++) {
                var bufferViewA = _c[_b];
                var bufferViewB = value.config.bufferViews[index++];
                var a = this.createTypeArrayFromBufferView(bufferViewA, 5125 /* UnsignedInt */);
                var b = value.createTypeArrayFromBufferView(bufferViewB, 5125 /* UnsignedInt */);
                for (var i = 0, l = a.length; i < l; ++i) {
                    b[i] = a[i];
                }
            }
            return value;
        };
        /**
         * TODO applyMatrix
         */
        /**
         *
         */
        BaseMesh.prototype.raycast = function (ray, raycastInfo, boneMatrices) {
            var subMeshIndex = 0;
            var p0 = _helpVector3A;
            var p1 = _helpVector3B;
            var p2 = _helpVector3C;
            var vertices = this.getVertices();
            var joints = boneMatrices ? this.getAttributes("JOINTS_0" /* JOINTS_0 */) : null;
            var weights = boneMatrices ? this.getAttributes("WEIGHTS_0" /* WEIGHTS_0 */) : null;
            var hit = false;
            for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var indices = primitive.indices !== undefined ? this.getIndices(subMeshIndex) : null;
                var castVertices = vertices;
                if (boneMatrices) {
                    if (!this._helpVertices) {
                        this._helpVertices = new Float32Array(vertices.length);
                    }
                    castVertices = this._helpVertices;
                    if (indices) {
                        for (var _b = 0, _c = indices; _b < _c.length; _b++) {
                            var index = _c[_b];
                            var vertexIndex = index * 3;
                            var jointIndex = index * 4;
                            p0.fromArray(vertices, vertexIndex);
                            p1
                                .set(0.0, 0.0, 0.0)
                                .add(p2.applyMatrix(_helpMatrix.fromArray(boneMatrices, joints[jointIndex + 0] * 16), p0).multiplyScalar(weights[jointIndex + 0]))
                                .add(p2.applyMatrix(_helpMatrix.fromArray(boneMatrices, joints[jointIndex + 1] * 16), p0).multiplyScalar(weights[jointIndex + 1]))
                                .add(p2.applyMatrix(_helpMatrix.fromArray(boneMatrices, joints[jointIndex + 2] * 16), p0).multiplyScalar(weights[jointIndex + 2]))
                                .add(p2.applyMatrix(_helpMatrix.fromArray(boneMatrices, joints[jointIndex + 3] * 16), p0).multiplyScalar(weights[jointIndex + 3]))
                                .toArray(castVertices, vertexIndex);
                        }
                    }
                    else {
                        var index = 0;
                        for (var i = 0, l = vertices.length; i < l; i += 3) {
                            var jointIndex = (index++) * 3;
                            p0.fromArray(vertices, i);
                            p1
                                .set(0.0, 0.0, 0.0)
                                .add(p2.applyMatrix(_helpMatrix.fromArray(boneMatrices, joints[jointIndex + 0] * 16), p0).multiplyScalar(weights[jointIndex + 0]))
                                .add(p2.applyMatrix(_helpMatrix.fromArray(boneMatrices, joints[jointIndex + 1] * 16), p0).multiplyScalar(weights[jointIndex + 1]))
                                .add(p2.applyMatrix(_helpMatrix.fromArray(boneMatrices, joints[jointIndex + 2] * 16), p0).multiplyScalar(weights[jointIndex + 2]))
                                .add(p2.applyMatrix(_helpMatrix.fromArray(boneMatrices, joints[jointIndex + 3] * 16), p0).multiplyScalar(weights[jointIndex + 3]))
                                .toArray(castVertices, i);
                        }
                    }
                }
                switch (primitive.mode) {
                    case 0 /* Points */:
                        break;
                    case 1 /* Lines */:
                        break;
                    case 2 /* LineLoop */:
                        break;
                    case 3 /* LineStrip */:
                        break;
                    case 6 /* TrianglesFan */:
                        break;
                    case 5 /* TrianglesStrip */:
                        break;
                    case 4 /* Triangles */:
                    default:
                        if (indices) {
                            for (var i = 0, l = indices.length; i < l; i += 3) {
                                p0.fromArray(castVertices, indices[i] * 3);
                                p1.fromArray(castVertices, indices[i + 1] * 3);
                                p2.fromArray(castVertices, indices[i + 2] * 3);
                                if (raycastInfo) {
                                    if (ray.intersectTriangle(p0, p1, p2, false, _helpRaycastInfo)) {
                                        if (!hit || raycastInfo.distance > _helpRaycastInfo.distance) {
                                            raycastInfo.subMeshIndex = subMeshIndex;
                                            raycastInfo.triangleIndex = i / 3; // TODO
                                            raycastInfo.distance = _helpRaycastInfo.distance;
                                            raycastInfo.position.copy(_helpRaycastInfo.position);
                                            raycastInfo.textureCoordA.copy(_helpRaycastInfo.textureCoordA);
                                            raycastInfo.textureCoordB.copy(_helpRaycastInfo.textureCoordB);
                                            hit = true;
                                        }
                                    }
                                }
                                else if (ray.intersectTriangle(p0, p1, p2)) {
                                    return true;
                                }
                            }
                        }
                        else {
                            for (var i = 0, l = castVertices.length; i < l; i += 9) {
                                p0.fromArray(castVertices, i);
                                p1.fromArray(castVertices, i + 3);
                                p2.fromArray(castVertices, i + 6);
                                if (raycastInfo) {
                                    if (ray.intersectTriangle(p0, p1, p2, false, _helpRaycastInfo)) {
                                        if (!hit || raycastInfo.distance > _helpRaycastInfo.distance) {
                                            raycastInfo.subMeshIndex = subMeshIndex;
                                            raycastInfo.triangleIndex = i / 3; // TODO
                                            raycastInfo.distance = _helpRaycastInfo.distance;
                                            raycastInfo.position.copy(_helpRaycastInfo.position);
                                            raycastInfo.textureCoordA.copy(_helpRaycastInfo.textureCoordA);
                                            raycastInfo.textureCoordB.copy(_helpRaycastInfo.textureCoordB);
                                            hit = true;
                                        }
                                    }
                                }
                                else if (ray.intersectTriangle(p0, p1, p2)) {
                                    return true;
                                }
                            }
                        }
                        break;
                }
                subMeshIndex++;
            }
            return hit;
        };
        /**
         *
         */
        BaseMesh.prototype.addSubMesh = function (indexCount, materialIndex, randerMode) {
            if (materialIndex === void 0) { materialIndex = 0; }
            var accessors = this.config.accessors;
            var primitives = this.config.meshes[0].primitives;
            var subMeshIndex = this.buffers.length === primitives.length + 1 ? primitives.length : 0;
            var indexBufferView = this.config.bufferViews[subMeshIndex + 1] = {
                buffer: subMeshIndex + 1,
                byteOffset: 0,
                byteLength: indexCount * this.getAccessorTypeCount("SCALAR" /* SCALAR */) * Uint16Array.BYTES_PER_ELEMENT,
                target: 34963 /* ElementArrayBuffer */,
            };
            var primitive = primitives[subMeshIndex] = primitives[subMeshIndex] || {
                attributes: primitives[0].attributes,
            };
            primitive.indices = accessors.length;
            primitive.material = materialIndex;
            primitive.mode = randerMode;
            accessors.push({
                bufferView: subMeshIndex + 1, byteOffset: 0,
                count: indexCount,
                componentType: 5123 /* UnsignedShort */, type: "SCALAR" /* SCALAR */,
            });
            this.buffers[subMeshIndex + 1] = new Uint16Array(indexBufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
            this.config.buffers[subMeshIndex + 1] = { byteLength: indexBufferView.byteLength };
            return primitives.length - 1;
        };
        /**
         * 获取该网格顶点的位置属性数据。
         * - x0, y0, z0, x1, y1, z1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        BaseMesh.prototype.getVertices = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("POSITION" /* POSITION */, offset, count);
        };
        /**
         * 获取该网格顶点的 UV 属性数据。
         * - u0, v0, u1, v1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        BaseMesh.prototype.getUVs = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */, offset, count);
        };
        /**
         * 获取该网格顶点的颜色属性数据。
         * - r0, g0, b0, a0, r1, g1, b1, a1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        BaseMesh.prototype.getColors = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("COLOR_0" /* COLOR_0 */, offset, count);
        };
        /**
         * 获取该网格顶点的法线属性数据。
         * - x0, y0, z0, x1, y1, z1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        BaseMesh.prototype.getNormals = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("NORMAL" /* NORMAL */, offset, count);
        };
        /**
         * 获取该网格顶点的切线属性数据。
         * - x0, y0, z0, w0,  x1, y1, z1, w1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        BaseMesh.prototype.getTangents = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("TANGENT" /* TANGENT */, offset, count);
        };
        /**
         * 获取该网格顶点的指定属性数据。
         * @param attributeType 属性名。
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点总数。（默认全部顶点）
         */
        BaseMesh.prototype.getAttributes = function (attributeType, offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            var accessorIndex = this._glTFMesh.primitives[0].attributes[attributeType];
            if (accessorIndex === undefined) {
                return null;
            }
            return this.createTypeArrayFromAccessor(this.getAccessor(accessorIndex), offset, count);
        };
        /**
         * 设置该网格指定的顶点属性数据。
         * @param attributeType 属性名。
         * @param value 属性数据。
         * @param offset 顶点偏移。（默认从第一个点开始）
         */
        BaseMesh.prototype.setAttributes = function (attributeType, value, offset) {
            if (offset === void 0) { offset = 0; }
            var target = this.getAttributes(attributeType, offset);
            if (target) {
                for (var i = 0, l = Math.min(value.length, target.length); i < l; i++) {
                    target[i] = value[i];
                }
            }
            return target;
        };
        /**
         * 获取该网格的顶点索引数据。
         * @param subMeshIndex 子网格索引。（默认第一个子网格）
         */
        BaseMesh.prototype.getIndices = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var accessorIndex = this._glTFMesh.primitives[subMeshIndex].indices;
                if (accessorIndex === undefined) {
                    return null;
                }
                return this.createTypeArrayFromAccessor(this.getAccessor(accessorIndex));
            }
            console.warn("Error arguments.");
            return null;
        };
        /**
         * 设置该网格的顶点索引数据。
         * @param value 顶点索引数据。
         * @param subMeshIndex 子网格索引。（默认第一个子网格）
         * @param offset 索引偏移。（默认不偏移）
         */
        BaseMesh.prototype.setIndices = function (value, subMeshIndex, offset) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (offset === void 0) { offset = 0; }
            var target = this.getIndices(subMeshIndex);
            if (target) {
                for (var i = 0, l = Math.min(value.length, target.length); i < l; i++) {
                    target[i] = value[offset + i];
                }
            }
            return target;
        };
        Object.defineProperty(BaseMesh.prototype, "drawMode", {
            /**
             * 该网格的渲染模式。
             */
            get: function () {
                return this._drawMode;
            },
            set: function (value) {
                this._drawMode = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseMesh.prototype, "subMeshCount", {
            /**
             * 该网格的子网格总数。
             */
            get: function () {
                return this._glTFMesh.primitives.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseMesh.prototype, "vertexCount", {
            /**
             * 该网格的顶点总数。
             */
            get: function () {
                return this._vertexCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseMesh.prototype, "attributeNames", {
            /**
             * 该网格的全部顶点属性名称。
             */
            get: function () {
                return this._attributeNames;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseMesh.prototype, "glTFMesh", {
            /**
             * 获取该网格的 glTF mesh 数据。
             */
            get: function () {
                return this._glTFMesh;
            },
            enumerable: true,
            configurable: true
        });
        return BaseMesh;
    }(egret3d.GLTFAsset));
    egret3d.BaseMesh = BaseMesh;
    __reflect(BaseMesh.prototype, "egret3d.BaseMesh", ["egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    egret3d.RAD_DEG = 180.0 / Math.PI;
    /**
     *
     */
    egret3d.DEG_RAD = Math.PI / 180.0;
    /**
     *
     */
    egret3d.EPSILON = 2.220446049250313e-16; // Number.EPSILON
    function sign(value) {
        if (value === 0 || value !== value) {
            return value;
        }
        return value > 0 ? 1 : -1;
    }
    egret3d.sign = sign;
    function floatClamp(v, min, max) {
        if (min === void 0) { min = 0.0; }
        if (max === void 0) { max = 1.0; }
        if (v < min)
            return min;
        else if (v > max)
            return max;
        else
            return v;
    }
    egret3d.floatClamp = floatClamp;
    function numberLerp(fromV, toV, v) {
        return fromV * (1 - v) + toV * v;
    }
    egret3d.numberLerp = numberLerp;
    function getNormal(a, b, c, out) {
        out.subtract(c, b);
        egret3d.helpVector3A.subtract(a, b);
        out.cross(egret3d.helpVector3A);
        var squaredLength = out.squaredLength;
        if (squaredLength > 0.0) {
            return out.multiplyScalar(1.0 / Math.sqrt(squaredLength));
        }
        return out.set(0.0, 0.0, 1.0);
    }
    egret3d.getNormal = getNormal;
    function calPlaneLineIntersectPoint(planeVector, planePoint, lineVector, linePoint, out) {
        var vp1 = planeVector.x;
        var vp2 = planeVector.y;
        var vp3 = planeVector.z;
        var n1 = planePoint.x;
        var n2 = planePoint.y;
        var n3 = planePoint.z;
        var v1 = lineVector.x;
        var v2 = lineVector.y;
        var v3 = lineVector.z;
        var m1 = linePoint.x;
        var m2 = linePoint.y;
        var m3 = linePoint.z;
        var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
        if (vpt === 0) {
            return null;
        }
        else {
            var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
            out.x = m1 + v1 * t;
            out.y = m2 + v2 * t;
            out.z = m3 + v3 * t;
        }
        return out;
    }
    egret3d.calPlaneLineIntersectPoint = calPlaneLineIntersectPoint;
    function triangleIntersectsPlane() {
    }
    egret3d.triangleIntersectsPlane = triangleIntersectsPlane;
    function satForAxes(axes) {
        var v0 = egret3d.helpVector3A;
        var v1 = egret3d.helpVector3B;
        var v2 = egret3d.helpVector3C;
        var extents = egret3d.helpVector3H;
        var testAxis = egret3d.helpVector3A;
        for (var i = 0, l = axes.length - 3; i <= l; i += 3) {
            testAxis.fromArray(axes, i);
            // project the aabb onto the seperating axis
            var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
            // project all 3 vertices of the triangle onto the seperating axis
            var p0 = v0.dot(testAxis);
            var p1 = v1.dot(testAxis);
            var p2 = v2.dot(testAxis);
            // actual test, basically see if either of the most extreme of the triangle points intersects r
            if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
                // points of the projected triangle are outside the projected half-length of the aabb
                // the axis is seperating and we can exit
                return false;
            }
        }
        return true;
    }
    function triangleIntersectsAABB(triangle, aabb) {
        if (aabb.isEmpty) {
            return false;
        }
        var v0 = egret3d.helpVector3A;
        var v1 = egret3d.helpVector3B;
        var v2 = egret3d.helpVector3C;
        // triangle edge vectors
        var f0 = egret3d.helpVector3D;
        var f1 = egret3d.helpVector3E;
        var f2 = egret3d.helpVector3F;
        var center = egret3d.helpVector3G;
        var extents = egret3d.helpVector3H;
        // compute box center and extents
        extents.subtract(aabb.maximum, aabb.center);
        // translate triangle to aabb origin
        v0.subtract(triangle.a, center);
        v1.subtract(triangle.b, center);
        v2.subtract(triangle.c, center);
        // compute edge vectors for triangle
        f0.subtract(v1, v0);
        f1.subtract(v2, v1);
        f2.subtract(v0, v2);
        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
        var axes = [
            0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y,
            f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x,
            -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0
        ];
        if (!satForAxes(axes)) {
            return false;
        }
        // test 3 face normals from the aabb
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes(axes)) {
            return false;
        }
        // finally testing the face normal of the triangle
        // use already existing triangle edge vectors here
        egret3d.helpVector3A.cross(f0, f1);
        axes = [egret3d.helpVector3A.x, egret3d.helpVector3A.y, egret3d.helpVector3A.z];
        return satForAxes(axes);
    }
    egret3d.triangleIntersectsAABB = triangleIntersectsAABB;
    function planeIntersectsAABB(plane, aabb) {
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.
        var vMin;
        var vMax;
        var min = aabb.minimum;
        var max = aabb.maximum;
        if (plane.normal.x > 0.0) {
            vMin = plane.normal.x * min.x;
            vMax = plane.normal.x * max.x;
        }
        else {
            vMin = plane.normal.x * max.x;
            vMax = plane.normal.x * min.x;
        }
        if (plane.normal.y > 0.0) {
            vMin += plane.normal.y * min.y;
            vMax += plane.normal.y * max.y;
        }
        else {
            vMin += plane.normal.y * max.y;
            vMax += plane.normal.y * min.y;
        }
        if (plane.normal.z > 0.0) {
            vMin += plane.normal.z * min.z;
            vMax += plane.normal.z * max.z;
        }
        else {
            vMin += plane.normal.z * max.z;
            vMax += plane.normal.z * min.z;
        }
        return vMin <= plane.constant && vMax >= plane.constant;
    }
    egret3d.planeIntersectsAABB = planeIntersectsAABB;
    function planeIntersectsSphere(plane, sphere) {
        return Math.abs(plane.getDistance(sphere.center)) <= sphere.radius;
    }
    egret3d.planeIntersectsSphere = planeIntersectsSphere;
    function aabbIntersectsSphere(aabb, sphere) {
        // Find the point on the AABB closest to the sphere center.
        egret3d.helpVector3A.copy(sphere.center).clamp(aabb.minimum, aabb.maximum);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return egret3d.helpVector3A.getSquaredDistance(sphere.center) <= (sphere.radius * sphere.radius);
    }
    egret3d.aabbIntersectsSphere = aabbIntersectsSphere;
    function aabbIntersectsAABB(valueA, valueB) {
        var minA = valueA.minimum;
        var maxA = valueA.maximum;
        var minB = valueB.minimum;
        var maxB = valueB.maximum;
        // using 6 splitting planes to rule out intersections.
        return maxA.x < minB.x || minA.x > maxB.x ||
            maxA.y < minB.y || minA.y > maxB.y ||
            maxA.z < minB.z || minA.z > maxB.z ? false : true;
    }
    egret3d.aabbIntersectsAABB = aabbIntersectsAABB;
    function sphereIntersectsSphere(valueA, valueB) {
        var radiusSum = valueA.radius + valueB.radius;
        return valueA.center.getSquaredDistance(valueB.center) <= (radiusSum * radiusSum);
    }
    egret3d.sphereIntersectsSphere = sphereIntersectsSphere;
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var BaseState = (function () {
            function BaseState() {
                this.autoClear = false;
                this.batchIndex = 0;
                this._isDone = false;
            }
            BaseState.prototype.undo = function () {
                if (this._isDone) {
                    this._isDone = false;
                    return true;
                }
                return false;
            };
            BaseState.prototype.redo = function () {
                if (this._isDone) {
                    return false;
                }
                this._isDone = true;
                this.editorModel.dirty = true;
                return true;
            };
            Object.defineProperty(BaseState.prototype, "isDone", {
                get: function () {
                    return this._isDone;
                },
                set: function (value) {
                    this._isDone = value;
                },
                enumerable: true,
                configurable: true
            });
            BaseState.prototype.dispatchEditorModelEvent = function (type, data) {
                this.editorModel.dispatchEvent(new editor.EditorModelEvent(type, data));
            };
            BaseState.prototype.serialize = function () {
                return null;
            };
            BaseState.prototype.deserialize = function (data) {
            };
            return BaseState;
        }());
        editor.BaseState = BaseState;
        __reflect(BaseState.prototype, "paper.editor.BaseState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 颜色。
     */
    var Color = (function (_super) {
        __extends(Color, _super);
        /**
         * 请使用 `egret3d.Color.create()` 创建实例。
         * @see egret3d.Color.create()
         */
        function Color() {
            var _this = _super.call(this) || this;
            /**
             * 红色通道
             */
            _this.r = 1.0;
            /**
             * 绿色通道
             */
            _this.g = 1.0;
            /**
             * 蓝色通道
             */
            _this.b = 1.0;
            /**
             * 透明通道
             */
            _this.a = 1.0;
            return _this;
        }
        /**
         * 创建一个新的颜色对象实例
         * @param r 红色通道
         * @param g 绿色通道
         * @param b 蓝色通道
         * @param a 透明通道
         */
        Color.create = function (r, g, b, a) {
            if (r === void 0) { r = 1.0; }
            if (g === void 0) { g = 1.0; }
            if (b === void 0) { b = 1.0; }
            if (a === void 0) { a = 1.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(r, g, b, a);
                instance._released = false;
                return instance;
            }
            return new Color().set(r, g, b, a);
        };
        /**
         * 序列化
         * @returns 序列化后的数据
         */
        Color.prototype.serialize = function () {
            return [this.r, this.g, this.b, this.a];
        };
        /**
         * 反序列化
         * @param value 需要反序列化的数据
         */
        Color.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        /**
         * 复制一个颜色对象
         * @returns 一个复制后的新的颜色对象
         */
        Color.prototype.clone = function () {
            return Color.create(this.r, this.g, this.b, this.a);
        };
        /**
         * 拷贝一个颜色对象的值
         * @param value 要拷贝的颜色对象
         */
        Color.prototype.copy = function (value) {
            return this.set(value.r, value.g, value.b, value.a);
        };
        /**
         * 设置一个颜色对象的rgba
         * @param r 红色通道
         * @param g 绿色通道
         * @param b 蓝色通道
         * @param a 透明通道
         * @returns 该对象本身
         */
        Color.prototype.set = function (r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
            return this;
        };
        Color.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.r = value[0 + offset];
            this.g = value[1 + offset];
            this.b = value[2 + offset];
            this.a = value[3 + offset];
            return this;
        };
        Color.prototype.multiply = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.r = valueA.r * valueB.r;
            this.g = valueA.g * valueB.g;
            this.b = valueA.b * valueB.b;
            this.a = valueA.a * valueB.a;
            return this;
        };
        Color.prototype.scale = function (value, source) {
            if (!source) {
                source = this;
            }
            this.r = source.r * value;
            this.g = source.g * value;
            this.b = source.b * value;
            this.a = source.a * value;
            return this;
        };
        Color.prototype.lerp = function (t, valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.r = t * (valueB.r - valueA.r) + valueA.r;
            this.g = t * (valueB.g - valueA.g) + valueA.g;
            this.b = t * (valueB.b - valueA.b) + valueA.b;
            this.a = t * (valueB.a - valueA.a) + valueA.a;
            return this;
        };
        /**
         * 黑色
         */
        Color.BLACK = new Color().set(0.0, 0.0, 0.0, 1.0);
        /**
         * 灰色
         */
        Color.GRAY = new Color().set(0.5, 0.5, 0.5, 1.0);
        /**
         * 白色
         */
        Color.WHITE = new Color().set(1.0, 1.0, 1.0, 1.0);
        /**
         * 红色
         */
        Color.RED = new Color().set(1.0, 0.0, 0.0, 1.0);
        /**
         * 绿色
         */
        Color.GREEN = new Color().set(0.0, 1.0, 0.0, 1.0);
        /**
         * 蓝色
         */
        Color.BLUE = new Color().set(0.0, 0.0, 1.0, 1.0);
        /**
         * 黄色
         */
        Color.YELLOW = new Color().set(1.0, 1.0, 0.0, 1.0);
        /**
         * 靛蓝色
         */
        Color.INDIGO = new Color().set(0.0, 1.0, 1.0, 1.0);
        /**
         * 紫色
         */
        Color.PURPLE = new Color().set(1.0, 0.0, 1.0, 1.0);
        Color._instances = [];
        return Color;
    }(paper.BaseRelease));
    egret3d.Color = Color;
    __reflect(Color.prototype, "egret3d.Color", ["egret3d.IColor", "paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var HideFlags;
    (function (HideFlags) {
        /**
         *
         */
        HideFlags[HideFlags["None"] = 0] = "None";
        /**
         *
         */
        HideFlags[HideFlags["NotEditable"] = 1] = "NotEditable";
        /**
         *
         */
        HideFlags[HideFlags["Hide"] = 2] = "Hide";
        /**
         *
         */
        HideFlags[HideFlags["HideAndDontSave"] = 3] = "HideAndDontSave";
    })(HideFlags = paper.HideFlags || (paper.HideFlags = {}));
    /**
     *
     */
    var DefaultNames;
    (function (DefaultNames) {
        DefaultNames["NoName"] = "NoName";
        DefaultNames["Global"] = "Global";
        DefaultNames["MainCamera"] = "Main Camera";
        DefaultNames["EditorCamera"] = "Editor Camera";
        DefaultNames["EditorOnly"] = "Editor Only";
        DefaultNames["MissingPrefab"] = "Missing Prefab";
    })(DefaultNames = paper.DefaultNames || (paper.DefaultNames = {}));
    /**
     *
     */
    var DefaultTags;
    (function (DefaultTags) {
        DefaultTags["Untagged"] = "";
        DefaultTags["Respawn"] = "Respawn";
        DefaultTags["Finish"] = "Finish";
        DefaultTags["EditorOnly"] = "Editor Only";
        DefaultTags["MainCamera"] = "Main Camera";
        DefaultTags["Player"] = "Player";
        DefaultTags["GameController"] = "Game Controller";
        DefaultTags["Global"] = "Global";
    })(DefaultTags = paper.DefaultTags || (paper.DefaultTags = {}));
    /**
     * 系统排序。
     */
    var SystemOrder;
    (function (SystemOrder) {
        SystemOrder[SystemOrder["Begin"] = 0] = "Begin";
        SystemOrder[SystemOrder["Enable"] = 1000] = "Enable";
        SystemOrder[SystemOrder["Start"] = 2000] = "Start";
        SystemOrder[SystemOrder["FixedUpdate"] = 3000] = "FixedUpdate";
        SystemOrder[SystemOrder["Update"] = 4000] = "Update";
        SystemOrder[SystemOrder["Animation"] = 5000] = "Animation";
        SystemOrder[SystemOrder["LaterUpdate"] = 6000] = "LaterUpdate";
        SystemOrder[SystemOrder["Renderer"] = 7000] = "Renderer";
        SystemOrder[SystemOrder["Draw"] = 8000] = "Draw";
        SystemOrder[SystemOrder["Disable"] = 9000] = "Disable";
        SystemOrder[SystemOrder["End"] = 10000] = "End";
    })(SystemOrder = paper.SystemOrder || (paper.SystemOrder = {}));
    /**
     * 渲染排序。
     */
    var RenderQueue;
    (function (RenderQueue) {
        RenderQueue[RenderQueue["Background"] = 1000] = "Background";
        RenderQueue[RenderQueue["Geometry"] = 2000] = "Geometry";
        RenderQueue[RenderQueue["AlphaTest"] = 2450] = "AlphaTest";
        RenderQueue[RenderQueue["Transparent"] = 3000] = "Transparent";
        RenderQueue[RenderQueue["Overlay"] = 4000] = "Overlay";
    })(RenderQueue = paper.RenderQueue || (paper.RenderQueue = {}));
    /**
     * 这里暂未实现用户自定义层级，但用户可以使用预留的UserLayer。
     * 这个属性可以实现相机的选择性剔除。
     */
    var Layer;
    (function (Layer) {
        Layer[Layer["Default"] = 2] = "Default";
        Layer[Layer["UI"] = 4] = "UI";
        Layer[Layer["UserLayer1"] = 8] = "UserLayer1";
        Layer[Layer["UserLayer2"] = 16] = "UserLayer2";
        Layer[Layer["UserLayer3"] = 32] = "UserLayer3";
        Layer[Layer["UserLayer4"] = 64] = "UserLayer4";
        Layer[Layer["UserLayer5"] = 128] = "UserLayer5";
        Layer[Layer["UserLayer6"] = 240] = "UserLayer6";
        Layer[Layer["UserLayer7"] = 256] = "UserLayer7";
        Layer[Layer["UserLayer8"] = 512] = "UserLayer8";
        Layer[Layer["UserLayer9"] = 1024] = "UserLayer9";
        Layer[Layer["UserLayer10"] = 2048] = "UserLayer10";
        Layer[Layer["UserLayer11"] = 3840] = "UserLayer11";
    })(Layer = paper.Layer || (paper.Layer = {}));
    /**
     * culling mask
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * culling mask 枚举。
     * 相机的cullingmask与renderer的renderLayer相匹配，才会执行渲染。否则将会被跳过。
     * 这个属性可以实现相机的选择性剔除。
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var CullingMask;
    (function (CullingMask) {
        CullingMask[CullingMask["Everything"] = 16777215] = "Everything";
        CullingMask[CullingMask["Nothing"] = 1] = "Nothing";
        CullingMask[CullingMask["Default"] = 2] = "Default";
        CullingMask[CullingMask["UI"] = 4] = "UI";
        CullingMask[CullingMask["UserLayer1"] = 8] = "UserLayer1";
        CullingMask[CullingMask["UserLayer2"] = 16] = "UserLayer2";
        CullingMask[CullingMask["UserLayer3"] = 32] = "UserLayer3";
        CullingMask[CullingMask["UserLayer4"] = 64] = "UserLayer4";
        CullingMask[CullingMask["UserLayer5"] = 128] = "UserLayer5";
        CullingMask[CullingMask["UserLayer6"] = 240] = "UserLayer6";
        CullingMask[CullingMask["UserLayer7"] = 256] = "UserLayer7";
        CullingMask[CullingMask["UserLayer8"] = 512] = "UserLayer8";
        CullingMask[CullingMask["UserLayer9"] = 1024] = "UserLayer9";
        CullingMask[CullingMask["UserLayer10"] = 2048] = "UserLayer10";
        CullingMask[CullingMask["UserLayer11"] = 3840] = "UserLayer11";
    })(CullingMask = paper.CullingMask || (paper.CullingMask = {}));
    // /**
    //  * 
    //  * @param cullingMask 
    //  * @param layer 
    //  */
    // export function layerTest(cullingMask: CullingMask, layer: Layer) {
    //     return (cullingMask & layer) !== 0;
    // }
    // /**
    //  * 
    //  * @param cullingMask 
    //  * @param layer 
    //  */
    // export function removeLayer(cullingMask: CullingMask, layer: Layer) {
    //     return cullingMask & ~layer;
    // }
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 四元数。
     */
    var Quaternion = (function (_super) {
        __extends(Quaternion, _super);
        function Quaternion() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         *
         */
        Quaternion.create = function (x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, z, w);
                instance._released = false;
                return instance;
            }
            return new Quaternion().set(x, y, z, w);
        };
        Quaternion.prototype.clone = function () {
            return Quaternion.create(this.x, this.y, this.z, this.w);
        };
        /**
         * - 旋转矩阵。
         */
        Quaternion.prototype.fromMatrix = function (matrix) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var rawData = matrix.rawData;
            var m11 = rawData[0], m12 = rawData[4], m13 = rawData[8];
            var m21 = rawData[1], m22 = rawData[5], m23 = rawData[9];
            var m31 = rawData[2], m32 = rawData[6], m33 = rawData[10];
            var trace = m11 + m22 + m33;
            var s = 0.0;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                this.w = 0.25 / s;
                this.x = (m32 - m23) * s;
                this.y = (m13 - m31) * s;
                this.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                this.w = (m32 - m23) / s;
                this.x = 0.25 * s;
                this.y = (m12 + m21) / s;
                this.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                this.w = (m13 - m31) / s;
                this.x = (m12 + m21) / s;
                this.y = 0.25 * s;
                this.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                this.w = (m21 - m12) / s;
                this.x = (m13 + m31) / s;
                this.y = (m23 + m32) / s;
                this.z = 0.25 * s;
            }
            return this;
        };
        Quaternion.prototype.fromEuler = function (value, order) {
            if (order === void 0) { order = 2 /* YXZ */; }
            var x = value.x, y = value.y, z = value.z;
            // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m
            var cos = Math.cos;
            var sin = Math.sin;
            var c1 = cos(x * 0.5);
            var c2 = cos(y * 0.5);
            var c3 = cos(z * 0.5);
            var s1 = sin(x * 0.5);
            var s2 = sin(y * 0.5);
            var s3 = sin(z * 0.5);
            switch (order) {
                case 0 /* XYZ */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 1 /* XZY */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 2 /* YXZ */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 3 /* YZX */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 4 /* ZXY */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 5 /* ZYX */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
            }
            return this;
        };
        /**
         * - 向量必须已归一化。
         */
        Quaternion.prototype.fromAxis = function (axis, radian) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
            // assumes axis is normalized
            var halfAngle = radian * 0.5, s = Math.sin(halfAngle);
            this.x = axis.x * s;
            this.y = axis.y * s;
            this.z = axis.z * s;
            this.w = Math.cos(halfAngle);
            return this;
        };
        Quaternion.prototype.inverse = function (source) {
            if (!source) {
                source = this;
            }
            this.x = source.x * -1;
            this.y = source.y * -1;
            this.z = source.z * -1;
            this.w = source.w;
            return this;
        };
        Quaternion.prototype.dot = function (value) {
            return this.x * value.x + this.y * value.y + this.z * value.z + this.w * value.w;
        };
        Quaternion.prototype.multiply = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            var qax = valueA.x, qay = valueA.y, qaz = valueA.z, qaw = valueA.w;
            var qbx = valueB.x, qby = valueB.y, qbz = valueB.z, qbw = valueB.w;
            this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
            return this;
        };
        Quaternion.prototype.premultiply = function (value) {
            return this.multiply(value, this);
        };
        Quaternion.prototype.lerp = function (t, valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            if (t === 0.0)
                return this.copy(valueA);
            if (t === 1.0)
                return this.copy(valueB);
            var x = valueA.x, y = valueA.y, z = valueA.z, w = valueA.w;
            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            var cosHalfTheta = w * valueB.w + x * valueB.x + y * valueB.y + z * valueB.z;
            if (cosHalfTheta < 0.0) {
                this.w = -valueB.w;
                this.x = -valueB.x;
                this.y = -valueB.y;
                this.z = -valueB.z;
                cosHalfTheta = -cosHalfTheta;
            }
            else {
                this.copy(valueB);
            }
            if (cosHalfTheta >= 1.0) {
                this.w = w;
                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            }
            var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
            if (sqrSinHalfTheta <= egret3d.EPSILON) {
                var s = 1.0 - t;
                this.w = s * w + t * this.w;
                this.x = s * x + t * this.x;
                this.y = s * y + t * this.y;
                this.z = s * z + t * this.z;
                return this.normalize();
            }
            var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
            var ratioA = Math.sin((1.0 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            this.w = (w * ratioA + this.w * ratioB);
            this.x = (x * ratioA + this.x * ratioB);
            this.y = (y * ratioA + this.y * ratioB);
            this.z = (z * ratioA + this.z * ratioB);
        };
        /**
         *
         * @param eye
         * @param target
         * @param up
         */
        Quaternion.prototype.lookAt = function (eye, target, up) {
            return this.fromMatrix(egret3d.helpMatrixA.lookAt(eye, target, up));
        };
        /**
         *
         * @param value
         * @param up
         */
        Quaternion.prototype.lookRotation = function (value, up) {
            return this.fromMatrix(egret3d.helpMatrixA.lookRotation(value, up));
        };
        Quaternion.prototype.toEuler = function (value, order) {
            if (order === void 0) { order = 2 /* YXZ */; }
            return _helpMatrix.fromRotation(this).toEuler(value, order);
        };
        Quaternion.IDENTITY = new Quaternion();
        Quaternion._instances = [];
        return Quaternion;
    }(egret3d.Vector4));
    egret3d.Quaternion = Quaternion;
    __reflect(Quaternion.prototype, "egret3d.Quaternion");
    var _helpMatrix = egret3d.Matrix4.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 预制体资源。
     */
    var Prefab = (function (_super) {
        __extends(Prefab, _super);
        function Prefab() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Prefab.create = function (name, xOrScene, y, z, scene) {
            var prefab = paper.Asset.find(name);
            if (prefab && prefab instanceof Prefab) {
                if (xOrScene !== undefined && xOrScene !== null) {
                    if (xOrScene instanceof paper.Scene) {
                        var gameObject = prefab.createInstance(xOrScene);
                        if (gameObject) {
                            gameObject.transform.setLocalPosition(0.0, 0.0, 0.0);
                        }
                        return gameObject;
                    }
                    else {
                        var gameObject = prefab.createInstance(scene || null);
                        if (gameObject) {
                            gameObject.transform.setLocalPosition(xOrScene, y, z);
                        }
                        return gameObject;
                    }
                }
                else {
                    var gameObject = prefab.createInstance();
                    if (gameObject) {
                        gameObject.transform.setLocalPosition(0.0, 0.0, 0.0);
                    }
                    return gameObject;
                }
            }
            else {
                console.warn("The prefab don't exists.", name);
            }
            return null;
        };
        /**
         * @deprecated
         */
        Prefab.prototype.createInstance = function (scene, keepUUID) {
            if (!this._raw) {
                return null;
            }
            var isEditor = paper.Application.playerMode === 2 /* Editor */;
            var deserializer = new paper.Deserializer();
            var gameObject = deserializer.deserialize(this._raw, keepUUID, isEditor, scene);
            if (gameObject && isEditor) {
                if (!gameObject.extras.prefab) {
                    gameObject.extras.prefab = this;
                }
            }
            return gameObject;
        };
        return Prefab;
    }(paper.BaseObjectAsset));
    paper.Prefab = Prefab;
    __reflect(Prefab.prototype, "paper.Prefab");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var _helpMatrix = egret3d.Matrix4.create();
    /**
     * Mesh 渲染组件。
     */
    var MeshRenderer = (function (_super) {
        __extends(MeshRenderer, _super);
        function MeshRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._materials = [egret3d.DefaultMaterials.MESH_BASIC];
            return _this;
        }
        MeshRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            this._materials.length = 0;
        };
        MeshRenderer.prototype.recalculateAABB = function () {
            this._aabb.clear();
            var filter = this.gameObject.getComponent(egret3d.MeshFilter);
            if (filter && filter.mesh) {
                var vertices = filter.mesh.getVertices();
                var position = egret3d.helpVector3A;
                for (var i = 0, l = vertices.length; i < l; i += 3) {
                    position.set(vertices[i], vertices[i + 1], vertices[i + 2]);
                    this._aabb.add(position);
                }
            }
        };
        MeshRenderer.prototype.raycast = function (p1, p2, p3) {
            var meshFilter = this.gameObject.getComponent(egret3d.MeshFilter);
            if (!meshFilter || !meshFilter.enabled || !meshFilter.mesh) {
                return false;
            }
            var raycastMesh = false;
            var raycastInfo = undefined;
            var worldMatrix = this.gameObject.transform.worldMatrix;
            var localRay = egret3d.helpRay.applyMatrix(_helpMatrix.inverse(worldMatrix), p1); // TODO transform inverse world matrix.
            var aabb = this.aabb;
            if (p2) {
                if (p2 === true) {
                    raycastMesh = true;
                }
                else {
                    raycastMesh = p3 || false;
                    raycastInfo = p2;
                }
            }
            if (raycastMesh ? aabb.raycast(localRay) && meshFilter.mesh.raycast(localRay, raycastInfo) : aabb.raycast(localRay, raycastInfo)) {
                if (raycastInfo) {
                    raycastInfo.position.applyMatrix(worldMatrix);
                    raycastInfo.distance = p1.origin.getDistance(raycastInfo.position);
                }
                return true;
            }
            return false;
        };
        Object.defineProperty(MeshRenderer.prototype, "materials", {
            /**
             * material list
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 材质数组
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._materials;
            },
            set: function (value) {
                if (value === this._materials) {
                    return;
                }
                // TODO 共享材质的接口。
                this._materials.length = 0;
                for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                    var material = value_1[_i];
                    if (!material) {
                        console.warn("Invalid material.");
                    }
                    this._materials.push(material || egret3d.DefaultMaterials.MISSING);
                }
                paper.EventPool.dispatchEvent("materials" /* Materials */, this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeshRenderer.prototype, "material", {
            /**
             * 材质数组中的第一个材质。
             */
            get: function () {
                return this._materials.length > 0 ? this._materials[0] : null;
            },
            set: function (value) {
                var dirty = false;
                if (value) {
                    if (this._materials.length > 0) {
                        if (this._materials[0] !== value) {
                            this._materials[0] = value;
                            dirty = true;
                        }
                    }
                    else {
                        this._materials.push(value);
                        dirty = true;
                    }
                }
                else if (this._materials.length > 0) {
                    this._materials.splice(0, 1);
                    dirty = true;
                }
                if (dirty) {
                    paper.EventPool.dispatchEvent("materials" /* Materials */, this);
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], MeshRenderer.prototype, "_materials", void 0);
        __decorate([
            paper.editor.property(13 /* MATERIAL_ARRAY */)
        ], MeshRenderer.prototype, "materials", null);
        return MeshRenderer;
    }(paper.BaseRenderer));
    egret3d.MeshRenderer = MeshRenderer;
    __reflect(MeshRenderer.prototype, "egret3d.MeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * light component
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 灯光组件
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var BaseLight = (function (_super) {
        __extends(BaseLight, _super);
        function BaseLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * TODO
             */
            _this.cullingMask = 16777215 /* Everything */;
            /**
             *
             */
            _this.intensity = 1.0;
            /**
             *
             */
            _this.color = egret3d.Color.create(1.0, 1.0, 1.0, 1.0);
            /**
             *
             */
            _this.castShadows = false;
            /**
             *
             */
            _this.shadowRadius = 0.5;
            /**
             *
             */
            _this.shadowBias = 0.01;
            /**
             *
             */
            _this.shadowSize = 512;
            /**
             *
             */
            _this.shadowCameraNear = 1.0;
            /**
             *
             */
            _this.shadowCameraFar = 100.0;
            /**
             *
             */
            _this.shadowCameraSize = 30;
            _this.viewPortPixel = { x: 0, y: 0, w: 0, h: 0 };
            _this.matrix = egret3d.Matrix4.create();
            return _this;
        }
        BaseLight.prototype._updateMatrix = function (camera) {
            // matrix * 0.5 + 0.5, after identity, range is 0 ~ 1 instead of -1 ~ 1
            var matrix = this.matrix;
            matrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
            var context = camera.context;
            context.updateCamera(camera, this.gameObject.transform.getWorldMatrix());
            context.updateLightDepth(this);
            matrix.multiply(context.matrix_p).multiply(context.matrix_v);
        };
        /**
         * @internal
         */
        BaseLight.prototype.update = function (camera, faceIndex) {
            camera.backgroundColor.set(1.0, 1.0, 1.0, 1.0);
            camera.clearOption_Color = true;
            camera.clearOption_Depth = true;
            this._updateMatrix(camera);
        };
        Object.defineProperty(BaseLight.prototype, "power", {
            /**
             *
             */
            get: function () {
                return this.intensity * (Math.PI * 4.0);
            },
            set: function (value) {
                this.intensity = value / (Math.PI * 4.0);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], BaseLight.prototype, "cullingMask", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0 })
        ], BaseLight.prototype, "intensity", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(9 /* COLOR */)
        ], BaseLight.prototype, "color", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(4 /* CHECKBOX */)
        ], BaseLight.prototype, "castShadows", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0 })
        ], BaseLight.prototype, "shadowRadius", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.01 })
        ], BaseLight.prototype, "shadowBias", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(0 /* UINT */)
        ], BaseLight.prototype, "shadowSize", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0 })
        ], BaseLight.prototype, "shadowCameraNear", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0 })
        ], BaseLight.prototype, "shadowCameraFar", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0 })
        ], BaseLight.prototype, "shadowCameraSize", void 0);
        return BaseLight;
    }(paper.BaseComponent));
    egret3d.BaseLight = BaseLight;
    __reflect(BaseLight.prototype, "egret3d.BaseLight");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 程序系统管理器。
     */
    var SystemManager = (function () {
        function SystemManager() {
            this._preSystems = [];
            this._systems = [];
        }
        /**
         * 程序系统管理器单例。
         */
        SystemManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SystemManager();
            }
            return this._instance;
        };
        SystemManager.prototype._getSystemInsertIndex = function (order) {
            var index = -1;
            var systemCount = this._systems.length;
            if (systemCount > 0) {
                if (order < this._systems[0]._order) {
                    return 0;
                }
                else if (order >= this._systems[systemCount - 1]._order) {
                    return systemCount;
                }
            }
            for (var i = 0; i < systemCount - 1; ++i) {
                if (this._systems[i]._order <= order && order < this._systems[i + 1]._order) {
                    index = i + 1;
                    break;
                }
            }
            return index < 0 ? this._systems.length : index;
        };
        SystemManager.prototype._checkRegister = function (systemClass) {
            var system = this.getSystem(systemClass);
            if (system) {
                console.warn("The system has been registered.", egret.getQualifiedClassName(systemClass));
                return system;
            }
            return system;
        };
        /**
         * @internal
         */
        SystemManager.prototype._preRegisterSystems = function () {
            this._preSystems.sort(function (a, b) { return a.order - b.order; });
            for (var _i = 0, _a = this._preSystems; _i < _a.length; _i++) {
                var pair = _a[_i];
                this.register(pair.systemClass, pair.order);
            }
            this._preSystems.length = 0;
        };
        /**
         * @internal
         */
        SystemManager.prototype._update = function () {
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system && system.enabled && !system._started) {
                    system._started = true;
                    system.onStart && system.onStart();
                }
            }
            for (var _b = 0, _c = this._systems; _b < _c.length; _b++) {
                var system = _c[_b];
                if (system) {
                    system._update();
                }
            }
            for (var _d = 0, _e = this._systems; _d < _e.length; _d++) {
                var system = _e[_d];
                if (system) {
                    system._lateUpdate();
                }
            }
        };
        /**
         * 在程序启动之前预注册一个指定的系统。
         */
        SystemManager.prototype.preRegister = function (systemClass, order) {
            if (order === void 0) { order = 4000 /* Update */; }
            if (this._systems.length > 0) {
                this.register(systemClass, order);
                return this;
            }
            this._preSystems.unshift({ systemClass: systemClass, order: order });
            return this;
        };
        /**
         * 为程序注册一个指定的系统。
         */
        SystemManager.prototype.register = function (systemClass, order) {
            if (order === void 0) { order = 4000 /* Update */; }
            var system = this._checkRegister(systemClass);
            if (system) {
                return system;
            }
            system = paper.BaseSystem.create(systemClass, order);
            this._systems.splice(this._getSystemInsertIndex(order), 0, system);
            system._initialize();
            return system;
        };
        /**
         * 从程序已注册的全部系统中获取一个指定的系统。
         */
        SystemManager.prototype.getSystem = function (systemClass) {
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system && system.constructor === systemClass) {
                    return system;
                }
            }
            return null;
        };
        /**
         * 从程序已注册的全部系统中获取一个指定的系统，如果尚未注册，则注册该系统。
         */
        SystemManager.prototype.getOrRegisterSystem = function (systemClass, order) {
            if (order === void 0) { order = 4000 /* Update */; }
            var system = this.getSystem(systemClass);
            if (!system) {
                system = this.register(systemClass, order);
            }
            return system;
        };
        Object.defineProperty(SystemManager.prototype, "systems", {
            /**
             * 程序已注册的全部系统。
             */
            get: function () {
                return this._systems;
            },
            enumerable: true,
            configurable: true
        });
        SystemManager._instance = null;
        return SystemManager;
    }());
    paper.SystemManager = SystemManager;
    __reflect(SystemManager.prototype, "paper.SystemManager");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 程序场景管理器。
     */
    var SceneManager = (function () {
        function SceneManager() {
            this._scenes = [];
            this._globalScene = null;
            this._editorScene = null;
        }
        /**
         * 场景管理器单例。
         */
        SceneManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SceneManager();
            }
            return this._instance;
        };
        /**
         * @internal
         */
        SceneManager.prototype._addScene = function (scene, isActive) {
            if (this._scenes.indexOf(scene) >= 0) {
                console.warn("Add the scene again.", scene.name);
            }
            if (isActive) {
                this._scenes.unshift(scene);
            }
            else {
                this._scenes.push(scene);
            }
        };
        /**
         * @internal
         */
        SceneManager.prototype._removeScene = function (scene) {
            if (scene === this._globalScene ||
                scene === this._editorScene) {
                console.warn("Cannot dispose global scene.");
                return false;
            }
            var index = this._scenes.indexOf(scene);
            if (index < 0) {
                console.warn("Remove scene error.", scene.name);
                return false;
            }
            this._scenes.splice(index, 1);
            return true;
        };
        /**
         * 卸载程序中的全部场景。
         * - 不包含全局场景。
         */
        SceneManager.prototype.unloadAllScene = function (excludes) {
            var i = this._scenes.length;
            while (i--) {
                var scene = this._scenes[i];
                if (excludes && excludes.indexOf(scene) >= 0) {
                    continue;
                }
                scene.destroy();
            }
        };
        /**
         * 从程序已创建的全部场景中获取指定名称的场景。
         */
        SceneManager.prototype.getScene = function (name) {
            for (var _i = 0, _a = this._scenes; _i < _a.length; _i++) {
                var scene = _a[_i];
                if (scene.name === name) {
                    return scene;
                }
            }
            return null;
        };
        Object.defineProperty(SceneManager.prototype, "scenes", {
            /**
             * 程序已创建的全部场景。
             * - 不包含全局场景。
             */
            get: function () {
                return this._scenes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "globalScene", {
            /**
             * 全局场景。
             * - 全局场景无法被销毁。
             */
            get: function () {
                if (!this._globalScene) {
                    this._globalScene = paper.Scene.createEmpty("Global" /* Global */, false);
                    this._scenes.pop(); // Remove global scene from scenes.
                }
                return this._globalScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "activeScene", {
            /**
             * 当前程序激活的场景。
             */
            get: function () {
                if (this._scenes.length === 0) {
                    paper.Scene.createEmpty();
                }
                return this._scenes[0];
            },
            set: function (value) {
                if (this._scenes.length <= 1 ||
                    this._scenes[0] === value ||
                    this._globalScene === value //|| // Cannot active global scene.
                ) {
                    return;
                }
                var index = this._scenes.indexOf(value);
                if (index < 0) {
                    console.warn("Active scene error.", value.name);
                }
                this._scenes.splice(index, 1);
                this._scenes.unshift(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "editorScene", {
            /**
             *
             */
            get: function () {
                if (!this._editorScene) {
                    this._editorScene = paper.Scene.createEmpty("Editor Only" /* EditorOnly */, false);
                    this._scenes.pop(); // Remove editor scene from scenes.
                }
                return this._editorScene;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        SceneManager.prototype.createScene = function (name, isActive) {
            if (isActive === void 0) { isActive = true; }
            return paper.Scene.createEmpty(name, isActive);
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.loadScene = function (resourceName, combineStaticObjects) {
            if (combineStaticObjects === void 0) { combineStaticObjects = true; }
            return paper.Scene.create(resourceName, combineStaticObjects);
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.unloadScene = function (scene) {
            scene.destroy();
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.getActiveScene = function () {
            return this.activeScene;
        };
        SceneManager._instance = null;
        return SceneManager;
    }());
    paper.SceneManager = SceneManager;
    __reflect(SceneManager.prototype, "paper.SceneManager");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 碰撞体类型。
     */
    var ColliderType;
    (function (ColliderType) {
        /**
         * 立方体。
         */
        ColliderType[ColliderType["Box"] = 0] = "Box";
        /**
         * 球体。
         */
        ColliderType[ColliderType["Sphere"] = 1] = "Sphere";
        /**
         * 圆柱体。
         */
        ColliderType[ColliderType["Cylinder"] = 2] = "Cylinder";
        /**
         * 圆锥体。
         */
        ColliderType[ColliderType["Cone"] = 3] = "Cone";
        /**
         * 胶囊体。
         */
        ColliderType[ColliderType["Capsule"] = 4] = "Capsule";
        /**
         * TODO
         */
        ColliderType[ColliderType["ConvexHull"] = 5] = "ConvexHull";
    })(ColliderType = egret3d.ColliderType || (egret3d.ColliderType = {}));
    /**
     *
     */
    var BaseCollider = (function (_super) {
        __extends(BaseCollider, _super);
        function BaseCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 碰撞体类型。
             */
            _this.colliderType = -1;
            /**
             *
             */
            _this._physicsData = null;
            return _this;
        }
        return BaseCollider;
    }(paper.BaseComponent));
    egret3d.BaseCollider = BaseCollider;
    __reflect(BaseCollider.prototype, "egret3d.BaseCollider", ["egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var EventDispatcher = (function () {
        function EventDispatcher() {
            this._eventMap = {};
        }
        EventDispatcher.prototype.addEventListener = function (type, listener, thisObject) {
            var list = this._eventMap[type];
            if (!list) {
                list = this._eventMap[type] = [];
            }
            list.push({ listener: listener, thisObject: thisObject || this });
        };
        EventDispatcher.prototype.removeEventListener = function (type, listener, thisObject) {
            var list = this._eventMap[type];
            if (!list) {
                return;
            }
            for (var i = 0, len = list.length; i < len; i++) {
                var bin = list[i];
                if (bin.listener == listener && bin.thisObject == (thisObject || this)) {
                    list.splice(i, 1);
                    break;
                }
            }
        };
        EventDispatcher.prototype.dispatchEvent = function (event) {
            event.target = this;
            this.notifyListener(event);
        };
        EventDispatcher.prototype.notifyListener = function (event) {
            var list = this._eventMap[event.type || event];
            if (!list) {
                return;
            }
            for (var i = 0, len = list.length; i < len; i++) {
                var bin = list[i];
                bin.listener.call(bin.thisObject, event);
            }
        };
        return EventDispatcher;
    }());
    egret3d.EventDispatcher = EventDispatcher;
    __reflect(EventDispatcher.prototype, "egret3d.EventDispatcher");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 事件派发器
         */
        var EventDispatcher = (function () {
            function EventDispatcher() {
                this.__z_e_listeners = {};
            }
            EventDispatcher.prototype.addEventListener = function (type, fun, thisObj, level) {
                if (level === void 0) { level = 0; }
                var list = this.__z_e_listeners[type];
                if (list === undefined) {
                    list = [];
                    this.__z_e_listeners[type] = list;
                }
                var item = {
                    func: fun,
                    context: thisObj,
                    level: level
                };
                list.push(item);
                list.sort(function (a, b) {
                    return b.level - a.level;
                });
            };
            EventDispatcher.prototype.removeEventListener = function (type, fun, thisObj) {
                var list = this.__z_e_listeners[type];
                if (list !== undefined) {
                    var size = list.length;
                    for (var i = 0; i < size; i++) {
                        var obj = list[i];
                        if (obj.func === fun && obj.context === thisObj) {
                            list.splice(i, 1);
                            return;
                        }
                    }
                }
            };
            EventDispatcher.prototype.dispatchEvent = function (event) {
                var list = this.__z_e_listeners[event.type];
                if (list !== undefined) {
                    list.forEach(function (ef) {
                        ef['___dirty___'] = true;
                    });
                    var size = list.length;
                    for (var i = 0; i < size; i++) {
                        var ef = list[i];
                        if (ef['___dirty___']) {
                            var fun = ef.func;
                            var context = ef.context;
                            if (context) {
                                fun.call(context, event);
                            }
                            else {
                                fun(event);
                            }
                            ef['___dirty___'] = false;
                        }
                        if (size != list.length) {
                            size = list.length;
                            i = 0;
                        }
                    }
                }
            };
            return EventDispatcher;
        }());
        editor.EventDispatcher = EventDispatcher;
        __reflect(EventDispatcher.prototype, "paper.editor.EventDispatcher", ["paper.editor.IEventDispatcher"]);
        /**
         * 事件
         */
        var BaseEvent = (function () {
            function BaseEvent(type, data) {
                this.type = type;
                this.data = data;
            }
            return BaseEvent;
        }());
        editor.BaseEvent = BaseEvent;
        __reflect(BaseEvent.prototype, "paper.editor.BaseEvent");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 单例组件基类。
     */
    var SingletonComponent = (function (_super) {
        __extends(SingletonComponent, _super);
        function SingletonComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @internal
         */
        SingletonComponent.__isSingleton = true;
        return SingletonComponent;
    }(paper.BaseComponent));
    paper.SingletonComponent = SingletonComponent;
    __reflect(SingletonComponent.prototype, "paper.SingletonComponent");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 系统基类。
     */
    var BaseSystem = (function () {
        /**
         * 禁止实例化系统。
         * @protected
         */
        function BaseSystem() {
            /**
             * @internal
             */
            this._order = -1;
            /**
             * @internal
             */
            this._started = true;
            this._locked = false;
            this._enabled = true;
            /**
             *
             */
            this._interests = [];
            /**
             *
             */
            this._groups = [];
            /**
             *
             */
            this._clock = paper.GameObject.globalGameObject.getOrAddComponent(paper.Clock);
            if (!BaseSystem._createEnabled) {
                throw new Error("Create an instance of a system is not allowed.");
            }
            BaseSystem._createEnabled = false;
        }
        /**
         * @internal
         */
        BaseSystem.create = function (systemClass, order) {
            if (order === void 0) { order = 4000 /* Update */; }
            this._createEnabled = true;
            var system = new systemClass();
            if (system._order < 0) {
                system._order = order;
            }
            return system;
        };
        /**
         * 系统内部初始化。
         * @internal
         */
        BaseSystem.prototype._initialize = function () {
            if (this._interests.length > 0) {
                var interests = void 0;
                if (Array.isArray(this._interests[0])) {
                    interests = this._interests;
                }
                else {
                    interests = [this._interests];
                }
                for (var _i = 0, interests_1 = interests; _i < interests_1.length; _i++) {
                    var interest = interests_1[_i];
                    for (var _a = 0, interest_1 = interest; _a < interest_1.length; _a++) {
                        var config = interest_1[_a];
                        if (!config.listeners) {
                            continue;
                        }
                        for (var _b = 0, _c = config.listeners; _b < _c.length; _b++) {
                            var listenerConfig = _c[_b];
                            if (Array.isArray(config.componentClass)) {
                                for (var _d = 0, _e = config.componentClass; _d < _e.length; _d++) {
                                    var componentClass = _e[_d];
                                    paper.EventPool.addEventListener(listenerConfig.type, componentClass, listenerConfig.listener);
                                }
                            }
                            else {
                                paper.EventPool.addEventListener(listenerConfig.type, config.componentClass, listenerConfig.listener);
                            }
                        }
                    }
                    this._groups.push(paper.GameObjectGroup.create(interest));
                }
            }
            this.onAwake && this.onAwake();
            this.onEnable && this.onEnable();
        };
        /**
         * 系统内部卸载。
         * @internal
         */
        BaseSystem.prototype._uninitialize = function () {
            this.onDestroy && this.onDestroy();
            if (this._interests.length > 0) {
                var interests = void 0;
                if (Array.isArray(this._interests[0])) {
                    interests = this._interests;
                }
                else {
                    interests = [this._interests];
                }
                for (var _i = 0, interests_2 = interests; _i < interests_2.length; _i++) {
                    var interest = interests_2[_i];
                    for (var _a = 0, interest_2 = interest; _a < interest_2.length; _a++) {
                        var config = interest_2[_a];
                        if (!config.listeners) {
                            continue;
                        }
                        for (var _b = 0, _c = config.listeners; _b < _c.length; _b++) {
                            var listenerConfig = _c[_b];
                            if (Array.isArray(config.componentClass)) {
                                for (var _d = 0, _e = config.componentClass; _d < _e.length; _d++) {
                                    var componentClass = _e[_d];
                                    paper.EventPool.removeEventListener(listenerConfig.type, componentClass, listenerConfig.listener);
                                }
                            }
                            else {
                                paper.EventPool.removeEventListener(listenerConfig.type, config.componentClass, listenerConfig.listener);
                            }
                        }
                    }
                }
            }
        };
        /**
         * 系统内部更新。
         * @internal
         */
        BaseSystem.prototype._update = function () {
            if (!this._enabled) {
                return;
            }
            this._locked = true;
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group = _a[_i];
                if (this.onAddGameObject) {
                    for (var _b = 0, _c = group._addedGameObjects; _b < _c.length; _b++) {
                        var gameObject = _c[_b];
                        if (gameObject) {
                            this.onAddGameObject(gameObject, group);
                        }
                    }
                }
                if (this.onAddComponent) {
                    for (var _d = 0, _e = group._addedComponents; _d < _e.length; _d++) {
                        var component = _e[_d];
                        if (component) {
                            this.onAddComponent(component, group);
                        }
                    }
                }
            }
            this.onUpdate && this.onUpdate(this._clock.deltaTime);
            this._locked = false;
        };
        /**
         * 系统内部更新。
         * @internal
         */
        BaseSystem.prototype._lateUpdate = function () {
            if (!this._enabled) {
                return;
            }
            this._locked = true;
            this.onLateUpdate && this.onLateUpdate(this._clock.deltaTime);
            this._locked = false;
        };
        Object.defineProperty(BaseSystem.prototype, "enabled", {
            /**
             * 该系统是否被激活。
             */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._locked) {
                    console.warn("Cannot change the enabled value when the system is updating.", egret.getQualifiedClassName(this));
                    return;
                }
                if (this._enabled === value) {
                    return;
                }
                this._enabled = value;
                if (this._enabled) {
                    this.onEnable && this.onEnable();
                }
                else {
                    this.onDisable && this.onDisable();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSystem.prototype, "groups", {
            /**
             * 该系统的实体组。
             */
            get: function () {
                return this._groups;
            },
            enumerable: true,
            configurable: true
        });
        BaseSystem._createEnabled = false;
        return BaseSystem;
    }());
    paper.BaseSystem = BaseSystem;
    __reflect(BaseSystem.prototype, "paper.BaseSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 脚本组件。
     * 生命周期的顺序。
     * - onAwake();
     * - onReset();
     * - onEnable();
     * - onStart();
     * - onFixedUpdate();
     * - onUpdate();
     * - onLateUpdate();
     * - onDisable();
     * - onDestroy();
     */
    var Behaviour = (function (_super) {
        __extends(Behaviour, _super);
        function Behaviour() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._isReseted = false;
            /**
             * @internal
             */
            _this._isStarted = false;
            return _this;
        }
        Behaviour.prototype.initialize = function (config) {
            _super.prototype.initialize.call(this, config);
            if (paper.Application.playerMode !== 2 /* Editor */ || this.constructor.executeInEditMode) {
                this.onAwake && this.onAwake(config);
            }
        };
        Behaviour.prototype.uninitialize = function () {
            if (paper.Application.playerMode !== 2 /* Editor */ || this.constructor.executeInEditMode) {
                this.onDestroy && this.onDestroy(); // TODO onDestroy 如果不是 enabled 就不派发
            }
            _super.prototype.uninitialize.call(this);
        };
        /**
         * @deprecated
         */
        Behaviour.prototype.onCollide = function (collider) { };
        return Behaviour;
    }(paper.BaseComponent));
    paper.Behaviour = Behaviour;
    __reflect(Behaviour.prototype, "paper.Behaviour");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 矩形可序列化对象
     */
    var Rectangle = (function () {
        function Rectangle(x, y, w, h) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (w === void 0) { w = 0.0; }
            if (h === void 0) { h = 0.0; }
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        Rectangle.prototype.serialize = function () {
            return [this.x, this.y, this.w, this.h];
        };
        Rectangle.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            this.w = element[2];
            this.h = element[3];
            return this;
        };
        return Rectangle;
    }());
    egret3d.Rectangle = Rectangle;
    __reflect(Rectangle.prototype, "egret3d.Rectangle", ["egret3d.IRectangle", "egret3d.IVector2", "egret3d.ISize", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         *
         */
        var ParticleSystem = (function (_super) {
            __extends(ParticleSystem, _super);
            function ParticleSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._interests = [
                    {
                        componentClass: particle.ParticleComponent,
                        listeners: [
                            { type: "rotation3DChanged" /* StartRotation3DChanged */, listener: function (comp) { _this._onMainUpdate(comp, "rotation3DChanged" /* StartRotation3DChanged */); } },
                            { type: "simulationSpace" /* SimulationSpaceChanged */, listener: function (comp) { _this._onMainUpdate(comp, "simulationSpace" /* SimulationSpaceChanged */); } },
                            { type: "scaleMode" /* ScaleModeChanged */, listener: function (comp) { _this._onMainUpdate(comp, "scaleMode" /* ScaleModeChanged */); } },
                            { type: "velocityChanged" /* VelocityChanged */, listener: _this._onVelocityOverLifetime.bind(_this) },
                            { type: "colorChanged" /* ColorChanged */, listener: _this._onColorOverLifetime.bind(_this) },
                            { type: "sizeChanged" /* SizeChanged */, listener: _this._onSizeOverLifetime.bind(_this) },
                            { type: "rotationChanged" /* RotationChanged */, listener: _this._onRotationOverLifetime.bind(_this) },
                            { type: "textureSheetChanged" /* TextureSheetChanged */, listener: _this._onTextureSheetAnimation.bind(_this) },
                        ]
                    },
                    {
                        componentClass: particle.ParticleRenderer,
                        listeners: [
                            { type: "mesh" /* Mesh */, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            { type: "materials" /* Materials */, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            { type: "lengthScale" /* LengthScaleChanged */, listener: function (comp) { _this._onRenderUpdate(comp, "lengthScale" /* LengthScaleChanged */); } },
                            { type: "velocityScale" /* VelocityScaleChanged */, listener: function (comp) { _this._onRenderUpdate(comp, "velocityScale" /* VelocityScaleChanged */); } },
                            { type: "renderMode" /* RenderMode */, listener: function (comp) { _this._onRenderUpdate(comp, "renderMode" /* RenderMode */); } },
                        ]
                    }
                ];
                _this._drawCalls = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.DrawCalls);
                return _this;
            }
            /**
            * Buffer改变的时候，有可能是初始化，也有可能是mesh改变，此时全部刷一下
            */
            ParticleSystem.prototype._onUpdateBatchMesh = function (comp) {
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                comp.initBatcher();
                //
                this._onRenderUpdate(renderer, "renderMode" /* RenderMode */);
                this._onRenderUpdate(renderer, "lengthScale" /* LengthScaleChanged */);
                this._onRenderUpdate(renderer, "velocityScale" /* VelocityScaleChanged */);
                //
                this._onMainUpdate(comp, "rotation3DChanged" /* StartRotation3DChanged */);
                this._onMainUpdate(comp, "simulationSpace" /* SimulationSpaceChanged */);
                this._onMainUpdate(comp, "scaleMode" /* ScaleModeChanged */);
                this._onShapeChanged(comp);
                this._onVelocityOverLifetime(comp);
                this._onColorOverLifetime(comp);
                this._onSizeOverLifetime(comp);
                this._onRotationOverLifetime(comp);
                this._onTextureSheetAnimation(comp);
            };
            ParticleSystem.prototype._onRenderUpdate = function (render, type) {
                if (!this._enabled || !this._groups[0].hasGameObject(render.gameObject)) {
                    return;
                }
                var material = render.batchMaterial;
                switch (type) {
                    case "renderMode" /* RenderMode */: {
                        this._onRenderMode(render);
                        break;
                    }
                    case "lengthScale" /* LengthScaleChanged */: {
                        material.setFloat("u_lengthScale" /* LENGTH_SCALE */, render.lengthScale);
                        break;
                    }
                    case "velocityScale" /* VelocityScaleChanged */: {
                        material.setFloat("u_speeaScale" /* SPEED_SCALE */, render.velocityScale);
                        break;
                    }
                }
            };
            /**
             *
             * @param render 渲染模式改变
             */
            ParticleSystem.prototype._onRenderMode = function (render) {
                var material = render.batchMaterial;
                material.removeDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                material.removeDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                material.removeDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                material.removeDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                material.removeDefine("RENDERMESH" /* RENDERMESH */);
                var mode = render.renderMode;
                switch (mode) {
                    case 0 /* Billboard */: {
                        material.addDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                        break;
                    }
                    case 1 /* Stretch */: {
                        material.addDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                        break;
                    }
                    case 2 /* HorizontalBillboard */: {
                        material.addDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                        break;
                    }
                    case 3 /* VerticalBillboard */: {
                        material.addDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                        break;
                    }
                    case 4 /* Mesh */: {
                        material.addDefine("RENDERMESH" /* RENDERMESH */);
                        break;
                    }
                    default: {
                        throw "_onRenderMode:invalid renderMode";
                    }
                }
            };
            ParticleSystem.prototype._onMainUpdate = function (component, type) {
                if (!this._enabled || !this._groups[0].hasGameObject(component.gameObject)) {
                    return;
                }
                var renderer = component.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                var mainModule = component.main;
                switch (type) {
                    case "rotation3DChanged" /* StartRotation3DChanged */: {
                        material.setBoolean("u_startRotation3D" /* START_ROTATION3D */, mainModule._startRotation3D);
                        break;
                    }
                    case "simulationSpace" /* SimulationSpaceChanged */: {
                        material.setInt("u_simulationSpace" /* SIMULATION_SPACE */, mainModule._simulationSpace);
                        break;
                    }
                    case "scaleMode" /* ScaleModeChanged */: {
                        material.setInt("u_scalingMode" /* SCALING_MODE */, mainModule._scaleMode);
                        break;
                    }
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onShapeChanged = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("SHAPE" /* SHAPE */);
                if (comp.shape.enable) {
                    material.addDefine("SHAPE" /* SHAPE */);
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onVelocityOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                material.removeDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                material.removeDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                material.removeDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                var velocityModule = comp.velocityOverLifetime;
                if (velocityModule.enable) {
                    var mode = velocityModule._mode;
                    switch (mode) {
                        case 0 /* Constant */: {
                            material.addDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                            //
                            var vec3 = new egret3d.Vector3(velocityModule._x.evaluate(), velocityModule._y.evaluate(), velocityModule._z.evaluate());
                            material.setVector3("u_velocityConst" /* VELOCITY_CONST */, vec3);
                            break;
                        }
                        case 1 /* Curve */: {
                            material.addDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                            //
                            material.setVector2v("u_velocityCurveX[0]" /* VELOCITY_CURVE_X */, velocityModule._x.curve.floatValues);
                            material.setVector2v("u_velocityCurveY[0]" /* VELOCITY_CURVE_Y */, velocityModule._y.curve.floatValues);
                            material.setVector2v("u_velocityCurveZ[0]" /* VELOCITY_CURVE_Z */, velocityModule._z.curve.floatValues);
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            material.addDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                            //
                            var minVec3 = new egret3d.Vector3(velocityModule._x.constantMin, velocityModule._y.constantMin, velocityModule._z.constantMin);
                            var maxVec3 = new egret3d.Vector3(velocityModule._x.constantMax, velocityModule._y.constantMax, velocityModule._z.constantMax);
                            material.setVector3("u_velocityConst" /* VELOCITY_CONST */, minVec3);
                            material.setVector3("u_velocityConstMax" /* VELOCITY_CONST_MAX */, maxVec3);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                            //
                            material.setVector2v("u_velocityCurveX[0]" /* VELOCITY_CURVE_X */, velocityModule._x.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveY[0]" /* VELOCITY_CURVE_Y */, velocityModule._y.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveZ[0]" /* VELOCITY_CURVE_Z */, velocityModule._z.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveMaxX[0]" /* VELOCITY_CURVE_MAX_X */, velocityModule._x.curveMax.floatValues);
                            material.setVector2v("u_velocityCurveMaxY[0]" /* VELOCITY_CURVE_MAX_Y */, velocityModule._y.curveMax.floatValues);
                            material.setVector2v("u_velocityCurveMaxZ[0]" /* VELOCITY_CURVE_MAX_Z */, velocityModule._z.curveMax.floatValues);
                            break;
                        }
                    }
                    material.setInt("u_spaceType" /* SPACE_TYPE */, velocityModule._space);
                }
            };
            /**
             * 更新颜色模块
             * @param component
             */
            ParticleSystem.prototype._onColorOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                material.removeDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                var colorModule = comp.colorOverLifetime;
                if (colorModule.enable) {
                    var color = colorModule._color;
                    switch (color.mode) {
                        case 1 /* Gradient */: {
                            material.addDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                            //
                            material.setVector2v("u_alphaGradient[0]" /* ALPHAS_GRADIENT */, color.gradient.alphaValues);
                            material.setVector4v("u_colorGradient[0]" /* COLOR_GRADIENT */, color.gradient.colorValues);
                            break;
                        }
                        case 3 /* TwoGradients */: {
                            material.addDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                            //
                            material.setVector2v("u_alphaGradient[0]" /* ALPHAS_GRADIENT */, color.gradientMin.alphaValues);
                            material.setVector2v("u_alphaGradientMax[0]" /* ALPHA_GRADIENT_MAX */, color.gradientMax.alphaValues);
                            material.setVector4v("u_colorGradient[0]" /* COLOR_GRADIENT */, color.gradientMin.colorValues);
                            material.setVector4v("u_colorGradientMax[0]" /* COLOR_GRADIENT_MAX */, color.gradientMax.colorValues);
                            break;
                        }
                    }
                }
            };
            /**
             * 更新大小模块
             * @param component
             */
            ParticleSystem.prototype._onSizeOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("SIZECURVE" /* SIZECURVE */);
                material.removeDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                material.removeDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                material.removeDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                var sizeModule = comp.sizeOverLifetime;
                if (sizeModule.enable) {
                    var separateAxes = sizeModule._separateAxes;
                    var mode = sizeModule._x.mode;
                    switch (mode) {
                        case 1 /* Curve */: {
                            if (separateAxes) {
                                material.addDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                                //
                                material.setVector2v("u_sizeCurveX[0]" /* SIZE_CURVE_X */, sizeModule._x.curve.floatValues);
                                material.setVector2v("u_sizeCurveY[0]" /* SIZE_CURVE_Y */, sizeModule._y.curve.floatValues);
                                material.setVector2v("u_sizeCurveZ[0]" /* SIZE_CURVE_Z */, sizeModule._z.curve.floatValues);
                            }
                            else {
                                material.addDefine("SIZECURVE" /* SIZECURVE */);
                                //
                                material.setVector2v("u_sizeCurve[0]" /* SIZE_CURVE */, sizeModule._size.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            if (separateAxes) {
                                material.addDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                                //
                                material.setVector2v("u_sizeCurveX[0]" /* SIZE_CURVE_X */, sizeModule._x.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveY[0]" /* SIZE_CURVE_Y */, sizeModule._y.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveZ[0]" /* SIZE_CURVE_Z */, sizeModule._z.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveMaxX[0]" /* SIZE_CURVE_MAX_X */, sizeModule._x.curveMax.floatValues);
                                material.setVector2v("u_sizeCurveMaxY[0]" /* SIZE_CURVE_MAX_Y */, sizeModule._y.curveMax.floatValues);
                                material.setVector2v("u_sizeCurveMaxZ[0]" /* SIZE_CURVE_MAX_Z */, sizeModule._z.curveMax.floatValues);
                            }
                            else {
                                material.addDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                                //
                                material.setVector2v("u_sizeCurve[0]" /* SIZE_CURVE */, sizeModule._size.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveMax[0]" /* SIZE_CURVE_MAX */, sizeModule._size.curveMax.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            /**
             * 更新旋转模块
             * @param comp
             */
            ParticleSystem.prototype._onRotationOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                material.removeDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                material.removeDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                material.removeDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                material.removeDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                material.removeDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                var rotationModule = comp.rotationOverLifetime;
                if (rotationModule.enable) {
                    var mode = comp.rotationOverLifetime._x.mode;
                    var separateAxes = rotationModule._separateAxes;
                    if (separateAxes) {
                        material.addDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                    }
                    else {
                        material.addDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                    }
                    switch (mode) {
                        case 0 /* Constant */: {
                            material.addDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                            //
                            if (separateAxes) {
                                material.setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule._x.constant, rotationModule._y.constant, rotationModule._z.constant));
                            }
                            else {
                                material.setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule._z.constant);
                            }
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            material.addDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                            //
                            if (separateAxes) {
                                material.setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule._x.constantMin, rotationModule._y.constantMin, rotationModule._z.constantMin));
                                material.setVector3("u_rotationConstMaxSeprarate" /* ROTATION_CONST_MAX_SEPRARATE */, new egret3d.Vector3(rotationModule._x.constantMax, rotationModule._y.constantMax, rotationModule._z.constantMax));
                            }
                            else {
                                material.setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule._z.constantMin);
                                material.setFloat("u_rotationConstMax" /* ROTATION_CONST_MAX */, rotationModule._z.constantMax);
                            }
                            break;
                        }
                        case 1 /* Curve */: {
                            material.addDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                            //
                            if (separateAxes) {
                                material.setVector2v("u_rotationCurveX[0]" /* ROTATE_CURVE_X */, rotationModule._x.curve.floatValues);
                                material.setVector2v("u_rotationCurveY[0]" /* ROTATE_CURVE_y */, rotationModule._y.curve.floatValues);
                                material.setVector2v("u_rotationCurveZ[0]" /* ROTATE_CURVE_Z */, rotationModule._z.curve.floatValues);
                            }
                            else {
                                material.setVector2v("u_rotationCurve[0]" /* ROTATION_CURVE */, rotationModule._z.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                            //
                            if (separateAxes) {
                                material.setVector2v("u_rotationCurveX[0]" /* ROTATE_CURVE_X */, rotationModule._x.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveY[0]" /* ROTATE_CURVE_y */, rotationModule._y.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveZ[0]" /* ROTATE_CURVE_Z */, rotationModule._z.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveMaxX[0]" /* ROTATION_CURVE_MAX_X */, rotationModule._x.curveMax.floatValues);
                                material.setVector2v("u_rotationCurveMaxY[0]" /* ROTATION_CURVE_MAX_Y */, rotationModule._y.curveMax.floatValues);
                                material.setVector2v("u_rotationCurveMaxZ[0]" /* ROTATION_CURVE_MAX_Z */, rotationModule._z.curveMax.floatValues);
                            }
                            else {
                                material.setVector2v("u_rotationCurve[0]" /* ROTATION_CURVE */, rotationModule._z.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveMax[0]" /* ROTATION_CURVE_MAX */, rotationModule._z.curveMin.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            ParticleSystem.prototype._onTextureSheetAnimation = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                material.removeDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                var module = comp.textureSheetAnimation;
                if (module.enable) {
                    var type = module._frameOverTime.mode;
                    switch (type) {
                        case 1 /* Curve */: {
                            material.addDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                            //
                            material.setVector2v("u_uvCurve[0]" /* UV_CURVE */, module._frameOverTime.curve.floatValues);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                            //
                            material.setVector2v("u_uvCurve[0]" /* UV_CURVE */, module._frameOverTime.curveMin.floatValues);
                            material.setVector2v("u_uvCurveMax[0]" /* UV_CURVE_MAX */, module._frameOverTime.curveMax.floatValues);
                            break;
                        }
                    }
                    if (type === 1 /* Curve */ || type === 2 /* TwoCurves */) {
                        material.setFloat("u_cycles" /* CYCLES */, module._cycleCount);
                        material.setVector4v("u_subUV" /* SUB_UV */, module.floatValues);
                    }
                }
            };
            ParticleSystem.prototype._updateDrawCalls = function (gameObject) {
                if (!this._enabled || !this._groups[0].hasGameObject(gameObject)) {
                    return;
                }
                var component = gameObject.getComponent(particle.ParticleComponent);
                var renderer = gameObject.getComponent(particle.ParticleRenderer);
                //
                this._onUpdateBatchMesh(component);
                this._drawCalls.removeDrawCalls(renderer);
                if (!renderer.batchMesh || !renderer.batchMaterial) {
                    return;
                }
                if (renderer._renderMode === 5 /* None */) {
                    console.error("ParticleSystem : error renderMode");
                }
                renderer.batchMesh._createBuffer();
                this._drawCalls.renderers.push(renderer);
                //
                var subMeshIndex = 0;
                for (var _i = 0, _a = renderer.batchMesh.glTFMesh.primitives; _i < _a.length; _i++) {
                    var _primitive = _a[_i];
                    var drawCall = {
                        renderer: renderer,
                        subMeshIndex: subMeshIndex++,
                        mesh: renderer.batchMesh,
                        material: renderer.batchMaterial || egret3d.DefaultMaterials.MISSING,
                        zdist: -1,
                    };
                    this._drawCalls.drawCalls.push(drawCall);
                }
            };
            ParticleSystem.prototype.onEnable = function () {
                for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    this._updateDrawCalls(gameObject);
                }
            };
            ParticleSystem.prototype.onAddGameObject = function (gameObject, _group) {
                this._updateDrawCalls(gameObject);
                var component = gameObject.getComponent(particle.ParticleComponent);
                if (component.main.playOnAwake) {
                    component.play();
                }
            };
            ParticleSystem.prototype.onRemoveGameObject = function (gameObject) {
                this._drawCalls.removeDrawCalls(gameObject.renderer);
                // component.stop();
            };
            ParticleSystem.prototype.onUpdate = function (deltaTime) {
                for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    gameObject.getComponent(particle.ParticleComponent).update(deltaTime);
                }
            };
            ParticleSystem.prototype.onDisable = function () {
                for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    this._drawCalls.removeDrawCalls(gameObject.renderer);
                }
            };
            return ParticleSystem;
        }(paper.BaseSystem));
        particle.ParticleSystem = ParticleSystem;
        __reflect(ParticleSystem.prototype, "egret3d.particle.ParticleSystem");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 全局碰撞信息收集组件。
     */
    var ContactColliders = (function (_super) {
        __extends(ContactColliders, _super);
        function ContactColliders() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 当前帧开始碰撞的。
             */
            _this.begin = [];
            /**
             * 当前帧维持碰撞的。
             */
            _this.stay = [];
            /**
             * 当前帧结束碰撞的。
             */
            _this.end = [];
            return _this;
        }
        /**
         * @internal
         */
        ContactColliders.prototype.clear = function () {
            this.begin.length = 0;
            this.end.length = 0;
        };
        return ContactColliders;
    }(paper.SingletonComponent));
    paper.ContactColliders = ContactColliders;
    __reflect(ContactColliders.prototype, "paper.ContactColliders");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 全局时间信息组件。
     */
    var Clock = (function (_super) {
        __extends(Clock, _super);
        function Clock() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.maxFixedSubSteps = 3;
            _this.fixedDeltaTime = 1.0 / 50.0; // TODO same as fps.
            _this.timeScale = 1.0;
            _this._frameCount = 0;
            _this._beginTime = 0.0;
            _this._lastTime = 0.0;
            _this._delayTime = 0.0;
            _this._unscaledTime = 0.0;
            _this._unscaledDeltaTime = 0.0;
            _this._fixedTime = 0.0;
            return _this;
        }
        Clock.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this._beginTime = Date.now() * 0.001;
        };
        /**
         * @internal
         */
        Clock.prototype.update = function (time) {
            if (this._unscaledTime !== 0.0) {
                this._lastTime = this._unscaledTime;
                if (this._fixedTime < this.fixedDeltaTime) {
                }
                else if (this._fixedTime < this.fixedDeltaTime * this.maxFixedSubSteps) {
                    this._fixedTime %= this.fixedDeltaTime;
                }
                else {
                    this._fixedTime -= this.fixedDeltaTime * this.maxFixedSubSteps;
                }
            }
            var now = time || Date.now() * 0.001;
            this._frameCount += 1;
            this._unscaledTime = now - this._beginTime;
            this._unscaledDeltaTime = this._unscaledTime - this._lastTime;
            this._fixedTime += this._unscaledDeltaTime;
        };
        Object.defineProperty(Clock.prototype, "frameCount", {
            get: function () {
                return this._frameCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "time", {
            /**
             * 从程序开始运行时的累计时间。（以秒为单位）
             */
            get: function () {
                return this._unscaledTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "fixedTime", {
            /**
             *
             */
            get: function () {
                return this._fixedTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "deltaTime", {
            /**
             * 上一帧到当前帧流逝的时间。
             */
            get: function () {
                return this._unscaledDeltaTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "unscaledTime", {
            /**
             *
             */
            get: function () {
                return this._unscaledTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "unscaledDeltaTime", {
            /**
             *
             */
            get: function () {
                return this._unscaledDeltaTime;
            },
            enumerable: true,
            configurable: true
        });
        return Clock;
    }(paper.SingletonComponent));
    paper.Clock = Clock;
    __reflect(Clock.prototype, "paper.Clock");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 已丢失或不支持的组件数据备份。
     */
    var MissingComponent = (function (_super) {
        __extends(MissingComponent, _super);
        function MissingComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.missingObject = null;
            return _this;
        }
        __decorate([
            paper.serializedField
        ], MissingComponent.prototype, "missingObject", void 0);
        return MissingComponent;
    }(paper.BaseComponent));
    paper.MissingComponent = MissingComponent;
    __reflect(MissingComponent.prototype, "paper.MissingComponent");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 关心组件的类型。
     */
    var InterestType;
    (function (InterestType) {
        /**
         *
         */
        InterestType[InterestType["Extends"] = 1] = "Extends";
        /**
         *
         */
        InterestType[InterestType["Exculde"] = 2] = "Exculde";
        /**
         *
         */
        InterestType[InterestType["Unessential"] = 4] = "Unessential";
    })(InterestType = paper.InterestType || (paper.InterestType = {}));
    /**
     * 实体组。
     * - 收集符合指定特征的实体。
     */
    var GameObjectGroup = (function () {
        function GameObjectGroup(interestConfig) {
            /**
             * @internal
             */
            this.locked = false;
            this._isRemoved = false;
            this._isBehaviour = false;
            // TODO add systems
            this._bufferedGameObjects = [];
            /**
             * @internal
             */
            this._addedGameObjects = [];
            this._gameObjects = [];
            this._bufferedComponents = [];
            /**
             * @internal
             */
            this._addedComponents = [];
            this._behaviourComponents = [];
            this._interestConfig = null;
            this._isBehaviour = interestConfig.length === 1 && interestConfig[0].type !== undefined && interestConfig[0].type !== 0;
            this._interestConfig = interestConfig;
            this._onAddComponent = this._onAddComponent.bind(this);
            this._onRemoveComponent = this._onRemoveComponent.bind(this);
            this._onAddUnessentialComponent = this._onAddUnessentialComponent.bind(this);
            this._onRemoveUnessentialComponent = this._onRemoveUnessentialComponent.bind(this);
            for (var _i = 0, _a = this._interestConfig; _i < _a.length; _i++) {
                var config = _a[_i];
                var isUnessential = config.type && (config.type & 4 /* Unessential */);
                if (Array.isArray(config.componentClass)) {
                    for (var _b = 0, _c = config.componentClass; _b < _c.length; _b++) {
                        var componentClass = _c[_b];
                        paper.EventPool.addEventListener("__disabled__" /* Disabled */, componentClass, this._onRemoveUnessentialComponent);
                        if (!isUnessential) {
                            paper.EventPool.addEventListener("__enabled__" /* Enabled */, componentClass, this._onAddComponent);
                            paper.EventPool.addEventListener("__disabled__" /* Disabled */, componentClass, this._onRemoveComponent);
                        }
                        paper.EventPool.addEventListener("__enabled__" /* Enabled */, componentClass, this._onAddUnessentialComponent);
                    }
                }
                else {
                    paper.EventPool.addEventListener("__disabled__" /* Disabled */, config.componentClass, this._onRemoveUnessentialComponent);
                    if (!isUnessential) {
                        paper.EventPool.addEventListener("__enabled__" /* Enabled */, config.componentClass, this._onAddComponent);
                        paper.EventPool.addEventListener("__disabled__" /* Disabled */, config.componentClass, this._onRemoveComponent);
                    }
                    paper.EventPool.addEventListener("__enabled__" /* Enabled */, config.componentClass, this._onAddUnessentialComponent);
                }
            }
            for (var _d = 0, _e = paper.Application.sceneManager.scenes; _d < _e.length; _d++) {
                var scene = _e[_d];
                for (var _f = 0, _g = scene.gameObjects; _f < _g.length; _f++) {
                    var gameObject = _g[_f];
                    this._addGameObject(gameObject);
                }
            }
        }
        /**
         * @internal
         */
        GameObjectGroup.create = function (interestConfig) {
            interestConfig = Array.isArray(interestConfig) ? interestConfig : [interestConfig];
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group_1 = _a[_i];
                if (group_1._interestConfig.length !== interestConfig.length) {
                    continue;
                }
                var isSame = true;
                for (var i = 0, l = interestConfig.length; i < l; ++i) {
                    var configA = interestConfig[i];
                    var configB = group_1._interestConfig[i];
                    if (configA.type !== configB.type) {
                        isSame = false;
                        break;
                    }
                    if (Array.isArray(configA.componentClass) && Array.isArray(configB.componentClass)) {
                        if (configA.componentClass.length !== configB.componentClass.length) {
                            isSame = false;
                            break;
                        }
                    }
                    else if (configA.componentClass !== configB.componentClass) {
                        isSame = false;
                        break;
                    }
                }
                if (isSame) {
                    return group_1;
                }
            }
            var group = new GameObjectGroup(interestConfig);
            this._groups.push(group);
            return group;
        };
        /**
         * @internal
         */
        GameObjectGroup.update = function () {
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group = _a[_i];
                group._update();
            }
        };
        GameObjectGroup.prototype._onAddComponent = function (component) {
            this._addGameObject(component.gameObject);
        };
        GameObjectGroup.prototype._onAddUnessentialComponent = function (component) {
            var gameObject = component.gameObject;
            if (!this._isBehaviour) {
                if (gameObject === paper.GameObject.globalGameObject) {
                    return;
                }
                if (this._bufferedGameObjects.indexOf(gameObject) < 0 && this._gameObjects.indexOf(gameObject) < 0) {
                    return;
                }
            }
            if (this._bufferedComponents.indexOf(component) >= 0 || this._behaviourComponents.indexOf(component) >= 0) {
                return;
            }
            this._bufferedComponents.push(component);
        };
        GameObjectGroup.prototype._onRemoveUnessentialComponent = function (component) {
            var gameObject = component.gameObject;
            var index = this._bufferedComponents.indexOf(component);
            if (index >= 0) {
                this._bufferedComponents.splice(index, 1);
                return;
            }
            if (this._isBehaviour) {
                index = this._behaviourComponents.indexOf(component);
                if (index < 0) {
                    return;
                }
                this._isRemoved = true;
                this._behaviourComponents[index] = null;
                index = this._addedComponents.indexOf(component);
                if (index >= 0) {
                    this._addedComponents[index] = null;
                }
            }
            else {
                if (gameObject === paper.GameObject.globalGameObject) {
                    return;
                }
                if (this._gameObjects.indexOf(gameObject) < 0) {
                    return;
                }
                index = this._addedComponents.indexOf(component);
                if (index >= 0) {
                    this._addedComponents[index] = null;
                }
            }
            for (var _i = 0, _a = paper.Application.systemManager.systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (!system.onRemoveComponent || system.groups.indexOf(this) < 0) {
                    continue;
                }
                system.onRemoveComponent(component, this);
            }
        };
        GameObjectGroup.prototype._onRemoveComponent = function (component) {
            this._removeGameObject(component.gameObject);
        };
        GameObjectGroup.prototype._addGameObject = function (gameObject) {
            if (!this._isBehaviour && gameObject === paper.GameObject.globalGameObject) {
                return;
            }
            if (this._bufferedGameObjects.indexOf(gameObject) >= 0 ||
                this._gameObjects.indexOf(gameObject) >= 0) {
                return;
            }
            for (var _i = 0, _a = this._interestConfig; _i < _a.length; _i++) {
                var config = _a[_i];
                if (config.type && (config.type & 4 /* Unessential */)) {
                    continue;
                }
                var isExtends = config.type && (config.type & 1 /* Extends */) !== 0;
                var isExculde = config.type && (config.type & 2 /* Exculde */) !== 0;
                var insterestComponent = null;
                if (Array.isArray(config.componentClass)) {
                    for (var _b = 0, _c = config.componentClass; _b < _c.length; _b++) {
                        var componentClass = _c[_b];
                        insterestComponent = gameObject.getComponent(componentClass, isExtends);
                        if (insterestComponent) {
                            break;
                        }
                    }
                }
                else {
                    insterestComponent = gameObject.getComponent(config.componentClass, isExtends);
                }
                if (isExculde ? insterestComponent : !insterestComponent) {
                    return;
                }
            }
            this._bufferedGameObjects.push(gameObject);
        };
        GameObjectGroup.prototype._removeGameObject = function (gameObject) {
            var index = this._bufferedGameObjects.indexOf(gameObject);
            if (index >= 0) {
                this._bufferedGameObjects.splice(index, 1);
            }
            else {
                index = this._gameObjects.indexOf(gameObject);
                if (index >= 0) {
                    if (this.locked) {
                        this.locked = false;
                        this._gameObjects = this._gameObjects.concat();
                    }
                    this._gameObjects.splice(index, 1);
                    index = this._addedGameObjects.indexOf(gameObject);
                    if (index >= 0) {
                        this._addedGameObjects[index] = null;
                    }
                    for (var _i = 0, _a = paper.Application.systemManager.systems; _i < _a.length; _i++) {
                        var system = _a[_i];
                        if (!system.onRemoveGameObject || system.groups.indexOf(this) < 0) {
                            continue;
                        }
                        system.onRemoveGameObject(gameObject, this);
                    }
                }
            }
        };
        GameObjectGroup.prototype._update = function () {
            this.locked = false;
            if (this._addedGameObjects.length > 0) {
                this._addedGameObjects.length = 0;
            }
            if (this._addedComponents.length > 0) {
                this._addedComponents.length = 0;
            }
            if (this._isRemoved) {
                var index = 0;
                var removeCount = 0;
                this._isRemoved = false;
                for (var _i = 0, _a = this._behaviourComponents; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (component) {
                        if (removeCount > 0) {
                            this._behaviourComponents[index - removeCount] = component;
                            this._behaviourComponents[index] = null;
                        }
                    }
                    else {
                        removeCount++;
                    }
                    index++;
                }
                if (removeCount > 0) {
                    this._behaviourComponents.length -= removeCount;
                }
            }
            if (this._bufferedGameObjects.length > 0) {
                for (var _b = 0, _c = this._bufferedGameObjects; _b < _c.length; _b++) {
                    var gameObject = _c[_b];
                    if (!gameObject) {
                        continue;
                    }
                    this._addedGameObjects.push(gameObject);
                    this._gameObjects.push(gameObject);
                }
                this._bufferedGameObjects.length = 0;
            }
            if (this._bufferedComponents.length > 0) {
                for (var _d = 0, _e = this._bufferedComponents; _d < _e.length; _d++) {
                    var component = _e[_d];
                    if (!component) {
                        continue;
                    }
                    this._addedComponents.push(component);
                    if (component instanceof paper.Behaviour) {
                        if (component.gameObject.getComponent(egret3d.Camera)) {
                            this._behaviourComponents.unshift(component);
                        }
                        else {
                            this._behaviourComponents.push(component);
                        }
                    }
                }
                this._bufferedComponents.length = 0;
            }
        };
        /**
         * 该组是否已收集指定的实体。
         */
        GameObjectGroup.prototype.hasGameObject = function (gameObject) {
            return this._gameObjects.indexOf(gameObject) >= 0;
        };
        Object.defineProperty(GameObjectGroup.prototype, "gameObjects", {
            /**
             * 该组已收集的全部实体。
             */
            get: function () {
                return this._gameObjects;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObjectGroup.prototype, "components", {
            /**
             * 该组已收集的全部组件。
             */
            get: function () {
                return this._behaviourComponents;
            },
            enumerable: true,
            configurable: true
        });
        GameObjectGroup._groups = [];
        return GameObjectGroup;
    }());
    paper.GameObjectGroup = GameObjectGroup;
    __reflect(GameObjectGroup.prototype, "paper.GameObjectGroup");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var GroupComponent = (function (_super) {
        __extends(GroupComponent, _super);
        function GroupComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.componentIndex = -1;
            _this.componentClass = null;
            _this._components = [];
            return _this;
        }
        GroupComponent.prototype._addComponent = function (component) {
            this._components.push(component);
        };
        GroupComponent.prototype._removeComponent = function (component) {
            var index = this._components.indexOf(component);
            if (index >= 0) {
                this._components.splice(1, 0);
            }
        };
        Object.defineProperty(GroupComponent.prototype, "components", {
            get: function () {
                return this._components;
            },
            enumerable: true,
            configurable: true
        });
        return GroupComponent;
    }(paper.BaseComponent));
    paper.GroupComponent = GroupComponent;
    __reflect(GroupComponent.prototype, "paper.GroupComponent");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var EnableSystem = (function (_super) {
        __extends(EnableSystem, _super);
        function EnableSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        EnableSystem.prototype.onAddComponent = function (component) {
            if (!component) {
                return;
            }
            if (paper.Application.playerMode === 2 /* Editor */) {
                if (!component.constructor.executeInEditMode) {
                    return;
                }
                if (!component._isReseted) {
                    component._isReseted = true;
                    component.onReset && component.onReset();
                }
            }
            component.onEnable && component.onEnable();
        };
        return EnableSystem;
    }(paper.BaseSystem));
    paper.EnableSystem = EnableSystem;
    __reflect(EnableSystem.prototype, "paper.EnableSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var StartSystem = (function (_super) {
        __extends(StartSystem, _super);
        function StartSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        StartSystem.prototype.onAddComponent = function (component) {
            if (!component || component._isStarted) {
                return;
            }
            if (paper.Application.playerMode === 2 /* Editor */ &&
                !component.constructor.executeInEditMode) {
                return;
            }
            component._isStarted = true;
            component.onStart && component.onStart();
        };
        return StartSystem;
    }(paper.BaseSystem));
    paper.StartSystem = StartSystem;
    __reflect(StartSystem.prototype, "paper.StartSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 固定更新系统。
     */
    var FixedUpdateSystem = (function (_super) {
        __extends(FixedUpdateSystem, _super);
        function FixedUpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        FixedUpdateSystem.prototype.onUpdate = function () {
            var currentTimes = 0;
            var fixedTime = this._clock.fixedTime;
            var totalTimes = Math.min(Math.floor(fixedTime / this._clock.fixedDeltaTime), this._clock.maxFixedSubSteps);
            var components = this._groups[0].components;
            while (fixedTime >= this._clock.fixedDeltaTime && currentTimes++ < this._clock.maxFixedSubSteps) {
                for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
                    var component = components_1[_i];
                    if (component) {
                        component.onFixedUpdate && component.onFixedUpdate(currentTimes, totalTimes);
                    }
                }
                fixedTime -= this._clock.fixedDeltaTime;
            }
        };
        return FixedUpdateSystem;
    }(paper.BaseSystem));
    paper.FixedUpdateSystem = FixedUpdateSystem;
    __reflect(FixedUpdateSystem.prototype, "paper.FixedUpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 更新系统。
     */
    var UpdateSystem = (function (_super) {
        __extends(UpdateSystem, _super);
        function UpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        UpdateSystem.prototype.onUpdate = function (deltaTime) {
            var components = this._groups[0].components;
            if (paper.Application.playerMode === 2 /* Editor */) {
                for (var _i = 0, components_2 = components; _i < components_2.length; _i++) {
                    var component = components_2[_i];
                    if (component && component.constructor.executeInEditMode) {
                        component.onUpdate && component.onUpdate(deltaTime);
                    }
                }
            }
            else {
                for (var _a = 0, components_3 = components; _a < components_3.length; _a++) {
                    var component = components_3[_a];
                    if (component) {
                        component.onUpdate && component.onUpdate(deltaTime);
                    }
                }
            }
        };
        return UpdateSystem;
    }(paper.BaseSystem));
    paper.UpdateSystem = UpdateSystem;
    __reflect(UpdateSystem.prototype, "paper.UpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 更新系统。
     */
    var LateUpdateSystem = (function (_super) {
        __extends(LateUpdateSystem, _super);
        function LateUpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            _this._laterCalls = [];
            return _this;
        }
        LateUpdateSystem.prototype.onUpdate = function (deltaTime) {
            // Update behaviours.
            var components = this._groups[0].components;
            if (paper.Application.playerMode === 2 /* Editor */) {
                for (var _i = 0, components_4 = components; _i < components_4.length; _i++) {
                    var component = components_4[_i];
                    if (component && component.constructor.executeInEditMode) {
                        component.onLateUpdate && component.onLateUpdate(deltaTime);
                    }
                }
            }
            else {
                for (var _a = 0, components_5 = components; _a < components_5.length; _a++) {
                    var component = components_5[_a];
                    if (component) {
                        component.onLateUpdate && component.onLateUpdate(deltaTime);
                    }
                }
            }
            //
            egret.ticker.update(); // TODO 帧频
            //
            if (this._laterCalls.length > 0) {
                for (var _b = 0, _c = this._laterCalls; _b < _c.length; _b++) {
                    var callback = _c[_b];
                    callback();
                }
                this._laterCalls.length = 0;
            }
        };
        /**
         *
         */
        LateUpdateSystem.prototype.callLater = function (callback) {
            this._laterCalls.push(callback);
        };
        return LateUpdateSystem;
    }(paper.BaseSystem));
    paper.LateUpdateSystem = LateUpdateSystem;
    __reflect(LateUpdateSystem.prototype, "paper.LateUpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var DisableSystem = (function (_super) {
        __extends(DisableSystem, _super);
        function DisableSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            _this._contactColliders = paper.GameObject.globalGameObject.getOrAddComponent(paper.ContactColliders);
            _this._disposeCollecter = paper.GameObject.globalGameObject.getOrAddComponent(paper.DisposeCollecter);
            return _this;
        }
        DisableSystem.prototype.onRemoveComponent = function (component) {
            if (!component) {
                return;
            }
            if (paper.Application.playerMode === 2 /* Editor */ &&
                !component.constructor.executeInEditMode) {
                return;
            }
            component.onDisable && component.onDisable();
        };
        DisableSystem.prototype.onUpdate = function () {
            var gameObjectPool = paper.GameObject._instances;
            for (var _i = 0, _a = this._disposeCollecter.scenes; _i < _a.length; _i++) {
                var scene = _a[_i];
                scene.uninitialize();
            }
            for (var _b = 0, _c = this._disposeCollecter.gameObjects; _b < _c.length; _b++) {
                var gameObject = _c[_b];
                // gameObjectPool.push(gameObject);
                gameObject.uninitialize();
            }
            for (var _d = 0, _e = this._disposeCollecter.components; _d < _e.length; _d++) {
                var component = _e[_d];
                component.uninitialize();
            }
            for (var _f = 0, _g = this._disposeCollecter.releases; _f < _g.length; _f++) {
                var instance = _g[_f];
                var instances = instance.constructor._instances; // TODO
                instances.push(instance);
            }
            this._contactColliders.clear();
            this._disposeCollecter.clear();
        };
        return DisableSystem;
    }(paper.BaseSystem));
    paper.DisableSystem = DisableSystem;
    __reflect(DisableSystem.prototype, "paper.DisableSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    paper.serializeClassMap = {
        0: "paper.Scene",
        1: "paper.GameObject",
        2: "egret3d.AniPlayer",
        3: "egret3d.BoxCollider",
        4: "egret3d.Camera",
        5: "egret3d.MeshFilter",
        6: "egret3d.MeshRenderer",
        7: "egret3d.particle.ParticleComponent",
        8: "egret3d.particle.ParticleRenderer",
        9: "egret3d.SkinnedMeshRenderer",
        10: "egret3d.SphereCollider",
        11: "egret3d.Transform",
        12: "egret3d.Shader",
        15: "egret3d.AnimationClip",
        16: "egret3d.TPoseInfo",
        17: "egret3d.PoseBoneMatrix",
        18: "egret3d.Texture",
        19: "egret3d.Texture",
        20: "egret3d.Vector2",
        21: "egret3d.Vector3",
        22: "egret3d.Vector4",
        23: "egret3d.Quaternion",
        24: "egret3d.Color",
        25: "egret3d.Gradient",
        26: "egret3d.Curve",
        27: "egret3d.Keyframe",
        28: "egret3d.Rect",
        29: "egret3d.MainModule",
        30: "egret3d.EmissionModule",
        31: "egret3d.ShapeModule",
        32: "egret3d.VelocityOverLifetimeModule",
        33: "egret3d.RotationOverLifetimeModule",
        34: "egret3d.ColorOverLifetimeModule",
        35: "egret3d.SizeOverLifetimeModule",
        36: "egret3d.MinMaxCurve",
        37: "egret3d.MinMaxGradient",
        38: "egret3d.alphaKey",
        39: "egret3d.colorKey",
        40: "egret3d.Animation",
        41: "egret3d.GLTFAsset",
        //
        13: "paper.Compatible",
        14: "paper.Compatible",
    };
    /**
     * @internal
     */
    var Compatible = (function () {
        function Compatible() {
        }
        Compatible.prototype.serialize = function () {
            throw new Error("Never");
        };
        Compatible.prototype.deserialize = function (element, data) {
            if (!data) {
                throw new Error("Never");
            }
            return data.getAssetOrComponent(element._glTFAsset);
        };
        return Compatible;
    }());
    paper.Compatible = Compatible;
    __reflect(Compatible.prototype, "paper.Compatible", ["paper.ISerializable"]);
})(paper || (paper = {}));
var paper;
(function (paper) {
    var KEY_UUID = "uuid";
    var KEY_ASSET = "asset";
    var KEY_CLASS = "class";
    var KEY_DESERIALIZE = "deserialize";
    var KEY_COMPONENTS = "components";
    var KEY_EXTRAS = "extras";
    var KEY_CHILDREN = "children";
    function _getDeserializedKeys(serializedClass, keys) {
        if (keys === void 0) { keys = null; }
        var serializeKeys = serializedClass.__serializeKeys;
        if (serializeKeys) {
            keys = keys || {};
            for (var key in serializeKeys) {
                var retargetKey = serializeKeys[key];
                if (retargetKey) {
                    keys[retargetKey] = key;
                }
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getDeserializedKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    function _getDeserializedIgnoreKeys(serializedClass, keys) {
        if (keys === void 0) { keys = null; }
        if (serializedClass.__deserializeIgnore) {
            keys = keys || [];
            for (var _i = 0, _a = serializedClass.__deserializeIgnore; _i < _a.length; _i++) {
                var key = _a[_i];
                keys.push(key);
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getDeserializedIgnoreKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    /**
     *
     */
    var Deserializer = (function () {
        function Deserializer() {
            /**
             *
             */
            this.assets = [];
            /**
             *
             */
            this.objects = {};
            /**
             *
             */
            this.components = {};
            this._deserializers = {};
            this._rootTarget = null;
        }
        Deserializer.prototype._deserializeObject = function (source, target) {
            var deserializedKeys = _getDeserializedKeys(target.constructor);
            var deserializedIgnoreKeys = _getDeserializedIgnoreKeys(target.constructor);
            for (var k in source) {
                if (k === KEY_CLASS) {
                    continue;
                }
                if (!this._keepUUID && k === KEY_UUID) {
                    continue;
                }
                var kk = (deserializedKeys && k in deserializedKeys) ? deserializedKeys[k] : k;
                if (deserializedIgnoreKeys &&
                    deserializedIgnoreKeys.indexOf(kk) >= 0) {
                    continue;
                }
                target[kk] = this._deserializeChild(source[k], target[kk]);
            }
            return target;
        };
        Deserializer.prototype._createComponent = function (componentSource, source, target) {
            var className = paper.serializeClassMap[componentSource.class] || componentSource.class;
            var clazz = egret.getDefinitionByName(className);
            var componentTarget = undefined;
            if (clazz) {
                var hasLink = KEY_EXTRAS in componentSource && componentSource[KEY_EXTRAS].linkedID;
                if (clazz === egret3d.Transform) {
                    componentTarget = this.components[componentSource.uuid];
                    if (KEY_CHILDREN in componentSource) {
                        for (var _i = 0, _a = componentSource[KEY_CHILDREN]; _i < _a.length; _i++) {
                            var childUUID = _a[_i];
                            var child = this.components[childUUID.uuid];
                            if (child && child._parent !== componentTarget) {
                                child._parent = componentTarget;
                                componentTarget._children.push(child);
                            }
                        }
                    }
                }
                else {
                    if (hasLink) {
                        var componentExtras = componentSource[KEY_EXTRAS];
                        var extras = source[KEY_EXTRAS];
                        var linkedID = componentExtras.linkedID;
                        var prefabDeserializer = this._deserializers[extras.prefab ? source.uuid : extras.rootID];
                        componentTarget = prefabDeserializer.components[linkedID];
                    }
                    else {
                        componentTarget = (target || this._rootTarget).addComponent(clazz);
                    }
                    // if (clazz === Behaviour) { TODO
                    //     (componentTarget as Behaviour)._isReseted = true;
                    // }
                }
                if (!hasLink && this._makeLink && componentTarget) {
                    componentTarget.extras.linkedID = componentSource.uuid;
                }
            }
            else {
                componentTarget = (target || this._rootTarget).addComponent(paper.MissingComponent);
                componentTarget.missingObject = componentSource;
                console.warn("Class " + className + " is not defined.");
            }
            this.components[componentSource.uuid] = componentTarget;
            return componentTarget;
        };
        Deserializer.prototype._deserializeChild = function (source, target) {
            if (source === null || source === undefined) {
                return source;
            }
            switch (typeof source) {
                case "function":
                    return undefined;
                case "object": {
                    if (target) {
                        if (ArrayBuffer.isView(target)) {
                            for (var i = 0, l = Math.min(source.length, target.length); i < l; ++i) {
                                target[i] = source[i];
                            }
                            return target;
                        }
                        else if (Array.isArray(target) && target.length === 0) {
                            for (var i = 0, l = source.length; i < l; ++i) {
                                target[i] = this._deserializeChild(source[i]);
                            }
                            return target;
                        }
                        else if (target[KEY_DESERIALIZE]) {
                            return target.deserialize(source, this);
                        }
                        else {
                            // console.info("Deserialize can be optimized."); TODO
                        }
                    }
                    if (Array.isArray(source)) {
                        target = [];
                        for (var i = 0, l = source.length; i < l; ++i) {
                            target[i] = this._deserializeChild(source[i]);
                        }
                        return target;
                    }
                    var classCodeOrName = source[KEY_CLASS];
                    if (KEY_ASSET in source) {
                        var assetIndex = source.asset;
                        if (assetIndex >= 0) {
                            return paper.Asset.find(this.assets[assetIndex]);
                        }
                        return null;
                    }
                    else if (KEY_UUID in source) {
                        var uuid = source.uuid;
                        if (uuid in this.objects) {
                            return this.objects[uuid];
                        }
                        else if (uuid in this.components) {
                            return this.components[uuid];
                        }
                        else if (classCodeOrName) {
                            var scene = this._rootTarget instanceof paper.GameObject ? this._rootTarget.scene : this._rootTarget;
                            if ((paper.serializeClassMap[classCodeOrName] || classCodeOrName) === egret.getQualifiedClassName(paper.GameObject)) {
                                for (var _i = 0, _a = scene.gameObjects; _i < _a.length; _i++) {
                                    var gameObject = _a[_i];
                                    if (gameObject.uuid === uuid) {
                                        return gameObject;
                                    }
                                }
                            }
                            else {
                                for (var _b = 0, _c = scene.gameObjects; _b < _c.length; _b++) {
                                    var gameObject = _c[_b];
                                    for (var _d = 0, _e = gameObject.components; _d < _e.length; _d++) {
                                        var component = _e[_d];
                                        if (component && component.uuid === uuid) {
                                            return component;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else if (classCodeOrName) {
                        var clazz = egret.getDefinitionByName(paper.serializeClassMap[classCodeOrName] || classCodeOrName);
                        if (clazz) {
                            target = new clazz();
                            return target.deserialize(source, this);
                        }
                    }
                    else {
                        target = {};
                        for (var k in source) {
                            target[k] = this._deserializeChild(source[k]);
                        }
                        return target;
                    }
                    console.warn("Deserialize error.", source);
                    return undefined;
                }
                default:
                    return source;
            }
        };
        Deserializer.prototype.getAssetOrComponent = function (source) {
            if (KEY_ASSET in source) {
                var assetIndex = source.asset;
                if (assetIndex >= 0) {
                    return paper.Asset.find(this.assets[assetIndex]);
                }
                return null;
            }
            var uuid = source.uuid;
            return this.components[uuid] || this.objects[uuid];
        };
        /**
         * @internal
         */
        Deserializer.prototype.deserialize = function (data, keepUUID, makeLink, rootTarget) {
            if (keepUUID === void 0) { keepUUID = false; }
            if (makeLink === void 0) { makeLink = false; }
            if (rootTarget === void 0) { rootTarget = null; }
            if (data.assets) {
                for (var _i = 0, _a = data.assets; _i < _a.length; _i++) {
                    var assetName = _a[_i];
                    this.assets.push(assetName);
                }
            }
            this._keepUUID = keepUUID;
            this._makeLink = makeLink;
            this._rootTarget = rootTarget;
            var sceneClassName = egret.getQualifiedClassName(paper.Scene);
            var transformClassName = egret.getQualifiedClassName(egret3d.Transform);
            var components = {};
            var root = null;
            if (data.components) {
                for (var _b = 0, _c = data.components; _b < _c.length; _b++) {
                    var componentSource = _c[_b];
                    components[componentSource.uuid] = componentSource;
                }
            }
            if (data.objects) {
                for (var _d = 0, _e = data.objects; _d < _e.length; _d++) {
                    var source = _e[_d];
                    var className = paper.serializeClassMap[source.class] || source.class;
                    var target = undefined;
                    if (className === sceneClassName) {
                        target = paper.Scene.createEmpty(source.name);
                        this._rootTarget = target;
                    }
                    else {
                        if (!this._rootTarget) {
                            this._rootTarget = paper.Application.sceneManager.activeScene; // TODO
                        }
                        var hasLink = KEY_EXTRAS in source && source[KEY_EXTRAS].linkedID;
                        if (hasLink) {
                            var extras = source[KEY_EXTRAS];
                            var linkedID = extras.linkedID;
                            var prefab = extras.prefab;
                            if (prefab) {
                                var assetIndex = prefab.asset;
                                if (assetIndex >= 0) {
                                    var assetName = this.assets[assetIndex];
                                    target = paper.Prefab.create(assetName, this._rootTarget);
                                    if (target) {
                                        this._deserializers[source.uuid] = Deserializer._lastDeserializer;
                                    }
                                    else {
                                        target = paper.GameObject.create("Missing Prefab" /* MissingPrefab */, "" /* Untagged */, this._rootTarget);
                                    }
                                }
                            }
                            else {
                                var prefabDeserializer = this._deserializers[extras.rootID];
                                target = prefabDeserializer.objects[linkedID];
                                if (!target) {
                                    // Delete node.
                                }
                            }
                        }
                        else {
                            target = paper.GameObject.create("NoName" /* NoName */, "" /* Untagged */, this._rootTarget);
                            if (this._makeLink) {
                                target.extras.linkedID = source.uuid;
                                if (root) {
                                    target.extras.rootID = root.uuid;
                                }
                            }
                        }
                        if (target && KEY_COMPONENTS in source) {
                            for (var _f = 0, _g = source[KEY_COMPONENTS]; _f < _g.length; _f++) {
                                var componentUUID = _g[_f];
                                var uuid = componentUUID.uuid;
                                var componentSource = components[uuid];
                                if ((paper.serializeClassMap[componentSource.class] || componentSource.class) === transformClassName) {
                                    this.components[uuid] = target.transform;
                                }
                            }
                        }
                    }
                    if (target) {
                        this.objects[source.uuid] = target;
                        root = root || target;
                    }
                }
                var i = data.objects.length;
                while (i--) {
                    var source = data.objects[i];
                    var target = this.objects[source.uuid];
                    if (target) {
                        this._deserializeObject(source, target); // 场景或实体属性反序列化。
                        if (target.constructor === paper.GameObject && KEY_COMPONENTS in source) {
                            for (var _h = 0, _j = source[KEY_COMPONENTS]; _h < _j.length; _h++) {
                                var componentUUID = _j[_h];
                                this._createComponent(components[componentUUID.uuid], source, target);
                            }
                        }
                    }
                }
            }
            if (data.components) {
                for (var _k = 0, _l = data.components; _k < _l.length; _k++) {
                    var componentSource = _l[_k];
                    var uuid = componentSource.uuid;
                    var component = this.components[uuid];
                    if (component) {
                        if (component.constructor === paper.MissingComponent) {
                            continue;
                        }
                        this._deserializeObject(componentSource, component);
                    }
                    else if (rootTarget && rootTarget.constructor === paper.GameObject) {
                        component = this._createComponent(componentSource);
                        root = root || component;
                        this._deserializeObject(componentSource, component);
                    }
                }
            }
            Deserializer._lastDeserializer = this;
            return root;
        };
        return Deserializer;
    }());
    paper.Deserializer = Deserializer;
    __reflect(Deserializer.prototype, "paper.Deserializer");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    paper.DATA_VERSION = 3;
    /**
     *
     */
    paper.DATA_VERSIONS = [paper.DATA_VERSION];
    var KEY_GAMEOBJECTS = "gameObjects";
    var KEY_COMPONENTS = "components";
    var KEY_EXTRAS = "extras";
    var KEY_CHILDREN = "children";
    var _inline = false;
    var _serializeds = [];
    var _deserializers = {};
    var _ignoreKeys = ["extras"];
    var _rootIgnoreKeys = ["name", "localPosition", "localRotation", "extras"];
    var _serializeData = null;
    var _defaultGameObject = null;
    /**
     *
     */
    function serialize(source, inline) {
        if (inline === void 0) { inline = false; }
        if (_serializeData) {
            console.warn("The deserialization is not complete.");
        }
        if (!_defaultGameObject) {
            _defaultGameObject = paper.GameObject.create("NoName" /* NoName */, "" /* Untagged */, paper.Application.sceneManager.globalScene);
            _defaultGameObject.parent = paper.GameObject.globalGameObject;
        }
        _inline = inline;
        _serializeData = { version: paper.DATA_VERSION, assets: [], objects: [], components: [] };
        _serializeObject(source);
        _serializeds.length = 0;
        for (var k in _deserializers) {
            delete _deserializers[k];
        }
        _defaultGameObject.transform.destroyChildren();
        _defaultGameObject.removeAllComponents();
        var serializeData = _serializeData;
        _serializeData = null;
        return serializeData;
    }
    paper.serialize = serialize;
    /**
     *
     */
    function clone(object) {
        var data = serialize(object, true);
        var deserializer = new paper.Deserializer();
        return deserializer.deserialize(data);
    }
    paper.clone = clone;
    /**
     *
     */
    function equal(source, target) {
        var typeSource = typeof source;
        var typeTarget = typeof target;
        if (typeSource !== typeTarget) {
            return false;
        }
        if (source === null && target === null) {
            return true;
        }
        if (source === null || target === null) {
            return false;
        }
        switch (typeSource) {
            case "undefined":
            case "boolean":
            case "number":
            case "string":
            case "symbol":
            case "function":
                return source === target;
            case "object":
            default:
                break;
        }
        if ((Array.isArray(source) || ArrayBuffer.isView(source)) &&
            (Array.isArray(target) || ArrayBuffer.isView(target))) {
            var sl = source.length;
            if (sl !== target.length) {
                return false;
            }
            if (sl === 0) {
                return true;
            }
            for (var i = 0; i < sl; ++i) {
                if (!equal(source[i], target[i])) {
                    return false;
                }
            }
            return true;
        }
        if (source.constructor !== target.constructor) {
            return false;
        }
        if (source instanceof paper.Asset ||
            source.constructor === paper.GameObject ||
            source instanceof paper.BaseComponent) {
            return source === target;
        }
        if (source.constructor === Object) {
            for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
                var k = source_1[_i];
                if (!equal(source[k], target[k])) {
                    return false;
                }
            }
            return true;
        }
        if (egret.is(source, "paper.ISerializable")) {
            return equal(source.serialize(), target.serialize());
        }
        if (source instanceof paper.BaseObject) {
            return equal(serializeStruct(source), serializeStruct(target));
        }
        throw new Error("Unsupported data.");
    }
    paper.equal = equal;
    /**
     *
     */
    function serializeAsset(source) {
        if (!source.name) {
            return { asset: -1 };
        }
        if (_serializeData && _serializeData.assets) {
            var index = _serializeData.assets.indexOf(source.name);
            if (index < 0) {
                index = _serializeData.assets.length;
                _serializeData.assets.push(source.name);
            }
            return { asset: index };
        }
        return { asset: -1 };
    }
    paper.serializeAsset = serializeAsset;
    /**
     * 创建指定对象的结构体。
     */
    function serializeStruct(source) {
        var className = egret.getQualifiedClassName(source);
        var target = { class: _findClassCode(className) || className };
        _serializeChildren(source, target, null, null);
        return target;
    }
    paper.serializeStruct = serializeStruct;
    function _getSerializedKeys(serializedClass, keys) {
        if (keys === void 0) { keys = null; }
        var serializeKeys = serializedClass.__serializeKeys;
        if (serializeKeys) {
            keys = keys || [];
            for (var key in serializeKeys) {
                keys.push(serializeKeys[key] || key);
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getSerializedKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    function _findClassCode(name) {
        for (var key in paper.serializeClassMap) {
            if (paper.serializeClassMap[key] === name) {
                return key;
            }
        }
        return "";
    }
    function _serializeReference(source) {
        var className = egret.getQualifiedClassName(source);
        return { uuid: source.uuid, class: _findClassCode(className) || className };
    }
    function _findPrefabRoot(gameObject) {
        while (!gameObject.extras.prefab) {
            gameObject = gameObject.parent;
        }
        return gameObject;
    }
    function _serializeObject(source) {
        if (_serializeds.indexOf(source.uuid) >= 0) {
            return true;
        }
        var target = _serializeReference(source);
        var temp = null;
        var ignoreKeys = _ignoreKeys;
        if (source instanceof paper.GameObject) {
            if (source.isDestroyed) {
                console.warn("Missing game object.");
                return false;
            }
            if (source.extras && source.extras.linkedID) {
                var rootPrefabObject = _findPrefabRoot(source);
                var prefabName = rootPrefabObject.extras.prefab.name;
                if (!(prefabName in _deserializers)) {
                    var prefabGameObject = paper.Prefab.create(prefabName, _defaultGameObject.scene);
                    prefabGameObject.parent = _defaultGameObject;
                    _deserializers[prefabName] = paper.Deserializer._lastDeserializer;
                }
                var deserializer = _deserializers[prefabName];
                temp = deserializer.objects[source.extras.linkedID];
                if (source.extras.prefab) {
                    ignoreKeys = _rootIgnoreKeys;
                }
            }
            else {
                temp = _defaultGameObject;
            }
            _serializeData.objects.push(target);
        }
        else if (source instanceof paper.BaseComponent) {
            if (source.isDestroyed) {
                console.warn("Missing component.");
                return false;
            }
            if (source.extras && source.extras.linkedID) {
                var rootPrefabObject = _findPrefabRoot(source.gameObject);
                var prefabName = rootPrefabObject.extras.prefab.name;
                if (!(prefabName in _deserializers)) {
                    var prefabGameObject = paper.Prefab.create(prefabName, _defaultGameObject.scene);
                    prefabGameObject.parent = _defaultGameObject;
                    _deserializers[prefabName] = paper.Deserializer._lastDeserializer;
                }
                var deserializer = _deserializers[prefabName];
                temp = deserializer.components[source.extras.linkedID];
                if (source.gameObject.extras.prefab) {
                    ignoreKeys = _rootIgnoreKeys;
                }
            }
            else {
                temp = _defaultGameObject.getOrAddComponent(source.constructor);
            }
            _serializeData.components.push(target);
        }
        else {
            _serializeData.objects.push(target);
        }
        _serializeds.push(source.uuid);
        _serializeChildren(source, target, temp, ignoreKeys);
        return true;
    }
    function _serializeChildren(source, target, temp, ignoreKeys) {
        var serializedKeys = _getSerializedKeys(source.constructor);
        if (!serializedKeys) {
            return;
        }
        for (var _i = 0, serializedKeys_1 = serializedKeys; _i < serializedKeys_1.length; _i++) {
            var k = serializedKeys_1[_i];
            if (temp && (!ignoreKeys || ignoreKeys.indexOf(k) < 0) && equal(source[k], temp[k])) {
                continue;
            }
            target[k] = _serializeChild(source[k], source, k);
        }
    }
    function _serializeChild(source, parent, key) {
        if (source === null || source === undefined) {
            return source;
        }
        switch (typeof source) {
            case "function":
                return undefined;
            case "object": {
                if (Array.isArray(source) || ArrayBuffer.isView(source)) {
                    var target = [];
                    for (var _i = 0, _a = source; _i < _a.length; _i++) {
                        var element = _a[_i];
                        var result = _serializeChild(element, parent, key);
                        if (result !== undefined) {
                            target.push(result);
                        }
                    }
                    return target;
                }
                if (source.constructor === Object) {
                    var target = {};
                    for (var k in source) {
                        var result = _serializeChild(source[k], parent, key);
                        if (result !== undefined) {
                            target[k] = result;
                        }
                    }
                    return target;
                }
                if (egret.is(source, "paper.ISerializable")) {
                    return source.serialize();
                }
                if (source instanceof paper.BaseObject) {
                    if (source.constructor === paper.Scene) {
                        return undefined; // Pass.
                    }
                    if (source instanceof paper.Asset) {
                        return serializeAsset(source);
                    }
                    if (source.constructor === paper.GameObject || source instanceof paper.BaseComponent) {
                        if (source.constructor === paper.GameObject && source.hideFlags === 3 /* HideAndDontSave */) {
                            return undefined; // Pass.
                        }
                        else if (source.constructor === egret3d.Transform && source.gameObject.hideFlags === 3 /* HideAndDontSave */) {
                            return undefined; // Pass.
                        }
                        if (parent) {
                            if (parent.constructor === paper.Scene) {
                                if (key === KEY_GAMEOBJECTS) {
                                    return _serializeObject(source) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                            else if (parent.constructor === paper.GameObject) {
                                if (key === KEY_COMPONENTS) {
                                    return _serializeObject(source) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                            else if (parent.constructor === egret3d.Transform) {
                                if (key === KEY_CHILDREN) {
                                    return _serializeObject(source.gameObject) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                        }
                        return _serializeReference(source);
                    }
                    return serializeStruct(source);
                }
                console.warn("Serialize error.", source);
                return undefined; // Pass.
            }
            default:
                return source;
        }
    }
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 应用程序运行模式。
     */
    var PlayerMode;
    (function (PlayerMode) {
        PlayerMode[PlayerMode["Player"] = 0] = "Player";
        PlayerMode[PlayerMode["DebugPlayer"] = 1] = "DebugPlayer";
        PlayerMode[PlayerMode["Editor"] = 2] = "Editor";
    })(PlayerMode = paper.PlayerMode || (paper.PlayerMode = {}));
    /**
     * 应用程序。
     */
    var ECS = (function () {
        function ECS() {
            /**
             * 引擎版本。
             */
            this.version = "1.2.0.001";
            /**
             * 系统管理器。
             */
            this.systemManager = paper.SystemManager.getInstance();
            /**
             * 场景管理器。
             */
            this.sceneManager = paper.SceneManager.getInstance();
            this._isFocused = false;
            this._isRunning = false;
            this._playerMode = 0 /* Player */;
            this._bindUpdate = null;
        }
        /**
         * 应用程序单例。
         */
        ECS.getInstance = function () {
            if (!this._instance) {
                this._instance = new ECS();
            }
            return this._instance;
        };
        ECS.prototype._update = function () {
            if (this._isRunning) {
                requestAnimationFrame(this._bindUpdate);
            }
            paper.Time && paper.Time.update();
            paper.GameObjectGroup.update();
            this.systemManager._update();
        };
        ECS.prototype._updatePlayerMode = function () {
            // if (this._playerMode !== PlayerMode.Player) { TODO
            //     egret3d.Camera.editor; // Active editor camera.
            // }
        };
        /**
         * @internal
         */
        ECS.prototype.init = function (options) {
            this._playerMode = options.playerMode || 0 /* Player */;
            this.systemManager.register(paper.EnableSystem, 1000 /* Enable */);
            this.systemManager.register(paper.StartSystem, 2000 /* Start */);
            this.systemManager.register(paper.FixedUpdateSystem, 3000 /* FixedUpdate */);
            this.systemManager.register(paper.UpdateSystem, 4000 /* Update */);
            this.systemManager.register(paper.LateUpdateSystem, 6000 /* LaterUpdate */);
            this.systemManager.register(paper.DisableSystem, 9000 /* Disable */);
            this._updatePlayerMode();
            this.resume();
        };
        /**
         * TODO
         * @internal
         */
        ECS.prototype.pause = function () {
            this._isRunning = false;
        };
        /**
         * TODO
         * @internal
         */
        ECS.prototype.resume = function () {
            if (this._isRunning) {
                return;
            }
            this._isRunning = true;
            if (!this._bindUpdate) {
                this._bindUpdate = this._update.bind(this);
            }
            this._update();
        };
        Object.defineProperty(ECS.prototype, "isFocused", {
            /**
             * TODO
             * @internal
             */
            get: function () {
                return this._isFocused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "isRunning", {
            /**
             * TODO
             * @internal
             */
            get: function () {
                return this._isRunning;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "playerMode", {
            /**
             * 运行模式。
             */
            get: function () {
                return this._playerMode;
            },
            set: function (value) {
                if (this._playerMode === value) {
                    return;
                }
                this._playerMode = value;
            },
            enumerable: true,
            configurable: true
        });
        ECS._instance = null;
        return ECS;
    }());
    paper.ECS = ECS;
    __reflect(ECS.prototype, "paper.ECS");
    //
    paper.Application = ECS.getInstance();
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * @internal
     */
    var BeginSystem = (function (_super) {
        __extends(BeginSystem, _super);
        function BeginSystem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BeginSystem.prototype.onAwake = function () {
            var globalGameObject = paper.GameObject.globalGameObject;
            globalGameObject.getOrAddComponent(egret3d.DefaultTextures);
            globalGameObject.getOrAddComponent(egret3d.DefaultMeshes);
            globalGameObject.getOrAddComponent(egret3d.DefaultShaders);
            globalGameObject.getOrAddComponent(egret3d.DefaultMaterials);
            paper.Time = globalGameObject.getOrAddComponent(paper.Clock);
            globalGameObject.getOrAddComponent(egret3d.WebGLCapabilities);
        };
        BeginSystem.prototype.onUpdate = function () {
            //
            egret3d.Performance.startCounter("all" /* All */);
            //
            egret3d.stage.update();
        };
        return BeginSystem;
    }(paper.BaseSystem));
    egret3d.BeginSystem = BeginSystem;
    __reflect(BeginSystem.prototype, "egret3d.BeginSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @internal
     */
    var EndSystem = (function (_super) {
        __extends(EndSystem, _super);
        function EndSystem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EndSystem.prototype.onUpdate = function (deltaTime) {
            //
            egret3d.InputManager.update(deltaTime);
            //
            egret3d.Performance.updateFPS();
            egret3d.Performance.endCounter("all" /* All */);
        };
        return EndSystem;
    }(paper.BaseSystem));
    egret3d.EndSystem = EndSystem;
    __reflect(EndSystem.prototype, "egret3d.EndSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    var _helpRotation = egret3d.Quaternion.create();
    var _helpMatrix = egret3d.Matrix4.create();
    var TransformDirty;
    (function (TransformDirty) {
        TransformDirty[TransformDirty["PRS"] = 7] = "PRS";
        TransformDirty[TransformDirty["Position"] = 1] = "Position";
        TransformDirty[TransformDirty["Rotation"] = 2] = "Rotation";
        TransformDirty[TransformDirty["Scale"] = 4] = "Scale";
        TransformDirty[TransformDirty["Euler"] = 8] = "Euler";
        TransformDirty[TransformDirty["Matrix"] = 16] = "Matrix";
    })(TransformDirty || (TransformDirty = {}));
    /**
     * 变换组件。
     * - 实现实体之间的父子关系。
     * - 实现 3D 空间坐标系。
     */
    var Transform = (function (_super) {
        __extends(Transform, _super);
        function Transform() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._localDirty = 7 /* PRS */ | 8 /* Euler */ | 16 /* Matrix */;
            _this._worldDirty = 7 /* PRS */ | 8 /* Euler */ | 16 /* Matrix */;
            /**
             * 世界矩阵的行列式，如果小于0，说明进行了反转
             * @internal
             */
            _this._worldMatrixDeterminant = 0.0;
            _this._localPosition = egret3d.Vector3.create();
            _this._localRotation = egret3d.Quaternion.create();
            _this._localEuler = egret3d.Vector3.create();
            _this._localEulerAngles = egret3d.Vector3.create();
            _this._localScale = egret3d.Vector3.ONE.clone();
            _this._localMatrix = egret3d.Matrix4.create();
            _this._position = egret3d.Vector3.create();
            _this._rotation = egret3d.Quaternion.create();
            _this._euler = egret3d.Vector3.create();
            _this._eulerAngles = egret3d.Vector3.create();
            _this._scale = egret3d.Vector3.ONE.clone();
            /**
             * TODO inverse world matrix.
             */
            _this._worldMatrix = egret3d.Matrix4.create();
            /**
             * @internal
             */
            _this._children = [];
            /**
             * @internal
             */
            _this._parent = null;
            return _this;
        }
        Transform.prototype._removeFromChildren = function (value) {
            var index = 0;
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child === value) {
                    this._children.splice(index, 1);
                    break;
                }
                index++;
            }
        };
        Transform.prototype._dirtify = function (isLocalDirty, dirty) {
            if (isLocalDirty) {
                this._localDirty |= dirty | 16 /* Matrix */;
                if (dirty & 2 /* Rotation */) {
                    this._localDirty |= 4 /* Scale */;
                    this._localDirty |= 8 /* Euler */;
                }
                else if (dirty & 4 /* Scale */) {
                    this._localDirty |= 2 /* Rotation */;
                }
            }
            if (!(this._worldDirty & dirty) || !(this._worldDirty & 16 /* Matrix */)) {
                if (dirty & 1 /* Position */) {
                    this._worldDirty |= dirty | 16 /* Matrix */;
                }
                else {
                    this._worldDirty |= 7 /* PRS */ | 8 /* Euler */ | 16 /* Matrix */;
                }
                for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child._dirtify(false, dirty);
                }
                if (this.gameObject.renderer) {
                    this.gameObject.renderer._boundingSphereDirty = true;
                }
            }
        };
        Transform.prototype._updateMatrix = function (isWorldSpace) {
            if (isWorldSpace) {
                var localMatrix = this.localMatrix;
                if (this._parent) {
                    this._worldMatrix.multiply(this._parent.worldMatrix, localMatrix);
                }
                else {
                    this._worldMatrix.copy(localMatrix);
                }
                this._worldMatrixDeterminant = this._worldMatrix.determinant();
                this._worldDirty &= ~16 /* Matrix */;
            }
            else {
                if ((this._localDirty & 2 /* Rotation */) || (this._localDirty & 4 /* Scale */)) {
                    this._localMatrix.compose(this.localPosition, this.localRotation, this.localScale);
                    this._localDirty &= ~7 /* PRS */;
                }
                else if (this._localDirty & 1 /* Position */) {
                    this._localMatrix.fromTranslate(this.localPosition, true);
                    this._localDirty &= ~1 /* Position */;
                }
                this._localDirty &= ~16 /* Matrix */;
            }
        };
        Transform.prototype._updateEuler = function (isWorldSpace, order) {
            if (isWorldSpace) {
                this.worldMatrix.toEuler(this._euler, order);
                this._eulerAngles.multiplyScalar(egret3d.RAD_DEG, this._euler);
                this._worldDirty &= ~8 /* Euler */;
            }
            else {
                this.localMatrix.toEuler(this._localEuler, order);
                this._localEulerAngles.multiplyScalar(egret3d.RAD_DEG, this._localEuler);
                this._localDirty &= ~8 /* Euler */;
            }
        };
        Transform.prototype._onParentChange = function (newParent, oldParent) {
            var prevActive = oldParent ? oldParent.gameObject.activeInHierarchy : this.gameObject.activeSelf;
            if ((newParent ? newParent.gameObject.activeInHierarchy : this.gameObject.activeSelf) !== prevActive) {
                this.gameObject._activeInHierarchyDirty(prevActive);
            }
            this._dirtify(false, 7 /* PRS */);
        };
        /**
         * @internal
         */
        Transform.prototype.getAllChildren = function (out) {
            if (out === void 0) { out = []; }
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (Array.isArray(out)) {
                    out.push(child);
                }
                else {
                    var childName = child.gameObject.name;
                    if (childName in out) {
                        var transformOrTransforms = out[childName];
                        if (Array.isArray(transformOrTransforms)) {
                            transformOrTransforms.push(child);
                        }
                        else {
                            out[childName] = [transformOrTransforms, child];
                        }
                    }
                    else {
                        out[childName] = child;
                    }
                }
                child.getAllChildren(out);
            }
            return out;
        };
        /**
         * 销毁所有子（孙）级变换组件。
         */
        Transform.prototype.destroyChildren = function () {
            var i = this._children.length;
            while (i--) {
                this._children[i].gameObject.destroy();
            }
        };
        /**
         * 该组件是否包含指定的子（孙）级变换组件。
         */
        Transform.prototype.contains = function (value) {
            if (value === this) {
                return false;
            }
            var ancestor = value;
            while (ancestor !== this && ancestor !== null) {
                ancestor = ancestor.parent;
            }
            return ancestor === this;
        };
        /**
         * 设置该组件实体的父级变换组件。
         * @param value 父级变换组件。
         * @param worldPositionStays 是否保留当前世界空间坐标系的位置。
         */
        Transform.prototype.setParent = function (value, worldPositionStays) {
            if (worldPositionStays === void 0) { worldPositionStays = false; }
            var prevParent = this._parent;
            if (prevParent === value) {
                return this;
            }
            if (value &&
                this.gameObject.scene !== value.gameObject.scene) {
                console.warn("Cannot change the parent to a different scene.");
                return this;
            }
            if (this === value || (value && this.contains(value))) {
                console.error("Set the parent error.");
                return this;
            }
            if (worldPositionStays) {
                _helpVector3.copy(this.position);
            }
            if (prevParent) {
                prevParent._removeFromChildren(this);
            }
            if (value) {
                value._children.push(this);
            }
            this._parent = value;
            this._onParentChange(value, prevParent);
            if (worldPositionStays) {
                this.position = _helpVector3;
            }
            return this;
        };
        /**
         *
         */
        Transform.prototype.getChildIndex = function (value) {
            if (value.parent !== this) {
                return -1;
            }
            return this._children.indexOf(value);
        };
        /**
         *
         */
        Transform.prototype.setChildIndex = function (value, index) {
            if (value.parent !== this) {
                return;
            }
            var prevIndex = this._children.indexOf(value);
            if (prevIndex === index) {
                return;
            }
            this._children.splice(prevIndex, 1);
            this._children.splice(index, 0, value);
        };
        /**
         *
         */
        Transform.prototype.getChildAt = function (index) {
            return 0 <= index && index < this._children.length ? this._children[index] : null;
        };
        /**
         * 通过指定的名称或路径获取该组件实体的子级（孙级）变换组件。
         * @param nameOrPath 名称或路径。
         */
        Transform.prototype.find = function (nameOrPath) {
            var names = nameOrPath.split("/");
            var ancestor = this;
            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                var name_1 = names_1[_i];
                if (!name_1) {
                    return ancestor;
                }
                var prevAncestor = ancestor;
                for (var _a = 0, _b = ancestor._children; _a < _b.length; _a++) {
                    var child = _b[_a];
                    if (child.gameObject.name === name_1) {
                        ancestor = child;
                        break;
                    }
                }
                if (prevAncestor === ancestor) {
                    return null;
                }
            }
            return ancestor;
        };
        /**
         * 该物体的本地位置。
         */
        Transform.prototype.getLocalPosition = function () {
            return this._localPosition;
        };
        Transform.prototype.setLocalPosition = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localPosition.x = p1.x;
                this._localPosition.y = p1.y;
                this._localPosition.z = p1.z;
            }
            else {
                this._localPosition.x = p1;
                this._localPosition.y = p2 || 0.0;
                this._localPosition.z = p3 || 0.0;
            }
            this._dirtify(true, 1 /* Position */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "localPosition", {
            /**
             * 该物体的本地位置。
             */
            get: function () {
                return this._localPosition;
            },
            set: function (value) {
                this._localPosition.x = value.x;
                this._localPosition.y = value.y;
                this._localPosition.z = value.z;
                this._dirtify(true, 1 /* Position */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的本地旋转。
         */
        Transform.prototype.getLocalRotation = function () {
            return this._localRotation;
        };
        Transform.prototype.setLocalRotation = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localRotation.x = p1.x;
                this._localRotation.y = p1.y;
                this._localRotation.z = p1.z;
                this._localRotation.w = p1.w;
            }
            else {
                this._localRotation.x = p1;
                this._localRotation.y = p2 || 0.0;
                this._localRotation.z = p3 || 0.0;
                this._localRotation.w = p4 !== undefined ? p4 : 1.0;
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "localRotation", {
            /**
             * 该物体的本地旋转。
             */
            get: function () {
                return this._localRotation;
            },
            set: function (value) {
                this._localRotation.x = value.x;
                this._localRotation.y = value.y;
                this._localRotation.z = value.z;
                this._localRotation.w = value.w;
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的本地欧拉弧度。
         */
        Transform.prototype.getLocalEuler = function (order) {
            if (this._localDirty & 8 /* Euler */) {
                this._updateEuler(false, order);
            }
            return this._localEuler;
        };
        Transform.prototype.setLocalEuler = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localEuler.x = p1.x;
                this._localEuler.y = p1.y;
                this._localEuler.z = p1.z;
                this._localEulerAngles.multiplyScalar(egret3d.RAD_DEG, this._localEuler);
                this._localRotation.fromEuler(this._localEuler, p2);
            }
            else {
                this._localEuler.x = p1;
                this._localEuler.y = p2;
                this._localEuler.z = p3;
                this._localEulerAngles.multiplyScalar(egret3d.RAD_DEG, this._localEuler);
                this._localRotation.fromEuler(this._localEuler, p4);
            }
            this._dirtify(true, 2 /* Rotation */);
            this._localDirty &= ~8 /* Euler */;
            return this;
        };
        Object.defineProperty(Transform.prototype, "localEuler", {
            /**
             * 该物体的本地欧拉弧度。
             */
            get: function () {
                if (this._localDirty & 8 /* Euler */) {
                    this._updateEuler(false);
                }
                return this._localEuler;
            },
            set: function (value) {
                this._localEuler.x = value.x;
                this._localEuler.y = value.y;
                this._localEuler.z = value.z;
                this._localEulerAngles.multiplyScalar(egret3d.RAD_DEG, this._localEuler);
                this._localRotation.fromEuler(this._localEuler);
                this._dirtify(true, 2 /* Rotation */);
                this._localDirty &= ~8 /* Euler */;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的本地欧拉角度。
         */
        Transform.prototype.getLocalEulerAngles = function (order) {
            if (this._localDirty & 8 /* Euler */) {
                this._updateEuler(false, order);
            }
            return this._localEulerAngles;
        };
        Transform.prototype.setLocalEulerAngles = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localEulerAngles.x = p1.x;
                this._localEulerAngles.y = p1.y;
                this._localEulerAngles.z = p1.z;
                this._localEuler.multiplyScalar(egret3d.DEG_RAD, this._localEulerAngles);
                this._localRotation.fromEuler(this._localEuler, p2);
            }
            else {
                this._localEulerAngles.x = p1;
                this._localEulerAngles.y = p2;
                this._localEulerAngles.z = p3;
                this._localEuler.multiplyScalar(egret3d.DEG_RAD, this._localEulerAngles);
                this._localRotation.fromEuler(this._localEuler, p4);
            }
            this._dirtify(true, 2 /* Rotation */);
            this._localDirty &= ~8 /* Euler */;
            return this;
        };
        Object.defineProperty(Transform.prototype, "localEulerAngles", {
            /**
             * 该物体的本地欧拉角度。
             */
            get: function () {
                if (this._localDirty & 8 /* Euler */) {
                    this._updateEuler(false);
                }
                return this._localEulerAngles;
            },
            set: function (value) {
                this._localEulerAngles.x = value.x;
                this._localEulerAngles.y = value.y;
                this._localEulerAngles.z = value.z;
                this._localEuler.multiplyScalar(egret3d.DEG_RAD, this._localEulerAngles);
                this._localRotation.fromEuler(this._localEuler);
                this._dirtify(true, 2 /* Rotation */);
                this._localDirty &= ~8 /* Euler */;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的本地缩放。
         */
        Transform.prototype.getLocalScale = function () {
            return this._localScale;
        };
        Transform.prototype.setLocalScale = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localScale.x = p1.x;
                this._localScale.y = p1.y;
                this._localScale.z = p1.z;
            }
            else {
                this._localScale.x = p1;
                this._localScale.y = p2 !== undefined ? p2 : p1;
                this._localScale.z = p3 !== undefined ? p3 : p1;
            }
            this._dirtify(true, 4 /* Scale */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "localScale", {
            /**
             * 该物体的本地缩放。
             */
            get: function () {
                return this._localScale;
            },
            set: function (value) {
                this._localScale.x = value.x;
                this._localScale.y = value.y;
                this._localScale.z = value.z;
                this._dirtify(true, 4 /* Scale */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的本地矩阵。
         */
        Transform.prototype.getLocalMatrix = function () {
            if (this._localDirty & 16 /* Matrix */) {
                this._updateMatrix(false);
            }
            return this._localMatrix;
        };
        Object.defineProperty(Transform.prototype, "localMatrix", {
            /**
             * 该物体的本地矩阵。
             */
            get: function () {
                if (this._localDirty & 16 /* Matrix */) {
                    this._updateMatrix(false);
                }
                return this._localMatrix;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的世界位置。
         */
        Transform.prototype.getPosition = function () {
            if (this._worldDirty & 1 /* Position */) {
                this.worldMatrix.decompose(this._position, null, null);
                this._worldDirty &= ~1 /* Position */;
            }
            return this._position;
        };
        Transform.prototype.setPosition = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localPosition.x = p1.x;
                this._localPosition.y = p1.y;
                this._localPosition.z = p1.z;
            }
            else {
                this._localPosition.x = p1;
                this._localPosition.y = p2 || 0.0;
                this._localPosition.z = p3 || 0.0;
            }
            if (this._parent) {
                this._localPosition.applyMatrix(_helpMatrix.inverse(this._parent.worldMatrix));
            }
            this._dirtify(true, 1 /* Position */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "position", {
            /**
             * 该物体的世界位置。
             */
            get: function () {
                if (this._worldDirty & 1 /* Position */) {
                    this.worldMatrix.decompose(this._position, null, null);
                    this._worldDirty &= ~1 /* Position */;
                }
                return this._position;
            },
            set: function (value) {
                this._localPosition.x = value.x;
                this._localPosition.y = value.y;
                this._localPosition.z = value.z;
                if (this._parent) {
                    this._localPosition.applyMatrix(_helpMatrix.inverse(this._parent.worldMatrix));
                }
                this._dirtify(true, 1 /* Position */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的世界旋转。
         */
        Transform.prototype.getRotation = function () {
            if (this._worldDirty & 2 /* Rotation */) {
                this.worldMatrix.decompose(null, this._rotation, null);
                this._worldDirty &= ~2 /* Rotation */;
            }
            return this._rotation;
        };
        Transform.prototype.setRotation = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localRotation.x = p1.x;
                this._localRotation.y = p1.y;
                this._localRotation.z = p1.z;
                this._localRotation.w = p1.w;
            }
            else {
                this._localRotation.x = p1;
                this._localRotation.y = p2 || 0.0;
                this._localRotation.z = p3 || 0.0;
                this._localRotation.w = p4 !== undefined ? p4 : 1.0;
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "rotation", {
            /**
             * 该物体的世界旋转。
             */
            get: function () {
                if (this._worldDirty & 2 /* Rotation */) {
                    this.worldMatrix.decompose(null, this._rotation, null);
                    this._worldDirty &= ~2 /* Rotation */;
                }
                return this._rotation;
            },
            set: function (value) {
                this._localRotation.x = value.x;
                this._localRotation.y = value.y;
                this._localRotation.z = value.z;
                this._localRotation.w = value.w;
                if (this._parent) {
                    this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
                }
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的世界欧拉弧度。
         */
        Transform.prototype.getEuler = function (order) {
            if (this._worldDirty & 8 /* Euler */) {
                this._updateEuler(true, order);
            }
            return this._euler;
        };
        Transform.prototype.setEuler = function (q1, q2, q3, q4) {
            if (q1.hasOwnProperty("x")) {
                this._localRotation.fromEuler(q1, q2);
            }
            else {
                _helpVector3.set(q1, q2, q3);
                this._localRotation.fromEuler(_helpVector3, q4);
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "euler", {
            /**
             * 该物体的世界欧拉弧度。
             */
            get: function () {
                if (this._worldDirty & 8 /* Euler */) {
                    this._updateEuler(true);
                }
                return this._euler;
            },
            set: function (value) {
                this._localRotation.fromEuler(value);
                if (this._parent) {
                    this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
                }
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的世界欧拉角度。
         */
        Transform.prototype.getEulerAngles = function (order) {
            if (this._worldDirty & 8 /* Euler */) {
                this._updateEuler(true, order);
            }
            return this._eulerAngles;
        };
        Transform.prototype.setEulerAngles = function (q1, q2, q3, q4) {
            if (q1.hasOwnProperty("x")) {
                _helpVector3.multiplyScalar(egret3d.DEG_RAD, q1);
                this._localRotation.fromEuler(_helpVector3, q2);
            }
            else {
                _helpVector3.set(q1 * egret3d.DEG_RAD, q2 * egret3d.DEG_RAD, q3 * egret3d.DEG_RAD);
                this._localRotation.fromEuler(_helpVector3, q4);
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "eulerAngles", {
            /**
             * 该物体的世界欧拉角度。
             */
            get: function () {
                if (this._worldDirty & 8 /* Euler */) {
                    this._updateEuler(true);
                }
                return this._eulerAngles;
            },
            set: function (value) {
                _helpVector3.multiplyScalar(egret3d.DEG_RAD, value);
                this._localRotation.fromEuler(_helpVector3);
                if (this._parent) {
                    this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
                }
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的世界缩放。
         */
        Transform.prototype.getScale = function () {
            if (this._worldDirty & 4 /* Scale */) {
                this.worldMatrix.decompose(null, null, this._scale);
                this._worldDirty &= ~4 /* Scale */;
            }
            return this._scale;
        };
        Transform.prototype.setScale = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localScale.x = p1.x;
                this._localScale.y = p1.y;
                this._localScale.z = p1.z;
            }
            else {
                this._localScale.x = p1;
                this._localScale.y = p2 !== undefined ? p2 : p1;
                this._localScale.z = p3 !== undefined ? p3 : p1;
            }
            if (this._parent) {
                this._localScale.applyDirection(_helpMatrix.inverse(this._parent.worldMatrix));
            }
            this._dirtify(true, 4 /* Scale */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "scale", {
            /**
             * 该物体的世界缩放。
             */
            get: function () {
                if (this._worldDirty & 4 /* Scale */) {
                    this.worldMatrix.decompose(null, null, this._scale);
                    this._worldDirty &= ~4 /* Scale */;
                }
                return this._scale;
            },
            set: function (value) {
                this._localScale.x = value.x;
                this._localScale.y = value.y;
                this._localScale.z = value.z;
                if (this._parent) {
                    this._localScale.applyDirection(_helpMatrix.inverse(this._parent.worldMatrix));
                }
                this._dirtify(true, 4 /* Scale */);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该物体的世界矩阵。
         */
        Transform.prototype.getWorldMatrix = function () {
            if (this._worldDirty & 16 /* Matrix */) {
                this._updateMatrix(true);
            }
            return this._worldMatrix;
        };
        Object.defineProperty(Transform.prototype, "worldMatrix", {
            /**
             * 该物体的世界矩阵。
             */
            get: function () {
                if (this._worldDirty & 16 /* Matrix */) {
                    this._updateMatrix(true);
                }
                return this._worldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.translate = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                if (p2) {
                    this.position = this._localPosition.add(p1, this.position);
                }
                else {
                    this.localPosition = this._localPosition.add(p1);
                }
            }
            else {
                _helpVector3.set(p1, p2, p3);
                if (p4) {
                    this.position = this._localPosition.add(_helpVector3, this.position);
                }
                else {
                    this.localPosition = this._localPosition.add(_helpVector3);
                }
            }
            return this;
        };
        Transform.prototype.rotate = function (p1, p2, p3, p4, p5) {
            if (p1.hasOwnProperty("x")) {
                if (p2) {
                    this.euler = this._localEuler.add(p1, this.euler);
                }
                else {
                    this.localEuler; // Update euler.
                    this.localEuler = this._localEuler.add(p1);
                }
            }
            else {
                _helpVector3.set(p1, p2, p3);
                if (p4) {
                    this.euler = this._localEuler.add(_helpVector3, this.euler);
                }
                else {
                    this.localEuler; // Update euler.
                    this.localEuler = this._localEuler.add(_helpVector3);
                }
            }
            return this;
        };
        /**
         * 将该物体绕指定轴旋转指定弧度。
         * @param axis 指定轴。
         * @param radian 指定弧度。
         * @param isWorldSpace 是否是世界坐标系。
         */
        Transform.prototype.rotateOnAxis = function (axis, radian, isWorldSpace) {
            _helpRotation.fromAxis(axis, radian);
            if (isWorldSpace) {
                this.localRotation = this._localRotation.premultiply(_helpRotation).normalize();
            }
            else {
                this.localRotation = this._localRotation.multiply(_helpRotation).normalize();
            }
            return this;
        };
        /**
         * 将该物体绕世界指定点和世界指定轴旋转指定弧度。
         * @param worldPosition 世界指定点。
         * @param worldAxis 世界指定轴。
         * @param radian 指定弧度。
         */
        Transform.prototype.rotateAround = function (worldPosition, worldAxis, radian) {
            this.rotateOnAxis(worldAxis, radian, true);
            this.position = this._localPosition.applyMatrix(_helpMatrix.fromRotation(_helpRotation.fromAxis(worldAxis, radian)).fromTranslate(worldPosition, true), this.position);
            return this;
        };
        Transform.prototype.rotateAngle = function (p1, p2, p3, p4, p5) {
            if (p1.hasOwnProperty("x")) {
                if (p2) {
                    this.eulerAngles = this._localEulerAngles.add(p1, this.eulerAngles);
                }
                else {
                    this.localEulerAngles; // Update euler.
                    this.localEulerAngles = this._localEulerAngles.add(p1);
                }
            }
            else {
                _helpVector3.set(p1, p2, p3);
                if (p4) {
                    this.eulerAngles = this._localEulerAngles.add(_helpVector3, this.eulerAngles);
                }
                else {
                    this.localEulerAngles; // Update euler.
                    this.localEulerAngles = this._localEulerAngles.add(_helpVector3);
                }
            }
            return this;
        };
        /**
         * 将该物体绕指定轴旋转指定角度。
         * @param axis 指定轴。
         * @param angle 指定角度。
         * @param isWorldSpace 是否是世界坐标系。
         */
        Transform.prototype.rotateAngleOnAxis = function (axis, angle, isWorldSpace) {
            return this.rotateOnAxis(axis, angle * egret3d.DEG_RAD, isWorldSpace);
        };
        /**
         * 将该物体绕世界指定点和世界指定轴旋转指定角度。
         * @param worldPosition 世界指定点。
         * @param worldAxis 世界指定轴。
         * @param angle 指定角度。
         */
        Transform.prototype.rotateAngleAround = function (worldPosition, worldAxis, angle) {
            return this.rotateAround(worldPosition, worldAxis, angle * egret3d.DEG_RAD);
        };
        /**
         * 获取该物体在世界空间坐标系下描述的 X 轴正方向。
         */
        Transform.prototype.getRight = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.worldMatrix, egret3d.Vector3.RIGHT).normalize();
        };
        /**
         * 获取该物体在世界空间坐标系下描述的 Y 轴正方向。
         */
        Transform.prototype.getUp = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.worldMatrix, egret3d.Vector3.UP).normalize();
        };
        /**
         * 获取该物体在世界空间坐标系下描述的 Z 轴正方向。
         */
        Transform.prototype.getForward = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.worldMatrix, egret3d.Vector3.FORWARD).normalize();
        };
        /**
         * 通过旋转使得该物体的 Z 轴正方向指向目标。
         * @param target 目标。
         * @param up 旋转后，该物体在世界空间坐标系下描述的 Y 轴正方向。
         */
        Transform.prototype.lookAt = function (target, up) {
            if (up === void 0) { up = egret3d.Vector3.UP; }
            this.rotation = this._localRotation.fromMatrix(_helpMatrix.lookAt(this.position, target instanceof Transform ? target.position : target, up));
            return this;
        };
        Object.defineProperty(Transform.prototype, "childCount", {
            /**
             * 该组件实体的全部子级变换组件总数。
             */
            get: function () {
                return this._children.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "children", {
            /**
             * 该组件实体的全部子级变换组件。
             */
            get: function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "parent", {
            /**
             * 该组件实体的父级变换组件。
             */
            get: function () {
                return this._parent;
            },
            set: function (value) {
                this.setParent(value, false);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField("localPosition")
        ], Transform.prototype, "_localPosition", void 0);
        __decorate([
            paper.serializedField("localRotation")
        ], Transform.prototype, "_localRotation", void 0);
        __decorate([
            paper.serializedField("localScale")
        ], Transform.prototype, "_localScale", void 0);
        __decorate([
            paper.editor.property(6 /* VECTOR3 */)
        ], Transform.prototype, "localPosition", null);
        __decorate([
            paper.editor.property(6 /* VECTOR3 */, { step: 1.0 })
        ], Transform.prototype, "localEulerAngles", null);
        __decorate([
            paper.editor.property(6 /* VECTOR3 */)
        ], Transform.prototype, "localScale", null);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Transform.prototype, "children", null);
        return Transform;
    }(paper.BaseComponent));
    egret3d.Transform = Transform;
    __reflect(Transform.prototype, "egret3d.Transform");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    var _attributesB = [
        "POSITION" /* POSITION */,
        "NORMAL" /* NORMAL */,
        "TEXCOORD_0" /* TEXCOORD_0 */,
    ];
    /**
     * 提供默认的几何网格，以及创建几何网格的方式。
     */
    var DefaultMeshes = (function (_super) {
        __extends(DefaultMeshes, _super);
        function DefaultMeshes() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultMeshes.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            // TODO 颜色切线，球体，更多类型。
            {
                var mesh = DefaultMeshes.createPlane();
                mesh._isBuiltin = true;
                mesh.name = "builtin/quad.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.QUAD = mesh;
            }
            {
                var mesh = DefaultMeshes.createPlane(1.0, 1.0, -0.5, 0.0);
                mesh._isBuiltin = true;
                mesh.name = "builtin/quad_particle.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.QUAD_PARTICLE = mesh;
            }
            {
                var mesh = DefaultMeshes.createPlane(10.0, 10.0);
                mesh._isBuiltin = true;
                mesh.name = "builtin/plane.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.PLANE = mesh;
            }
            {
                var mesh = DefaultMeshes.createCube();
                mesh._isBuiltin = true;
                mesh.name = "builtin/cube.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CUBE = mesh;
            }
            {
                var mesh = new egret3d.Mesh(16, 18);
                mesh._isBuiltin = true;
                mesh.name = "builtin/pyramid.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.PYRAMID = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    -0.5, -0.5, -0.5,
                    0.0, 0.5, 0.0,
                    0.5, -0.5, -0.5,
                    0.5, -0.5, -0.5,
                    0.0, 0.5, 0.0,
                    0.5, -0.5, 0.5,
                    0.5, -0.5, 0.5,
                    0.0, 0.5, 0.0,
                    -0.5, -0.5, 0.5,
                    -0.5, -0.5, 0.5,
                    0.0, 0.5, 0.0,
                    -0.5, -0.5, -0.5,
                    -0.5, -0.5, -0.5,
                    0.5, -0.5, -0.5,
                    0.5, -0.5, 0.5,
                    -0.5, -0.5, 0.5,
                ]);
                mesh.setAttributes("NORMAL" /* NORMAL */, [
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, -1, 0,
                    0, -1, 0,
                    0, -1, 0,
                    0, -1, 0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                ]);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, [
                    0, 0,
                    0.5, 0.5,
                    0, 1,
                    0, 1,
                    0.5, 0.5,
                    1, 1,
                    1, 1,
                    0.5, 0.5,
                    1, 0,
                    1, 0,
                    0.5, 0.5,
                    0, 0,
                    0, 0,
                    1, 0,
                    1, 1,
                    0, 1,
                ]);
                mesh.setIndices([
                    0, 2, 1, 3, 5, 4,
                    6, 8, 7, 9, 11, 10,
                    12, 14, 13, 15, 14, 12
                ]);
            }
            {
                var mesh = DefaultMeshes.createCylinder(0.0, 0.5, 1.0, 0.0, 0.0, 0.0, 16, 1);
                mesh._isBuiltin = true;
                mesh.name = "builtin/cone.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CONE = mesh;
            }
            {
                var mesh = DefaultMeshes.createCylinder();
                mesh._isBuiltin = true;
                mesh.name = "builtin/cylinder.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CYLINDER = mesh;
            }
            {
                var mesh = DefaultMeshes.createTorus();
                mesh._isBuiltin = true;
                mesh.name = "builtin/torus.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.TORUS = mesh;
            }
            {
                var mesh = DefaultMeshes.createSphere();
                mesh._isBuiltin = true;
                mesh.name = "builtin/sphere.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.SPHERE = mesh;
            }
            {
                var mesh = new egret3d.Mesh(4, 2, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh._isBuiltin = true;
                mesh.name = "builtin/line_x.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes.LINE_X = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,
                    0.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
                mesh.setIndices([0, 1], 0);
            }
            {
                var mesh = new egret3d.Mesh(4, 2, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh._isBuiltin = true;
                mesh.name = "builtin/line_y.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes.LINE_Y = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                    0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
                mesh.setIndices([0, 1], 0);
            }
            {
                var mesh = new egret3d.Mesh(4, 2, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh._isBuiltin = true;
                mesh.name = "builtin/line_z.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes.LINE_Z = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.0, 0.0,
                    0.0, 0.0, 1.0,
                    0.0, 0.0, 0.0,
                    0.0, 0.0, 1.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
                mesh.setIndices([0, 1], 0);
            }
            {
                var mesh = DefaultMeshes.createCircle();
                mesh._isBuiltin = true;
                mesh.name = "builtin/circle_line.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CIRCLE_LINE = mesh;
            }
            {
                // const meshAttributesType: { [key: string]: gltf.AccessorType } = {};
                // meshAttributesType[gltf.AttributeSemanticType._INSTANCE_DISTANCE] = gltf.AccessorType.SCALAR;
                var mesh = new egret3d.Mesh(8, 24, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh._isBuiltin = true;
                mesh.name = "builtin/cube_line.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes.CUBE_LINE = mesh;
                //
                mesh.setAttributes("POSITION" /* POSITION */, [
                    // Z-
                    -0.5, 0.5, -0.5,
                    0.5, 0.5, -0.5,
                    0.5, -0.5, -0.5,
                    -0.5, -0.5, -0.5,
                    // Z+
                    0.5, 0.5, 0.5,
                    0.5, -0.5, 0.5,
                    -0.5, -0.5, 0.5,
                    -0.5, 0.5, 0.5,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                ]);
                mesh.setIndices([
                    0, 1, 1, 2, 2, 3, 3, 0,
                    4, 5, 5, 6, 6, 7, 7, 4,
                    0, 7, 1, 4, 2, 5, 3, 6,
                ]);
                //
                // const lineDistances = mesh.getAttributes(gltf.AttributeSemanticType._INSTANCE_DISTANCE);
                // this.computeLineDistances(mesh.getAttributes(gltf.AttributeSemanticType.POSITION), lineDistances);
                // mesh.setAttributes(gltf.AttributeSemanticType._INSTANCE_DISTANCE, lineDistances);
            }
        };
        /**
         * 创建带网格的实体。
         */
        DefaultMeshes.createObject = function (mesh, name, tag, scene) {
            var gameObject = paper.GameObject.create(name, tag, scene);
            var meshFilter = gameObject.addComponent(egret3d.MeshFilter);
            var renderer = gameObject.addComponent(egret3d.MeshRenderer);
            meshFilter.mesh = mesh;
            switch (mesh) {
                case this.QUAD:
                case this.QUAD_PARTICLE:
                case this.PLANE:
                    renderer.material = egret3d.DefaultMaterials.MESH_BASIC_DOUBLESIDE;
                    break;
                case this.LINE_X:
                case this.LINE_Y:
                case this.LINE_Z:
                case this.CIRCLE_LINE:
                case this.CUBE_LINE:
                    renderer.material = egret3d.DefaultMaterials.LINEDASHED_COLOR;
                    break;
            }
            return gameObject;
        };
        /**
         * 创建平面网格。
         */
        DefaultMeshes.createPlane = function (width, height, centerOffsetX, centerOffsetY, widthSegments, heightSegments) {
            if (width === void 0) { width = 1.0; }
            if (height === void 0) { height = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (widthSegments === void 0) { widthSegments = 1; }
            if (heightSegments === void 0) { heightSegments = 1; }
            var widthHalf = width / 2;
            var heightHalf = height / 2;
            var gridX1 = widthSegments + 1;
            var gridY1 = heightSegments + 1;
            var segmentWidth = width / widthSegments;
            var segmentHeight = height / heightSegments;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // generate vertices, normals and uvs
            for (var iy = 0; iy < gridY1; iy++) {
                var y = iy * segmentHeight - heightHalf;
                for (var ix = 0; ix < gridX1; ix++) {
                    var x = ix * segmentWidth - widthHalf;
                    vertices.push(centerOffsetX + x, centerOffsetY - y, 0.0);
                    normals.push(0.0, 0.0, 1.0);
                    uvs.push(ix / widthSegments, iy / heightSegments);
                }
            }
            // indices
            for (var iy = 0; iy < heightSegments; iy++) {
                for (var ix = 0; ix < widthSegments; ix++) {
                    var a = ix + gridX1 * iy;
                    var b = ix + gridX1 * (iy + 1);
                    var c = (ix + 1) + gridX1 * (iy + 1);
                    var d = (ix + 1) + gridX1 * iy;
                    // faces
                    indices.push(a, b, d, b, c, d);
                }
            }
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        /**
         * 创建立方体网格。
         */
        DefaultMeshes.createCube = function (width, height, depth, centerOffsetX, centerOffsetY, centerOffsetZ, widthSegments, heightSegments, depthSegments, differentFace) {
            if (width === void 0) { width = 1.0; }
            if (height === void 0) { height = 1.0; }
            if (depth === void 0) { depth = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (widthSegments === void 0) { widthSegments = 1; }
            if (heightSegments === void 0) { heightSegments = 1; }
            if (depthSegments === void 0) { depthSegments = 1; }
            if (differentFace === void 0) { differentFace = false; }
            // helper variables
            var meshVertexCount = 0;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // build each side of the box geometry
            buildPlane("z", "y", "x", -1, -1, depth, height, -width, depthSegments, heightSegments); // px
            buildPlane("z", "y", "x", 1, -1, depth, height, width, depthSegments, heightSegments); // nx
            buildPlane("x", "z", "y", 1, 1, width, depth, -height, widthSegments, depthSegments); // py
            buildPlane("x", "z", "y", 1, -1, width, depth, height, widthSegments, depthSegments); // ny
            buildPlane("x", "y", "z", 1, -1, width, height, -depth, widthSegments, heightSegments); // pz
            buildPlane("x", "y", "z", -1, -1, width, height, depth, widthSegments, heightSegments); // nz
            // build geometry
            if (differentFace) {
                var faceIndexCount = indices.length / 6;
                var mesh = egret3d.Mesh.create(vertices.length / 3, 0);
                mesh.setAttributes("POSITION" /* POSITION */, vertices);
                mesh.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                for (var i = 0; i < 6; ++i) {
                    mesh.addSubMesh(faceIndexCount, i);
                    mesh.setIndices(indices, i, faceIndexCount * i);
                }
                return mesh;
            }
            else {
                var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length);
                mesh.setAttributes("POSITION" /* POSITION */, vertices);
                mesh.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                mesh.setIndices(indices);
                return mesh;
            }
            function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY) {
                var segmentWidth = width / gridX;
                var segmentHeight = height / gridY;
                var widthHalf = width / 2;
                var heightHalf = height / 2;
                var depthHalf = depth / 2;
                var gridX1 = gridX + 1;
                var gridY1 = gridY + 1;
                var vertexCount = 0;
                // generate vertices, normals and uvs
                for (var iy = 0; iy < gridY1; iy++) {
                    var y = iy * segmentHeight - heightHalf;
                    for (var ix = 0; ix < gridX1; ix++) {
                        var x = ix * segmentWidth - widthHalf;
                        // set values to correct vector component
                        _helpVector3[u] = x * udir;
                        _helpVector3[v] = y * vdir;
                        _helpVector3[w] = depthHalf;
                        // now apply vector to vertex buffer
                        vertices.push(_helpVector3.x + centerOffsetX, _helpVector3.y + centerOffsetY, _helpVector3.z + centerOffsetZ);
                        // set values to correct vector component
                        _helpVector3[u] = 0.0;
                        _helpVector3[v] = 0.0;
                        _helpVector3[w] = depth > 0.0 ? 1.0 : -1.0;
                        // now apply vector to normal buffer
                        normals.push(_helpVector3.x, _helpVector3.y, _helpVector3.z);
                        // uvs
                        uvs.push(ix / gridX);
                        uvs.push(iy / gridY);
                        // counters
                        vertexCount += 1;
                    }
                }
                // indices
                // 1. you need three indices to draw a single face
                // 2. a single segment consists of two faces
                // 3. so we need to generate six (2*3) indices per segment
                for (var iy = 0; iy < gridY; iy++) {
                    for (var ix = 0; ix < gridX; ix++) {
                        var a = meshVertexCount + ix + gridX1 * iy;
                        var b = meshVertexCount + ix + gridX1 * (iy + 1);
                        var c = meshVertexCount + (ix + 1) + gridX1 * (iy + 1);
                        var d = meshVertexCount + (ix + 1) + gridX1 * iy;
                        // faces
                        indices.push(a, b, d, b, c, d);
                    }
                }
                // update total number of vertices
                meshVertexCount += vertexCount;
            }
        };
        /**
         * 创建圆柱体网格。
         */
        DefaultMeshes.createCylinder = function (radiusTop, radiusBottom, height, centerOffsetX, centerOffsetY, centerOffsetZ, radialSegments, heightSegments, openEnded, thetaStart, thetaLength, differentFace) {
            if (radiusTop === void 0) { radiusTop = 0.5; }
            if (radiusBottom === void 0) { radiusBottom = 0.5; }
            if (height === void 0) { height = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (radialSegments === void 0) { radialSegments = 16; }
            if (heightSegments === void 0) { heightSegments = 1; }
            if (openEnded === void 0) { openEnded = false; }
            if (thetaStart === void 0) { thetaStart = 0.0; }
            if (thetaLength === void 0) { thetaLength = Math.PI * 2.0; }
            if (differentFace === void 0) { differentFace = false; }
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // helper variables
            var index = 0;
            var groupStart = 0;
            var halfHeight = height / 2;
            var indexArray = [];
            var subIndices = [];
            // generate geometry
            generateTorso();
            if (openEnded === false) {
                if (radiusTop > 0.0)
                    generateCap(true);
                if (radiusBottom > 0.0)
                    generateCap(false);
            }
            // build geometry
            if (differentFace) {
                var mesh = egret3d.Mesh.create(vertices.length / 3, 0);
                mesh.setAttributes("POSITION" /* POSITION */, vertices);
                mesh.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                for (var i = 0; i < subIndices.length; i += 3) {
                    mesh.addSubMesh(subIndices[1], subIndices[2]);
                    mesh.setIndices(indices, i, subIndices[0]);
                }
                return mesh;
            }
            else {
                var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length);
                mesh.setAttributes("POSITION" /* POSITION */, vertices);
                mesh.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                mesh.setIndices(indices);
                return mesh;
            }
            function generateTorso() {
                var groupCount = 0;
                // this will be used to calculate the normal
                var slope = (radiusBottom - radiusTop) / height;
                // generate vertices, normals and uvs
                for (var iY = 0; iY <= heightSegments; iY++) {
                    var indexRow = [];
                    var v = iY / heightSegments;
                    // calculate the radius of the current row
                    var radius = v * (radiusBottom - radiusTop) + radiusTop;
                    for (var iX = 0; iX <= radialSegments; iX++) {
                        var u = iX / radialSegments;
                        var theta = u * thetaLength + thetaStart;
                        var sinTheta = Math.sin(theta);
                        var cosTheta = Math.cos(theta);
                        // vertex
                        _helpVector3.x = radius * sinTheta;
                        _helpVector3.y = -v * height + halfHeight;
                        _helpVector3.z = -radius * cosTheta;
                        vertices.push(_helpVector3.x + centerOffsetX, _helpVector3.y + centerOffsetY, _helpVector3.z + centerOffsetZ);
                        // normal
                        _helpVector3.set(sinTheta, slope, cosTheta).normalize();
                        normals.push(_helpVector3.x, _helpVector3.y, _helpVector3.z);
                        // uv
                        uvs.push(u, v);
                        // save index of vertex in respective row
                        indexRow.push(index++);
                    }
                    // now save vertices of the row in our index array
                    indexArray.push(indexRow);
                }
                // generate indices
                for (var iX = 0; iX < radialSegments; iX++) {
                    for (var iY = 0; iY < heightSegments; iY++) {
                        // we use the index array to access the correct indices
                        var a = indexArray[iY][iX];
                        var b = indexArray[iY + 1][iX];
                        var c = indexArray[iY + 1][iX + 1];
                        var d = indexArray[iY][iX + 1];
                        // faces
                        indices.push(a, b, d, b, c, d);
                        // update group counter
                        groupCount += 6;
                    }
                }
                // add a group to the geometry. this will ensure multi material support
                subIndices.push(groupStart, groupCount, 0);
                // calculate new start value for groups
                groupStart += groupCount;
            }
            function generateCap(top) {
                var centerIndexStart = 0, centerIndexEnd = 0;
                var groupCount = 0;
                var radius = top ? radiusTop : radiusBottom;
                var sign = top ? 1 : -1;
                // save the index of the first center vertex
                centerIndexStart = index;
                // first we generate the center vertex data of the cap.
                // because the geometry needs one set of uvs per face,
                // we must generate a center vertex per face/segment
                for (var iX = 1; iX <= radialSegments; iX++) {
                    // vertex
                    vertices.push(0.0, halfHeight * sign, 0.0);
                    // normal
                    normals.push(0.0, sign, 0.0);
                    // uv
                    uvs.push(0.5, 0.5);
                    // increase index
                    index++;
                }
                // save the index of the last center vertex
                centerIndexEnd = index;
                // now we generate the surrounding vertices, normals and uvs
                for (var iX = 0; iX <= radialSegments; iX++) {
                    var u = iX / radialSegments;
                    var theta = u * thetaLength + thetaStart;
                    var cosTheta = Math.cos(theta);
                    var sinTheta = Math.sin(theta);
                    // vertex
                    _helpVector3.x = radius * sinTheta;
                    _helpVector3.y = halfHeight * sign;
                    _helpVector3.z = -radius * cosTheta;
                    vertices.push(_helpVector3.x + centerOffsetX, _helpVector3.y + centerOffsetY, _helpVector3.z + centerOffsetZ);
                    // normal
                    normals.push(0.0, sign, 0.0);
                    // uv
                    uvs.push((sinTheta * 0.5 * sign) + 0.5, (cosTheta * 0.5) + 0.5);
                    // increase index
                    index++;
                }
                // generate indices
                for (var iX = 0; iX < radialSegments; iX++) {
                    var c = centerIndexStart + iX;
                    var i = centerIndexEnd + iX;
                    if (top === true) {
                        // face top
                        indices.push(i, i + 1, c);
                    }
                    else {
                        // face bottom
                        indices.push(i + 1, i, c);
                    }
                    groupCount += 3;
                }
                // add a group to the geometry. this will ensure multi material support
                subIndices.push(groupStart, groupCount, top === true ? 1 : 2);
                // calculate new start value for groups
                groupStart += groupCount;
            }
        };
        /**
         * 创建圆形网格。
         */
        DefaultMeshes.createCircle = function (radius, arc, axis) {
            if (radius === void 0) { radius = 0.5; }
            if (arc === void 0) { arc = 1.0; }
            if (axis === void 0) { axis = 1; }
            var vertices = [];
            for (var i = 0; i <= 64 * arc; ++i) {
                switch (axis) {
                    case 1:
                        vertices.push(0.0, Math.cos(i / 32 * Math.PI) * radius, -Math.sin(i / 32 * Math.PI) * radius);
                        break;
                    case 2:
                        vertices.push(Math.cos(i / 32 * Math.PI) * radius, 0.0, -Math.sin(i / 32 * Math.PI) * radius);
                        break;
                    case 3:
                        vertices.push(Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius, -0.0);
                        break;
                }
            }
            var mesh = egret3d.Mesh.create(vertices.length / 3, 0, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.glTFMesh.primitives[0].mode = 3 /* LineStrip */;
            return mesh;
        };
        /**
         * 创建圆环网格。
         */
        DefaultMeshes.createTorus = function (radius, tube, radialSegments, tubularSegments, arc, axis) {
            if (radius === void 0) { radius = 0.5; }
            if (tube === void 0) { tube = 0.1; }
            if (radialSegments === void 0) { radialSegments = 4; }
            if (tubularSegments === void 0) { tubularSegments = 12; }
            if (arc === void 0) { arc = 1.0; }
            if (axis === void 0) { axis = 1; }
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // helper variables
            var center = egret3d.Vector3.create();
            var vertex = egret3d.Vector3.create();
            var normal = egret3d.Vector3.create();
            var j, i;
            // generate vertices, normals and uvs
            for (j = 0; j <= radialSegments; j++) {
                for (i = 0; i <= tubularSegments; i++) {
                    var u = i / tubularSegments * Math.PI * 2 * arc;
                    var v = j / radialSegments * Math.PI * 2;
                    // vertex
                    switch (axis) {
                        case 1:
                            vertex.x = tube * Math.sin(v);
                            vertex.y = (radius + tube * Math.cos(v)) * Math.cos(u);
                            vertex.z = (radius + tube * Math.cos(v)) * Math.sin(u);
                            break;
                        case 2:
                            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                            vertex.y = tube * Math.sin(v);
                            vertex.z = (radius + tube * Math.cos(v)) * Math.sin(u);
                            break;
                        default:
                            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                            vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                            vertex.z = tube * Math.sin(v);
                    }
                    vertices.push(vertex.x, vertex.y, -vertex.z);
                    // normal
                    center.x = radius * Math.cos(u);
                    center.y = radius * Math.sin(u);
                    normal.subtract(vertex, center).normalize();
                    normals.push(normal.x, normal.y, -normal.z);
                    // uv
                    uvs.push(i / tubularSegments);
                    uvs.push(j / radialSegments);
                }
            }
            // generate indices
            for (j = 1; j <= radialSegments; j++) {
                for (i = 1; i <= tubularSegments; i++) {
                    // indices
                    var a = (tubularSegments + 1) * j + i - 1;
                    var b = (tubularSegments + 1) * (j - 1) + i - 1;
                    var c = (tubularSegments + 1) * (j - 1) + i;
                    var d = (tubularSegments + 1) * j + i;
                    // faces
                    indices.push(a, b, d, b, c, d);
                }
            }
            center.release();
            vertex.release();
            normal.release();
            // build geometry
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length, ["POSITION" /* POSITION */, "NORMAL" /* NORMAL */, "TEXCOORD_0" /* TEXCOORD_0 */]);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        /**
         * 创建球体网格。
         * TODO
         */
        DefaultMeshes.createSphere = function (radius, widthSegments, heightSegments) {
            if (radius === void 0) { radius = 0.5; }
            if (widthSegments === void 0) { widthSegments = 24; }
            if (heightSegments === void 0) { heightSegments = 12; }
            widthSegments = Math.max(3, Math.floor(widthSegments));
            heightSegments = Math.max(2, Math.floor(heightSegments));
            var mesh = new egret3d.Mesh((widthSegments + 1) * (heightSegments + 1), widthSegments * heightSegments * 6 - 6, _attributesB);
            //
            var index = 0;
            var vertex = new egret3d.Vector3();
            var normal = new egret3d.Vector3();
            var grid = new Array();
            var vertices = [];
            var normals = [];
            var uvs = [];
            for (var iy = 0; iy <= heightSegments; iy++) {
                var verticesRow = new Array();
                var v = iy / heightSegments;
                for (var ix = 0; ix <= widthSegments; ix++) {
                    var u = ix / widthSegments;
                    // Vertex.
                    vertex.x = -radius * Math.cos(u * Math.PI * 2) * Math.sin(v * Math.PI);
                    vertex.y = radius * Math.cos(v * Math.PI);
                    vertex.z = radius * Math.sin(u * Math.PI * 2) * Math.sin(v * Math.PI);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // Normal.
                    normal.x = vertex.x;
                    normal.y = vertex.y;
                    normal.z = vertex.z;
                    var num = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
                    if (num > Number.MIN_VALUE) {
                        normals.push(normal.x / num, normal.y / num, normal.z / num);
                    }
                    else {
                        normals.push(0.0, 0.0, 0.0);
                    }
                    uvs.push(0, 1.0 - u, v);
                    verticesRow.push(index++);
                }
                grid.push(verticesRow);
            }
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            // Indices.
            var tris = new Array();
            for (var iy = 0; iy < heightSegments; iy++) {
                for (var ix = 0; ix < widthSegments; ix++) {
                    var a = grid[iy][ix + 1];
                    var b = grid[iy][ix];
                    var c = grid[iy + 1][ix];
                    var d = grid[iy + 1][ix + 1];
                    if (iy !== 0) {
                        tris.push(a, d, b);
                    }
                    if (iy !== heightSegments - 1) {
                        tris.push(b, d, c);
                    }
                }
            }
            var indices = mesh.getIndices();
            for (var i = 0, l = tris.length; i < l; i++) {
                indices[i] = tris[i];
            }
            return mesh;
        };
        DefaultMeshes.prototype.computeLineDistances = function (vertices, out) {
            out[0] = 0;
            for (var i = 3, ii = 1; i > vertices.length; i += 3, ii++) {
                var start = egret3d.Vector3.create(vertices[i - 3], vertices[i - 2], vertices[i - 1]);
                var end = egret3d.Vector3.create(vertices[i], vertices[i + 1], vertices[i + 2]);
                out[ii] = out[ii - 1] + start.getDistance(end);
            }
        };
        return DefaultMeshes;
    }(paper.SingletonComponent));
    egret3d.DefaultMeshes = DefaultMeshes;
    __reflect(DefaultMeshes.prototype, "egret3d.DefaultMeshes");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 默认的贴图。
     */
    var DefaultTextures = (function (_super) {
        __extends(DefaultTextures, _super);
        function DefaultTextures() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultTextures.prototype.initialize = function () {
            {
                var texture = egret3d.GLTexture2D.createColorTexture("builtin/white.image.json", 255, 255, 255);
                texture._isBuiltin = true;
                DefaultTextures.WHITE = texture;
                paper.Asset.register(texture);
            }
            {
                var texture = egret3d.GLTexture2D.createColorTexture("builtin/gray.image.json", 128, 128, 128);
                texture._isBuiltin = true;
                DefaultTextures.GRAY = texture;
                paper.Asset.register(texture);
            }
            {
                var texture = egret3d.GLTexture2D.createGridTexture("builtin/grid.image.json");
                texture._isBuiltin = true;
                DefaultTextures.GRID = texture;
                paper.Asset.register(texture);
            }
            {
                var texture = egret3d.GLTexture2D.createColorTexture("builtin/missing.image.json", 255, 0, 255);
                texture._isBuiltin = true;
                DefaultTextures.MISSING = texture;
                paper.Asset.register(texture);
            }
        };
        return DefaultTextures;
    }(paper.SingletonComponent));
    egret3d.DefaultTextures = DefaultTextures;
    __reflect(DefaultTextures.prototype, "egret3d.DefaultTextures");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 默认的 shader。
     */
    var DefaultShaders = (function (_super) {
        __extends(DefaultShaders, _super);
        function DefaultShaders() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultShaders.prototype._createShader = function (name, config, renderQueue, states, defines) {
            var shader = new egret3d.Shader(config, name);
            shader._isBuiltin = true;
            if (renderQueue) {
                shader._renderQueue = renderQueue;
            }
            if (defines) {
                shader._defines = defines;
            }
            if (states) {
                var shaderStates = egret3d.GLTFAsset.copyTechniqueStates(states);
                if (shaderStates) {
                    shader._states = shaderStates;
                }
            }
            paper.Asset.register(shader);
            return shader;
        };
        DefaultShaders.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            //
            var helpMaterial = new egret3d.Material(new egret3d.Shader(egret3d.ShaderLib.meshbasic, ""));
            //
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.MESH_BASIC = this._createShader("builtin/meshbasic.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_BASIC_DOUBLESIDE = this._createShader("builtin/meshbasic_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.MESH_LAMBERT = this._createShader("builtin/meshlambert.shader.json", egret3d.ShaderLib.meshlambert, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_LAMBERT_DOUBLESIDE = this._createShader("builtin/meshlambert_doubleside.shader.json", egret3d.ShaderLib.meshlambert, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.MESH_PHONG = this._createShader("builtin/meshphong.shader.json", egret3d.ShaderLib.meshphong, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_PHONE_DOUBLESIDE = this._createShader("builtin/meshphong_doubleside.shader.json", egret3d.ShaderLib.meshphong, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.MESH_PHYSICAL = this._createShader("builtin/meshphysical.shader.json", egret3d.ShaderLib.meshphysical, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_PHYSICAL_DOUBLESIDE = this._createShader("builtin/meshphysical_doubleside.shader.json", egret3d.ShaderLib.meshphysical, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */).setBlend(1 /* Blend */);
            DefaultShaders.TRANSPARENT = this._createShader("builtin/transparent.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(1 /* Blend */);
            DefaultShaders.TRANSPARENT_DOUBLESIDE = this._createShader("builtin/transparent_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */).setBlend(3 /* Add */);
            DefaultShaders.TRANSPARENT_ADDITIVE = this._createShader("builtin/transparent_additive.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(3 /* Add */);
            DefaultShaders.TRANSPARENT_ADDITIVE_DOUBLESIDE = this._createShader("builtin/transparent_additive_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.LINEDASHED = this._createShader("builtin/linedashed.shader.json", egret3d.ShaderLib.linedashed, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.VERTEX_COLOR = this._createShader("builtin/vertcolor.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_MAP" /* USE_MAP */, "USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MATERIAL_COLOR = this._createShader("builtin/materialcolor.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.PARTICLE = this._createShader("builtin/particle.shader.json", egret3d.ShaderLib.particle, 2000 /* Geometry */, helpMaterial.glTFTechnique.states, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(1 /* Blend */);
            DefaultShaders.PARTICLE_BLEND = this._createShader("builtin/particle_blend.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, true).setBlend(1 /* Blend */);
            helpMaterial.glTFTechnique.states.functions.depthFunc = [514 /* EQUAL */]; //TODO
            DefaultShaders.PARTICLE_BLEND1 = this._createShader("builtin/particle_blend1.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(3 /* Add */);
            DefaultShaders.PARTICLE_ADDITIVE = this._createShader("builtin/particle_additive.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(2 /* Blend_PreMultiply */);
            DefaultShaders.PARTICLE_BLEND_PREMULTIPLY = this._createShader("builtin/particle_blend_premultiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(4 /* Add_PreMultiply */);
            DefaultShaders.PARTICLE_ADDITIVE_PREMULTIPLY = this._createShader("builtin/particle_additive_premultiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Transparent */, helpMaterial.glTFTechnique.states, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.CUBE = this._createShader("builtin/cube.shader.json", egret3d.ShaderLib.cube, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.DEPTH = this._createShader("builtin/depth.shader.json", egret3d.ShaderLib.depth, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.DISTANCE_RGBA = this._createShader("builtin/distanceRGBA.shader.json", egret3d.ShaderLib.distanceRGBA, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.EQUIRECT = this._createShader("builtin/equirect.shader.json", egret3d.ShaderLib.equirect, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.NORMAL = this._createShader("builtin/normal.shader.json", egret3d.ShaderLib.normal, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.POINTS = this._createShader("builtin/points.shader.json", egret3d.ShaderLib.points, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.SHADOW = this._createShader("builtin/shadow.shader.json", egret3d.ShaderLib.shadow, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.SPRITE = this._createShader("builtin/sprite.shader.json", egret3d.ShaderLib.sprite, 2000 /* Geometry */, helpMaterial.glTFTechnique.states);
            // // TODO
            // helpMaterial.clearStates().setDepth(true, true).setCullFace(true, gltf.FrontFace.CCW, gltf.CullFace.BACK);
            // this._createShader("obsolete/shaders/diffuse.shader.json", egret3d.ShaderLib.diffuse as any, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states, [ShaderDefines.USE_MAP]);
            helpMaterial.dispose();
        };
        return DefaultShaders;
    }(paper.SingletonComponent));
    egret3d.DefaultShaders = DefaultShaders;
    __reflect(DefaultShaders.prototype, "egret3d.DefaultShaders");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DefaultMaterials = (function (_super) {
        __extends(DefaultMaterials, _super);
        function DefaultMaterials() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultMaterials.prototype._createMaterial = function (name, shader, renderQueue) {
            if (renderQueue === void 0) { renderQueue = 2000 /* Geometry */; }
            var material = new egret3d.Material(shader);
            material.name = name;
            material.renderQueue = renderQueue;
            material._isBuiltin = true;
            paper.Asset.register(material);
            return material;
        };
        DefaultMaterials.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            DefaultMaterials.MESH_BASIC = this._createMaterial("builtin/meshbasic.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setTexture(egret3d.DefaultTextures.WHITE);
            DefaultMaterials.MESH_BASIC_DOUBLESIDE = this._createMaterial("builtin/meshbasic_doubleside.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setTexture(egret3d.DefaultTextures.WHITE)
                .setCullFace(false);
            DefaultMaterials.MESH_LAMBERT = this._createMaterial("builtin/meshlambert.mat.json", egret3d.DefaultShaders.MESH_LAMBERT)
                .setTexture(egret3d.DefaultTextures.WHITE);
            DefaultMaterials.MESH_LAMBERT_DOUBLESIDE = this._createMaterial("builtin/meshlambert_doubleside.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setTexture(egret3d.DefaultTextures.WHITE)
                .setCullFace(false);
            DefaultMaterials.LINEDASHED_COLOR = this._createMaterial("builtin/linedashed_color.mat.json", egret3d.DefaultShaders.LINEDASHED)
                .addDefine("USE_COLOR" /* USE_COLOR */);
            DefaultMaterials.MISSING = this._createMaterial("builtin/missing.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setColor(egret3d.Color.PURPLE);
            DefaultMaterials.SHADOW_DEPTH = this._createMaterial("builtin/shadow_depth.mat.json", egret3d.DefaultShaders.DEPTH)
                .addDefine("DEPTH_PACKING 3201" /* DEPTH_PACKING_3201 */);
            DefaultMaterials.SHADOW_DISTANCE = this._createMaterial("builtin/shadow_distance.mat.json", egret3d.DefaultShaders.DISTANCE_RGBA);
        };
        return DefaultMaterials;
    }(paper.SingletonComponent));
    egret3d.DefaultMaterials = DefaultMaterials;
    __reflect(DefaultMaterials.prototype, "egret3d.DefaultMaterials");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 激活的摄像机和灯光。
     */
    var CamerasAndLights = (function (_super) {
        __extends(CamerasAndLights, _super);
        function CamerasAndLights() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.cameras = [];
            _this.lights = [];
            return _this;
        }
        CamerasAndLights.prototype._sortCameras = function (a, b) {
            var aOrder = a.renderTarget ? a.order : a.order * 1000 + 1;
            var bOrder = b.renderTarget ? b.order : b.order * 1000 + 1;
            return aOrder - bOrder;
        };
        /**
         * 更新摄像机。
         */
        CamerasAndLights.prototype.updateCameras = function (gameObjects) {
            this.cameras.length = 0;
            for (var _i = 0, gameObjects_1 = gameObjects; _i < gameObjects_1.length; _i++) {
                var gameObject = gameObjects_1[_i];
                this.cameras.push(gameObject.getComponent(egret3d.Camera));
            }
        };
        CamerasAndLights.prototype.updateLights = function (gameObjects) {
            this.lights.length = 0;
            for (var _i = 0, gameObjects_2 = gameObjects; _i < gameObjects_2.length; _i++) {
                var gameObject = gameObjects_2[_i];
                this.lights.push(gameObject.getComponent(egret3d.BaseLight, true));
            }
        };
        CamerasAndLights.prototype.sortCameras = function () {
            // TODO camera order event.
            this.cameras.sort(this._sortCameras);
        };
        Object.defineProperty(CamerasAndLights.prototype, "cameraCount", {
            /**
             * 摄像机计数
             */
            get: function () {
                return this.cameras.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CamerasAndLights.prototype, "lightCount", {
            /**
             * 灯光计数。
             */
            get: function () {
                return this.lights.length;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property(0 /* UINT */)
        ], CamerasAndLights.prototype, "cameraCount", null);
        __decorate([
            paper.editor.property(0 /* UINT */)
        ], CamerasAndLights.prototype, "lightCount", null);
        return CamerasAndLights;
    }(paper.SingletonComponent));
    egret3d.CamerasAndLights = CamerasAndLights;
    __reflect(CamerasAndLights.prototype, "egret3d.CamerasAndLights");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 所有 Draw call 信息。
     */
    var DrawCalls = (function (_super) {
        __extends(DrawCalls, _super);
        function DrawCalls() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 每个渲染帧的 Draw call 计数。
             */
            _this.drawCallCount = 0;
            /**
             * 参与渲染的渲染器列表。
             */
            _this.renderers = [];
            /**
             * Draw call 列表。
             */
            _this.drawCalls = [];
            /**
             * 非透明 Draw call 列表。
             */
            _this.opaqueCalls = [];
            /**
             * 透明 Draw call 列表。
             */
            _this.transparentCalls = [];
            /**
             * 阴影 Draw call 列表。
             */
            _this.shadowCalls = [];
            return _this;
        }
        /**
         * 所有非透明的, 按照从近到远排序
         */
        DrawCalls.prototype._sortOpaque = function (a, b) {
            var aMat = a.material;
            var bMat = b.material;
            if (aMat.renderQueue !== bMat.renderQueue) {
                return aMat.renderQueue - bMat.renderQueue;
            }
            else if (aMat._glTFTechnique.program !== bMat._glTFTechnique.program) {
                return aMat._glTFTechnique.program - bMat._glTFTechnique.program;
            }
            else if (aMat._id !== bMat._id) {
                return aMat._id - bMat._id;
            }
            else {
                return a.zdist - b.zdist;
            }
        };
        /**
         * 所有透明的，按照从远到近排序
         */
        DrawCalls.prototype._sortFromFarToNear = function (a, b) {
            if (a.material.renderQueue === b.material.renderQueue) {
                return b.zdist - a.zdist;
            }
            else {
                return a.material.renderQueue - b.material.renderQueue;
            }
        };
        /**
         *
         */
        DrawCalls.prototype.shadowFrustumCulling = function (camera) {
            this.shadowCalls.length = 0;
            for (var _i = 0, _a = this.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                var renderer = drawCall.renderer;
                if (renderer.castShadows &&
                    (camera.cullingMask & renderer.gameObject.layer) !== 0 &&
                    (!renderer.frustumCulled || camera.testFrustumCulling(renderer))) {
                    this.drawCallCount++;
                    this.shadowCalls.push(drawCall);
                }
            }
            this.shadowCalls.sort(this._sortFromFarToNear);
        };
        /**
         *
         */
        DrawCalls.prototype.frustumCulling = function (camera) {
            var cameraPosition = camera.gameObject.transform.position;
            this.opaqueCalls.length = 0;
            this.transparentCalls.length = 0;
            for (var _i = 0, _a = this.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                var renderer = drawCall.renderer;
                if ((camera.cullingMask & renderer.gameObject.layer) !== 0 &&
                    (!renderer.frustumCulled || camera.testFrustumCulling(renderer))) {
                    this.drawCallCount++;
                    // if (drawCall.material.renderQueue >= paper.RenderQueue.Transparent && drawCall.material.renderQueue <= paper.RenderQueue.Overlay) {
                    if (drawCall.material.renderQueue >= 3000 /* Transparent */) {
                        this.transparentCalls.push(drawCall);
                    }
                    else {
                        this.opaqueCalls.push(drawCall);
                    }
                    drawCall.zdist = renderer.gameObject.transform.getPosition().getDistance(cameraPosition);
                }
            }
            this.opaqueCalls.sort(this._sortOpaque);
            this.transparentCalls.sort(this._sortFromFarToNear);
        };
        /**
         * 移除指定渲染器的 draw call 列表。
         */
        DrawCalls.prototype.removeDrawCalls = function (renderer) {
            var index = this.renderers.indexOf(renderer);
            if (index < 0) {
                return;
            }
            var i = this.drawCalls.length;
            while (i--) {
                if (this.drawCalls[i].renderer === renderer) {
                    this.drawCalls.splice(i, 1);
                }
            }
            this.renderers.splice(index, 1);
        };
        /**
         * 是否包含指定渲染器的 draw call 列表。
         */
        DrawCalls.prototype.hasDrawCalls = function (renderer) {
            return this.renderers.indexOf(renderer) >= 0;
        };
        __decorate([
            paper.editor.property(0 /* UINT */)
        ], DrawCalls.prototype, "drawCallCount", void 0);
        return DrawCalls;
    }(paper.SingletonComponent));
    egret3d.DrawCalls = DrawCalls;
    __reflect(DrawCalls.prototype, "egret3d.DrawCalls");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 组件事件。
     */
    var EventPool;
    (function (EventPool) {
        /**
         * @internal
         */
        var EventType;
        (function (EventType) {
            EventType["Enabled"] = "__enabled__";
            EventType["Disabled"] = "__disabled__";
        })(EventType = EventPool.EventType || (EventPool.EventType = {}));
        var _behaviourComponentType = egret.getQualifiedClassName(paper.Behaviour);
        var _componentListeners = {};
        function _dispatchEvent(type, componentType, component, extend) {
            var componentListeners = _componentListeners[componentType];
            if (type in componentListeners) {
                var eventListeners = componentListeners[type];
                for (var _i = 0, eventListeners_1 = eventListeners; _i < eventListeners_1.length; _i++) {
                    var listener = eventListeners_1[_i];
                    // 监听直接派发，所以监听都应注意 bind 问题。
                    if (extend) {
                        listener(component, extend);
                    }
                    else {
                        listener(component);
                    }
                }
            }
        }
        /**
         * 添加事件监听
         */
        function addEventListener(eventType, componentClass, callback) {
            var componentType = egret.getQualifiedClassName(componentClass);
            var componentListeners = componentType in _componentListeners ? _componentListeners[componentType] : _componentListeners[componentType] = {};
            var eventListeners = eventType in componentListeners ? componentListeners[eventType] : componentListeners[eventType] = [];
            eventListeners.push(callback);
        }
        EventPool.addEventListener = addEventListener;
        /**
         * 移除事件监听
         */
        function removeEventListener(eventType, componentClass, callback) {
            var componentType = egret.getQualifiedClassName(componentClass);
            if (componentType in _componentListeners) {
                var componentListeners = _componentListeners[componentType];
                if (eventType in componentListeners) {
                    var eventListeners = componentListeners[eventType];
                    for (var i = 0, l = eventListeners.length; i < l; i++) {
                        if (eventListeners[i] === callback) {
                            eventListeners.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }
        EventPool.removeEventListener = removeEventListener;
        /**
         * 移除所有该类型的事件监听
         */
        function removeAllEventListener(eventType, componentClass) {
            var componentType = egret.getQualifiedClassName(componentClass);
            if (componentType in _componentListeners) {
                var componentListeners = _componentListeners[componentType];
                if (eventType) {
                    if (eventType in componentListeners) {
                        componentListeners[eventType].length = 0;
                    }
                }
                else {
                    delete _componentListeners[componentType];
                }
            }
        }
        EventPool.removeAllEventListener = removeAllEventListener;
        /**
         * 发送组件事件:
         * @param type event type:
         * @param component component
         */
        function dispatchEvent(type, component, extend) {
            // 如果是组件的添加或删除事件，并且该组件派生自 Behaviour 组件，则需要使用基类的组件类型，这些组件发出的添加或删除事件都能被生命周期系统收到。 
            if (type === "__enabled__" /* Enabled */ || type === "__disabled__" /* Disabled */) {
                if (egret.is(component, _behaviourComponentType)) {
                    _dispatchEvent(type, _behaviourComponentType, component);
                }
            }
            var componentType = egret.getQualifiedClassName(component);
            if (componentType in _componentListeners) {
                _dispatchEvent(type, componentType, component, extend);
            }
        }
        EventPool.dispatchEvent = dispatchEvent;
    })(EventPool = paper.EventPool || (paper.EventPool = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var BoxCollider = (function (_super) {
        __extends(BoxCollider, _super);
        function BoxCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colliderType = egret3d.ColliderType.Box;
            _this.aabb = egret3d.AABB.ONE.clone();
            return _this;
        }
        BoxCollider.prototype.raycast = function (ray, raycastInfo) {
            var localRay = egret3d.helpRay.applyMatrix(egret3d.helpMatrixA.inverse(this.transform.worldMatrix), ray); // TODO transform inverse world matrix.
            if (this.aabb.raycast(localRay, raycastInfo)) {
                if (raycastInfo) {
                    raycastInfo.position.applyMatrix(this.transform.worldMatrix);
                    raycastInfo.distance = ray.origin.getDistance(raycastInfo.position);
                }
                return true;
            }
            return false;
        };
        __decorate([
            paper.serializedField
        ], BoxCollider.prototype, "aabb", void 0);
        return BoxCollider;
    }(egret3d.BaseCollider));
    egret3d.BoxCollider = BoxCollider;
    __reflect(BoxCollider.prototype, "egret3d.BoxCollider");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var SphereCollider = (function (_super) {
        __extends(SphereCollider, _super);
        function SphereCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colliderType = egret3d.ColliderType.Sphere;
            _this.sphere = egret3d.Sphere.create(egret3d.Vector3.ZERO, 0.5);
            return _this;
        }
        SphereCollider.prototype.raycast = function (ray, raycastInfo) {
            var localRay = egret3d.helpRay.applyMatrix(egret3d.helpMatrixA.inverse(this.transform.worldMatrix), ray); // TODO transform inverse world matrix.
            if (this.sphere.raycast(localRay, raycastInfo)) {
                if (raycastInfo) {
                    raycastInfo.position.applyMatrix(this.transform.worldMatrix);
                    raycastInfo.distance = ray.origin.getDistance(raycastInfo.position);
                }
                return true;
            }
            return false;
        };
        __decorate([
            paper.serializedField
        ], SphereCollider.prototype, "sphere", void 0);
        return SphereCollider;
    }(egret3d.BaseCollider));
    egret3d.SphereCollider = SphereCollider;
    __reflect(SphereCollider.prototype, "egret3d.SphereCollider");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @internal
     */
    var CameraAndLightSystem = (function (_super) {
        __extends(CameraAndLightSystem, _super);
        function CameraAndLightSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                [
                    { componentClass: egret3d.Camera }
                ],
                [
                    { componentClass: [egret3d.DirectionalLight, egret3d.PointLight, egret3d.SpotLight] }
                ]
            ];
            _this._camerasAndLights = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.CamerasAndLights);
            return _this;
        }
        CameraAndLightSystem.prototype.onAddGameObject = function (_gameObject, group) {
            if (group === this._groups[0]) {
                this._camerasAndLights.updateCameras(this._groups[0].gameObjects);
            }
            else if (group === this._groups[1]) {
                this._camerasAndLights.updateLights(this._groups[1].gameObjects);
            }
        };
        CameraAndLightSystem.prototype.onRemoveGameObject = function (_gameObject, group) {
            if (group === this._groups[0]) {
                this._camerasAndLights.updateCameras(this._groups[0].gameObjects);
            }
            else if (group === this._groups[1]) {
                this._camerasAndLights.updateLights(this._groups[1].gameObjects);
            }
        };
        CameraAndLightSystem.prototype.onUpdate = function (deltaTime) {
            var cameras = this._camerasAndLights.cameras;
            if (cameras.length > 0) {
                this._camerasAndLights.sortCameras();
                for (var _i = 0, cameras_1 = cameras; _i < cameras_1.length; _i++) {
                    var component = cameras_1[_i];
                    component._update(deltaTime);
                }
            }
        };
        return CameraAndLightSystem;
    }(paper.BaseSystem));
    egret3d.CameraAndLightSystem = CameraAndLightSystem;
    __reflect(CameraAndLightSystem.prototype, "egret3d.CameraAndLightSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var helpRectA = new egret3d.Rectangle();
    /**
     * 相机组件
     */
    var Camera = (function (_super) {
        __extends(Camera, _super);
        function Camera() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 是否清除颜色缓冲区
             */
            _this.clearOption_Color = true;
            /**
             * 是否清除深度缓冲区
             */
            _this.clearOption_Depth = true;
            /**
             * 相机的渲染剔除，对应 GameObject 的层级。
             * - camera.cullingMask = paper.CullingMask.UI;
             * - camera.cullingMask |= paper.CullingMask.UI;
             * - camera.cullingMask &= ~paper.CullingMask.UI;
             */
            _this.cullingMask = 16777215 /* Everything */;
            /**
             * 相机渲染排序
             */
            _this.order = 0;
            /**
             * 透视投影的fov
             */
            _this.fov = Math.PI * 0.25;
            /**
             * 正交投影的竖向size
             */
            _this.size = 2.0;
            /**
             * 0=正交，1=透视 中间值可以在两种相机间过度
             */
            _this.opvalue = 1.0;
            /**
             * 背景色
             */
            _this.backgroundColor = egret3d.Color.create(0.15, 0.25, 0.5, 1.0);
            /**
             * 相机视窗
             */
            _this.viewport = new egret3d.Rectangle(0, 0, 1, 1);
            /**
             * TODO 功能完善后开放此接口
             */
            _this.postQueues = [];
            /**
             * 相机渲染上下文
             * @internal
             */
            _this.context = null;
            /**
             * 渲染目标，如果为null，则为画布
             */
            _this.renderTarget = null;
            _this._near = 0.001;
            _this._far = 1000.0;
            _this._projectionMatrix = egret3d.Matrix4.create();
            _this._matProjO = egret3d.Matrix4.create();
            _this._frameVectors = [
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create()
            ];
            return _this;
        }
        Object.defineProperty(Camera, "main", {
            /**
             * 当前场景的主相机。
             * - 如果没有则创建一个。
             */
            get: function () {
                var gameObject = paper.Application.sceneManager.activeScene.findWithTag("Main Camera" /* MainCamera */);
                if (!gameObject) {
                    gameObject = paper.GameObject.create("Main Camera" /* MainCamera */, "Main Camera" /* MainCamera */);
                    gameObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                    gameObject.transform.lookAt(egret3d.Vector3.ZERO);
                }
                return gameObject.getOrAddComponent(Camera);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera, "editor", {
            /**
             * 编辑相机。
             * - 如果没有则创建一个。
             */
            get: function () {
                var gameObject = paper.Application.sceneManager.editorScene.find("Editor Camera" /* EditorCamera */);
                if (!gameObject) {
                    gameObject = paper.GameObject.create("Editor Camera" /* EditorCamera */, "Editor Only" /* EditorOnly */, paper.Application.sceneManager.editorScene);
                    gameObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                    gameObject.transform.lookAt(egret3d.Vector3.ZERO);
                    var camera = gameObject.addComponent(Camera);
                    camera.cullingMask &= ~4 /* UI */;
                    camera.far = 10000.0;
                }
                return gameObject.getOrAddComponent(Camera);
            },
            enumerable: true,
            configurable: true
        });
        // private readonly _frustumPlanes: Plane[] = [
        //     Plane.create(),
        //     Plane.create(),
        //     Plane.create(),
        //     Plane.create(),
        //     Plane.create(),
        //     Plane.create(),
        // ];
        /**
         * 计算相机视锥区域
         */
        Camera.prototype._calcCameraFrame = function () {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var farLD = this._frameVectors[0];
            var nearLD = this._frameVectors[1];
            var farRD = this._frameVectors[2];
            var nearRD = this._frameVectors[3];
            var farLT = this._frameVectors[4];
            var nearLT = this._frameVectors[5];
            var farRT = this._frameVectors[6];
            var nearRT = this._frameVectors[7];
            var near_h = this.near * Math.tan(this.fov * 0.5);
            var asp = vpp.w / vpp.h;
            var near_w = near_h * asp;
            nearLT.set(-near_w, near_h, this.near);
            nearLD.set(-near_w, -near_h, this.near);
            nearRT.set(near_w, near_h, this.near);
            nearRD.set(near_w, -near_h, this.near);
            var far_h = this.far * Math.tan(this.fov * 0.5);
            var far_w = far_h * asp;
            farLT.set(-far_w, far_h, this.far);
            farLD.set(-far_w, -far_h, this.far);
            farRT.set(far_w, far_h, this.far);
            farRD.set(far_w, -far_h, this.far);
            var matrix = this.gameObject.transform.getWorldMatrix();
            farLD.applyMatrix(matrix);
            nearLD.applyMatrix(matrix);
            farRD.applyMatrix(matrix);
            nearRD.applyMatrix(matrix);
            farLT.applyMatrix(matrix);
            nearLT.applyMatrix(matrix);
            farRT.applyMatrix(matrix);
            nearRT.applyMatrix(matrix);
        };
        Camera.prototype._intersectPlane = function (boundingSphere, v0, v1, v2) {
            var subV0 = egret3d.helpVector3A;
            var subV1 = egret3d.helpVector3B;
            var cross = egret3d.helpVector3C;
            var hitPoint = egret3d.helpVector3D;
            var distVec = egret3d.helpVector3E;
            var center = boundingSphere.center;
            subV0.subtract(v1, v0);
            subV1.subtract(v2, v1);
            cross.cross(subV0, subV1);
            egret3d.calPlaneLineIntersectPoint(cross, v0, cross, center, hitPoint);
            distVec.subtract(hitPoint, center);
            var val = distVec.dot(cross);
            if (val <= 0) {
                return true;
            }
            var dist = hitPoint.getDistance(center);
            if (dist < boundingSphere.radius) {
                return true;
            }
            return false;
        };
        /**
         * @internal
         */
        Camera.prototype._update = function (_delta) {
            this._calcCameraFrame();
            this.context.updateCamera(this, this.gameObject.transform.getWorldMatrix());
        };
        Camera.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.context = new egret3d.RenderContext();
        };
        /**
         * 计算相机的 project matrix（投影矩阵）
         */
        Camera.prototype.calcProjectMatrix = function (asp, matrix) {
            if (this.opvalue > 0) {
                egret3d.Matrix4.perspectiveProjectLH(this.fov, asp, this.near, this.far, this._projectionMatrix);
            }
            if (this.opvalue < 1) {
                egret3d.Matrix4.orthoProjectLH(this.size * asp, this.size, this.near, this.far, this._matProjO);
            }
            if (this.opvalue === 0.0) {
                matrix.copy(this._matProjO);
            }
            else if (this.opvalue === 1.0) {
                matrix.copy(this._projectionMatrix);
            }
            else {
                matrix.lerp(this.opvalue, this._matProjO, this._projectionMatrix);
            }
            return matrix;
        };
        /**
         * 计算相机视口像素rect
         */
        Camera.prototype.calcViewPortPixel = function (viewPortPixel) {
            var w;
            var h;
            var renderTarget = this.renderTarget;
            var viewport = this.viewport;
            if (renderTarget) {
                w = renderTarget.width;
                h = renderTarget.height;
            }
            else {
                w = egret3d.stage.screenViewport.w;
                h = egret3d.stage.screenViewport.h;
            }
            viewPortPixel.x = w * viewport.x;
            viewPortPixel.y = h * viewport.y;
            viewPortPixel.w = w * viewport.w;
            viewPortPixel.h = h * viewport.h;
            //asp = this.viewPortPixel.w / this.viewPortPixel.h;
        };
        /**
         * 由屏幕坐标得到世界坐标
         */
        Camera.prototype.calcWorldPosFromScreenPos = function (screenPos, outWorldPos) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var vppos = egret3d.helpVector3A;
            vppos.x = screenPos.x / vpp.w * 2.0 - 1.0;
            vppos.y = 1.0 - screenPos.y / vpp.h * 2.0;
            vppos.z = screenPos.z;
            var matrixView = egret3d.helpMatrixA;
            var matrixProject = egret3d.helpMatrixB;
            var asp = vpp.w / vpp.h;
            matrixView.inverse(this.gameObject.transform.getWorldMatrix());
            this.calcProjectMatrix(asp, matrixProject);
            egret3d.helpMatrixC.multiply(matrixProject, matrixView)
                .inverse()
                .transformVector3(vppos, outWorldPos);
        };
        /**
         * 由世界坐标得到屏幕坐标
         */
        Camera.prototype.calcScreenPosFromWorldPos = function (worldPos, outScreenPos) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var matrixView = egret3d.helpMatrixA;
            var matrixProject = egret3d.helpMatrixB;
            var asp = vpp.w / vpp.h;
            matrixView.inverse(this.gameObject.transform.getWorldMatrix());
            this.calcProjectMatrix(asp, matrixProject);
            var matrixViewProject = egret3d.helpMatrixC.multiply(matrixProject, matrixView);
            var ndcPos = egret3d.helpVector3A;
            matrixViewProject.transformVector3(worldPos, ndcPos);
            outScreenPos.x = (ndcPos.x + 1.0) * vpp.w * 0.5;
            outScreenPos.y = (1.0 - ndcPos.y) * vpp.h * 0.5;
        };
        Camera.prototype.getPosAtXPanelInViewCoordinateByScreenPos = function (screenPos, z, out) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var nearpos = egret3d.helpVector3A;
            nearpos.z = -this.near;
            nearpos.x = screenPos.x - vpp.w * 0.5;
            nearpos.y = vpp.h * 0.5 - screenPos.y;
            var farpos = egret3d.helpVector3B;
            farpos.z = -this.far;
            farpos.x = this.far * nearpos.x / this.near;
            farpos.y = this.far * nearpos.y / this.near;
            var rate = (nearpos.z - z) / (nearpos.z - farpos.z);
            out.x = nearpos.x - (nearpos.x - farpos.x) * rate;
            out.y = nearpos.y - (nearpos.y - farpos.y) * rate;
        };
        /**
         * 由屏幕坐标发射射线
         */
        Camera.prototype.createRayByScreen = function (screenPosX, screenPosY, ray) {
            var from = egret3d.Vector3.create(screenPosX, screenPosY, 0.0).release();
            var to = egret3d.Vector3.create(screenPosX, screenPosY, 1.0).release();
            this.calcWorldPosFromScreenPos(from, from);
            this.calcWorldPosFromScreenPos(to, to);
            to.subtract(to, from).normalize();
            ray = ray || egret3d.Ray.create();
            ray.set(from, to);
            return ray;
        };
        Camera.prototype.testFrustumCulling = function (node) {
            var boundingSphere = node.boundingSphere;
            if (!this._intersectPlane(boundingSphere, this._frameVectors[0], this._frameVectors[1], this._frameVectors[5]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVectors[1], this._frameVectors[3], this._frameVectors[7]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVectors[3], this._frameVectors[2], this._frameVectors[6]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVectors[2], this._frameVectors[0], this._frameVectors[4]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVectors[5], this._frameVectors[7], this._frameVectors[6]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVectors[0], this._frameVectors[2], this._frameVectors[3]))
                return false;
            return true;
        };
        Object.defineProperty(Camera.prototype, "near", {
            /**
             * 相机到近裁剪面距离。
             */
            get: function () {
                return this._near;
            },
            set: function (value) {
                if (value >= this.far) {
                    value = this.far - 1.0;
                }
                if (value < 0.001) {
                    value = 0.001;
                }
                this._near = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "far", {
            /**
             * 相机到远裁剪面距离。
             */
            get: function () {
                return this._far;
            },
            set: function (value) {
                if (value <= this.near) {
                    value = this.near + 1.0;
                }
                if (value >= 10000.0) {
                    value = 10000.0;
                }
                this._far = value;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField,
            paper.editor.property(4 /* CHECKBOX */)
        ], Camera.prototype, "clearOption_Color", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(4 /* CHECKBOX */)
        ], Camera.prototype, "clearOption_Depth", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(10 /* LIST */, { listItems: paper.editor.getItemsFromEnum(paper.CullingMask) })
        ], Camera.prototype, "cullingMask", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(1 /* INT */)
        ], Camera.prototype, "order", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0, maximum: Math.PI, step: 0.01 })
        ], Camera.prototype, "fov", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0 })
        ], Camera.prototype, "size", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0, maximum: 1.0, step: 0.01 })
        ], Camera.prototype, "opvalue", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(9 /* COLOR */)
        ], Camera.prototype, "backgroundColor", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "viewport", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "_near", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "_far", void 0);
        __decorate([
            paper.editor.property(2 /* FLOAT */, { minimum: 0.001, step: 1 })
        ], Camera.prototype, "near", null);
        __decorate([
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0, maximum: 3000.0, step: 1 })
        ], Camera.prototype, "far", null);
        return Camera;
    }(paper.BaseComponent));
    egret3d.Camera = Camera;
    __reflect(Camera.prototype, "egret3d.Camera");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var CameraPostQueueDepth = (function () {
        function CameraPostQueueDepth() {
            this.renderTarget = null;
        }
        CameraPostQueueDepth.prototype.render = function (camera, renderSystem) {
            // camera.context.drawtype = "_depth";
            // renderSystem._targetAndViewport(camera.viewport, this.renderTarget);
            // renderSystem._cleanBuffer(true, true, Color.BLACK);
            // renderSystem._renderCamera(camera);
            // GlRenderTarget.useNull();
        };
        return CameraPostQueueDepth;
    }());
    egret3d.CameraPostQueueDepth = CameraPostQueueDepth;
    __reflect(CameraPostQueueDepth.prototype, "egret3d.CameraPostQueueDepth", ["egret3d.ICameraPostQueue"]);
    // /**
    //  * framebuffer绘制通道
    //  * 
    //  */
    // export class CameraPostQueueQuad implements ICameraPostQueue {
    //     /**
    //      * shader & uniform
    //      */
    //     public readonly material: Material = new Material();
    //     /**
    //      * @inheritDoc
    //      */
    //     public renderTarget: GlRenderTarget = null as any;
    //     /**
    //      * @inheritDoc
    //      */
    //     public render(camera: Camera, _renderSystem: CameraSystem) {
    //         const webgl = WebGLKit.webgl;
    //         camera._targetAndViewport(this.renderTarget, true);
    //         WebGLKit.zWrite(true);
    //         // webgl.depthMask(true); // 开启 zwrite 以便正常 clear depth
    //         webgl.clearColor(0, 0.3, 0, 0);
    //         webgl.clearDepth(1.0);
    //         webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
    //         const mesh = DefaultMeshes.QUAD;
    //         camera.context.drawtype = "";
    //         WebGLKit.draw(camera.context, this.material, mesh, 0, "quad");
    //     }
    // }
    /**
     * 颜色绘制通道
     *
     */
    var CameraPostQueueColor = (function () {
        function CameraPostQueueColor() {
            /**
             * @inheritDoc
             */
            this.renderTarget = null;
        }
        /**
         * @inheritDoc
         */
        CameraPostQueueColor.prototype.render = function (camera, renderSystem) {
            // renderSystem._targetAndViewport(camera.viewport, this.renderTarget);
            // renderSystem._cleanBuffer(camera.clearOption_Color, camera.clearOption_Depth, camera.backgroundColor);
            // renderSystem._renderCamera(camera);
            // GlRenderTarget.useNull();
        };
        return CameraPostQueueColor;
    }());
    egret3d.CameraPostQueueColor = CameraPostQueueColor;
    __reflect(CameraPostQueueColor.prototype, "egret3d.CameraPostQueueColor", ["egret3d.ICameraPostQueue"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var LightSize;
    (function (LightSize) {
        LightSize[LightSize["Directional"] = 12] = "Directional";
        LightSize[LightSize["Point"] = 15] = "Point";
        LightSize[LightSize["Spot"] = 18] = "Spot";
    })(LightSize || (LightSize = {}));
    var _helpVector3 = egret3d.Vector3.create();
    /**
     * @internal
     */
    var RenderContext = (function () {
        function RenderContext() {
            /**
             *
             */
            this.lightCount = 0;
            this.directLightCount = 0;
            this.pointLightCount = 0;
            this.spotLightCount = 0;
            this.shaderContextDefine = "";
            /**
             *
             */
            this.lightmap = null;
            this.lightmapUV = 1;
            this.lightmapIntensity = 1.0;
            //TODO
            // 15: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, intensity, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
            this.directLightArray = new Float32Array(0);
            // 19: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, intensity, distance, decay, shadow, shadowBias, shadowRadius, shadowCameraNear, shadowCameraFar, shadowMapSizeX, shadowMapSizeY
            this.pointLightArray = new Float32Array(0);
            // 19: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, intensity, distance, decay, coneCos, penumbraCos, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
            this.spotLightArray = new Float32Array(0);
            this.directShadowMatrix = new Float32Array(0);
            this.spotShadowMatrix = new Float32Array(0);
            this.pointShadowMatrix = new Float32Array(0);
            this.matrix_m = egret3d.Matrix4.create();
            this.matrix_mvp = egret3d.Matrix4.create();
            this.directShadowMaps = [];
            this.pointShadowMaps = [];
            this.spotShadowMaps = [];
            this.ambientLightColor = new Float32Array([0, 0, 0]);
            this.viewPortPixel = { x: 0, y: 0, w: 0, h: 0 };
            //
            this.cameraPosition = new Float32Array(3);
            this.cameraForward = new Float32Array(3);
            this.cameraUp = new Float32Array(3);
            // transforms
            this.matrix_v = egret3d.Matrix4.create();
            this.matrix_p = egret3d.Matrix4.create();
            this.matrix_mv = egret3d.Matrix4.create();
            this.matrix_vp = egret3d.Matrix4.create();
            this.matrix_mv_inverse = new egret3d.Matrix3(); //INVERS
            this.lightShadowCameraNear = 0;
            this.lightShadowCameraFar = 0;
            this.lightPosition = new Float32Array([0.0, 0.0, 0.0, 1.0]);
            this.fogColor = new Float32Array(3);
            this.fogDensity = 0.0;
            this.fogNear = 0.0;
            this.fogFar = 0.0;
            this.drawCall = null;
        }
        RenderContext.prototype.updateCamera = function (camera, matrix) {
            camera.calcViewPortPixel(this.viewPortPixel); // update viewport
            camera.calcProjectMatrix(this.viewPortPixel.w / this.viewPortPixel.h, this.matrix_p);
            this.matrix_v.inverse(matrix);
            this.matrix_vp.multiply(this.matrix_p, this.matrix_v);
            var rawData = matrix.rawData;
            if (this.cameraPosition[0] !== rawData[12] ||
                this.cameraPosition[1] !== rawData[13] ||
                this.cameraPosition[2] !== rawData[14]) {
                this.cameraPosition[0] = rawData[12];
                this.cameraPosition[1] = rawData[13];
                this.cameraPosition[2] = rawData[14];
            }
            if (this.cameraUp[0] !== rawData[4] ||
                this.cameraUp[1] !== rawData[5] ||
                this.cameraUp[2] !== rawData[6]) {
                this.cameraUp[0] = rawData[4];
                this.cameraUp[1] = rawData[5];
                this.cameraUp[2] = rawData[6];
            }
            if (this.cameraForward[0] !== rawData[8] ||
                this.cameraForward[1] !== rawData[9] ||
                this.cameraForward[2] !== rawData[10]) {
                this.cameraForward[0] = -rawData[8];
                this.cameraForward[1] = -rawData[9];
                this.cameraForward[2] = -rawData[10];
            }
        };
        RenderContext.prototype.updateLights = function (lights, ambientLightColor) {
            var allLightCount = 0, directLightCount = 0, pointLightCount = 0, spotLightCount = 0;
            if (lights.length > 0) {
                this.ambientLightColor[0] = ambientLightColor.r;
                this.ambientLightColor[1] = ambientLightColor.g;
                this.ambientLightColor[2] = ambientLightColor.b;
            }
            for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {
                var light = lights_1[_i];
                if (light instanceof egret3d.DirectionalLight) {
                    directLightCount++;
                }
                else if (light instanceof egret3d.PointLight) {
                    pointLightCount++;
                }
                else if (light instanceof egret3d.SpotLight) {
                    spotLightCount++;
                }
                allLightCount++;
            }
            // TODO
            if (this.directLightArray.length !== directLightCount * 12 /* Directional */) {
                this.directLightArray = new Float32Array(directLightCount * 12 /* Directional */);
            }
            if (this.pointLightArray.length !== pointLightCount * 15 /* Point */) {
                this.pointLightArray = new Float32Array(pointLightCount * 15 /* Point */);
            }
            if (this.spotLightArray.length !== spotLightCount * 18 /* Spot */) {
                this.spotLightArray = new Float32Array(spotLightCount * 18 /* Spot */);
            }
            if (this.directShadowMatrix.length !== directLightCount * 16) {
                this.directShadowMatrix = new Float32Array(directLightCount * 16);
            }
            if (this.pointShadowMatrix.length !== pointLightCount * 16) {
                this.pointShadowMatrix = new Float32Array(pointLightCount * 16);
            }
            if (this.spotShadowMatrix.length !== spotLightCount * 16) {
                this.spotShadowMatrix = new Float32Array(spotLightCount * 16);
            }
            this.directShadowMaps.length = directLightCount;
            this.pointShadowMaps.length = pointLightCount;
            this.spotShadowMaps.length = spotLightCount;
            this.lightCount = allLightCount;
            this.directLightCount = directLightCount;
            this.pointLightCount = pointLightCount;
            this.spotLightCount = spotLightCount;
            var directLightIndex = 0, pointLightIndex = 0, spotLightIndex = 0, index = 0;
            var lightArray = this.directLightArray;
            for (var _a = 0, lights_2 = lights; _a < lights_2.length; _a++) {
                var light = lights_2[_a];
                switch (light.constructor) {
                    case egret3d.DirectionalLight: {
                        light.gameObject.transform.getForward(_helpVector3);
                        _helpVector3.applyDirection(this.matrix_v).normalize();
                        lightArray = this.directLightArray;
                        index = directLightIndex * 12 /* Directional */;
                        // lightArray[index++] = dirHelper.x; // Right-hand.
                        // lightArray[index++] = dirHelper.y;
                        // lightArray[index++] = dirHelper.z;
                        lightArray[index++] = -_helpVector3.x; // Left-hand.
                        lightArray[index++] = -_helpVector3.y;
                        lightArray[index++] = -_helpVector3.z;
                        lightArray[index++] = light.color.r * light.intensity;
                        lightArray[index++] = light.color.g * light.intensity;
                        lightArray[index++] = light.color.b * light.intensity;
                        break;
                    }
                    case egret3d.PointLight: {
                        var position = light.gameObject.transform.getPosition();
                        lightArray = this.pointLightArray;
                        index = pointLightIndex * 15 /* Point */;
                        lightArray[index++] = position.x;
                        lightArray[index++] = position.y;
                        lightArray[index++] = position.z;
                        lightArray[index++] = light.color.r * light.intensity;
                        lightArray[index++] = light.color.g * light.intensity;
                        lightArray[index++] = light.color.b * light.intensity;
                        lightArray[index++] = light.distance;
                        lightArray[index++] = light.decay;
                        break;
                    }
                    case egret3d.SpotLight: {
                        var position = light.gameObject.transform.getPosition();
                        light.gameObject.transform.getForward(_helpVector3);
                        _helpVector3.applyDirection(this.matrix_v).normalize();
                        lightArray = this.spotLightArray;
                        index = spotLightIndex * 18 /* Spot */;
                        lightArray[index++] = position.x;
                        lightArray[index++] = position.y;
                        lightArray[index++] = position.z;
                        // lightArray[index++] = dirHelper.x; // Right-hand.
                        // lightArray[index++] = dirHelper.y;
                        // lightArray[index++] = dirHelper.z;
                        lightArray[index++] = -_helpVector3.x; // Left-hand.
                        lightArray[index++] = -_helpVector3.y;
                        lightArray[index++] = -_helpVector3.z;
                        lightArray[index++] = light.color.r * light.intensity;
                        lightArray[index++] = light.color.g * light.intensity;
                        lightArray[index++] = light.color.b * light.intensity;
                        lightArray[index++] = light.distance;
                        lightArray[index++] = light.decay;
                        lightArray[index++] = Math.cos(light.angle);
                        lightArray[index++] = Math.cos(light.angle * (1 - light.penumbra));
                        break;
                    }
                }
                if (light.castShadows) {
                    lightArray[index++] = 1;
                    // lightArray[index++] = light.shadowBias; // Right-hand.
                    lightArray[index++] = -light.shadowBias; // Left-hand.
                    lightArray[index++] = light.shadowRadius;
                    lightArray[index++] = light.shadowSize;
                    lightArray[index++] = light.shadowSize;
                    switch (light.constructor) {
                        case egret3d.DirectionalLight:
                            this.directShadowMatrix.set(light.matrix.rawData, directLightIndex * 16);
                            this.directShadowMaps[directLightIndex++] = light.renderTarget.texture;
                            break;
                        case egret3d.PointLight:
                            lightArray[index++] = light.shadowCameraNear;
                            lightArray[index++] = light.shadowCameraFar;
                            this.pointShadowMatrix.set(light.matrix.rawData, pointLightIndex * 16);
                            this.pointShadowMaps[pointLightIndex++] = light.renderTarget.texture;
                            break;
                        case egret3d.SpotLight:
                            this.spotShadowMatrix.set(light.matrix.rawData, spotLightIndex * 16);
                            this.spotShadowMaps[spotLightIndex++] = light.renderTarget.texture;
                            break;
                    }
                }
                else {
                    lightArray[index++] = 0;
                    lightArray[index++] = 0;
                    lightArray[index++] = 0;
                    lightArray[index++] = 0;
                    switch (light.constructor) {
                        case egret3d.DirectionalLight:
                            this.directShadowMaps[directLightIndex++] = null;
                            break;
                        case egret3d.PointLight:
                            lightArray[index++] = 0;
                            lightArray[index++] = 0;
                            this.pointShadowMaps[pointLightIndex++] = null;
                            break;
                        case egret3d.SpotLight:
                            this.spotShadowMaps[spotLightIndex++] = null;
                            break;
                    }
                }
            }
        };
        RenderContext.prototype.updateLightDepth = function (light) {
            var position = light.gameObject.transform.getPosition();
            if (this.lightPosition[0] !== position.x ||
                this.lightPosition[1] !== position.y ||
                this.lightPosition[2] !== position.z) {
                //
                this.lightPosition[0] = position.x;
                this.lightPosition[1] = position.y;
                this.lightPosition[2] = position.z;
            }
            if (this.lightShadowCameraNear !== light.shadowCameraNear ||
                this.lightShadowCameraNear !== light.shadowCameraFar) {
                //
                this.lightShadowCameraNear = light.shadowCameraNear;
                this.lightShadowCameraFar = light.shadowCameraFar;
            }
        };
        RenderContext.prototype.update = function (drawCall) {
            var renderer = drawCall.renderer;
            var scene = renderer.gameObject.scene;
            var matrix = drawCall.matrix || renderer.gameObject.transform.worldMatrix;
            this.drawCall = drawCall;
            this.matrix_m.copy(matrix); // clone matrix because getWorldMatrix returns a reference
            this.matrix_mv.multiply(this.matrix_v, this.matrix_m);
            this.matrix_mvp.multiply(this.matrix_vp, this.matrix_m);
            this.matrix_mv_inverse.getNormalMatrix(this.matrix_mv);
            //
            this.shaderContextDefine = "";
            if (renderer.lightmapIndex >= 0 &&
                scene.lightmaps.length > renderer.lightmapIndex) {
                this.lightmap = scene.lightmaps[renderer.lightmapIndex];
                this.lightmapUV = drawCall.mesh.glTFMesh.primitives[drawCall.subMeshIndex].attributes.TEXCOORD_1 ? 1 : 0;
                this.lightmapIntensity = scene.lightmapIntensity;
                this.shaderContextDefine += "#define USE_LIGHTMAP \n";
            }
            if (this.lightCount > 0) {
                if (this.directLightCount > 0) {
                    this.shaderContextDefine += "#define NUM_DIR_LIGHTS " + this.directLightCount + "\n";
                }
                if (this.pointLightCount > 0) {
                    this.shaderContextDefine += "#define NUM_POINT_LIGHTS " + this.pointLightCount + "\n";
                }
                if (this.spotLightCount > 0) {
                    this.shaderContextDefine += "#define NUM_SPOT_LIGHTS " + this.spotLightCount + "\n";
                }
                if (renderer.receiveShadows) {
                    this.shaderContextDefine += "#define USE_SHADOWMAP \n";
                    this.shaderContextDefine += "#define SHADOWMAP_TYPE_PCF \n";
                }
            }
            if (scene.fogMode !== 0 /* NONE */) {
                this.fogColor[0] = scene.fogColor.r;
                this.fogColor[1] = scene.fogColor.g;
                this.fogColor[2] = scene.fogColor.b;
                this.shaderContextDefine += "#define USE_FOG \n";
                if (scene.fogMode === 2 /* FOG_EXP2 */) {
                    this.fogDensity = scene.fogDensity;
                    this.shaderContextDefine += "#define FOG_EXP2 \n";
                }
                else {
                    this.fogNear = scene.fogNear;
                    this.fogFar = scene.fogFar;
                }
            }
        };
        return RenderContext;
    }());
    egret3d.RenderContext = RenderContext;
    __reflect(RenderContext.prototype, "egret3d.RenderContext");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 可以添加egret2d显示对象（包括EUI）进行渲染。
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Egret2DRenderer = (function (_super) {
        __extends(Egret2DRenderer, _super);
        function Egret2DRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * TODO
             */
            _this.frustumCulled = false;
            _this._screenAdapter = new egret3d.ConstantAdapter();
            _this._catchedEvent = {};
            _this._stageWidth = 0;
            _this._stageHeight = 0;
            _this._scaler = 1;
            return _this;
        }
        Object.defineProperty(Egret2DRenderer.prototype, "screenAdapter", {
            get: function () {
                return this._screenAdapter;
            },
            set: function (adapter) {
                adapter.$dirty = true;
                this._screenAdapter = adapter;
            },
            enumerable: true,
            configurable: true
        });
        Egret2DRenderer.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.stage = new egret.Stage();
            this.stage.maxTouches = 98;
            this.root = new egret.DisplayObjectContainer();
            this.stage.addChild(this.root);
            if (!this._renderer) {
                this._renderer = egret.web.Renderer.getInstance(egret3d.WebGLCapabilities.webgl);
            }
            var stage = this.stage;
            var displayList = new egret.sys.DisplayList(stage);
            displayList.renderBuffer = new egret.sys.RenderBuffer(undefined, undefined, true);
            stage.$displayList = displayList;
            // TODO
            var webInput = paper.Application.systemManager.getSystem(egret3d.Egret2DRendererSystem).webInput;
            if (webInput) {
                egret.web.$cacheTextAdapter(webInput, stage, egret3d.WebGLCapabilities.canvas.parentNode, egret3d.WebGLCapabilities.canvas);
            }
            egret3d.InputManager.touch.addEventListener("touchstart", this._onTouchStart, this);
            egret3d.InputManager.touch.addEventListener("touchend", this._onTouchEnd, this);
            egret3d.InputManager.touch.addEventListener("touchcancel", this._onTouchEnd, this);
            egret3d.InputManager.touch.addEventListener("touchmove", this._onTouchMove, this);
            egret3d.InputManager.mouse.addEventListener("mousedown", this._onTouchStart, this);
            egret3d.InputManager.mouse.addEventListener("mouseup", this._onTouchEnd, this);
            egret3d.InputManager.mouse.addEventListener("mousemove", this._onTouchMove, this);
        };
        Egret2DRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            egret3d.InputManager.touch.removeEventListener("touchstart", this._onTouchStart, this);
            egret3d.InputManager.touch.removeEventListener("touchend", this._onTouchEnd, this);
            egret3d.InputManager.touch.removeEventListener("touchcancel", this._onTouchEnd, this);
            egret3d.InputManager.touch.removeEventListener("touchmove", this._onTouchMove, this);
            egret3d.InputManager.mouse.removeEventListener("mousedown", this._onTouchStart, this);
            egret3d.InputManager.mouse.removeEventListener("mouseup", this._onTouchEnd, this);
            egret3d.InputManager.mouse.removeEventListener("mousemove", this._onTouchMove, this);
            // this.stage.removeChild(this.root);
        };
        Egret2DRenderer.prototype.recalculateAABB = function () {
            // TODO
        };
        Egret2DRenderer.prototype.raycast = function (p1, p2, p3) {
            // TODO
            return false;
        };
        /**
         * 检查屏幕接触事件是否能够穿透此2D层
         */
        Egret2DRenderer.prototype.checkEventThrough = function (x, y) {
            return !!this._catchedEvent[x + "_" + y];
        };
        Egret2DRenderer.prototype._onTouchStart = function (event) {
            // console.log(event);
            if (this.stage.$onTouchBegin(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                this._catchedEvent[event.x + "_" + event.y] = true;
            }
        };
        Egret2DRenderer.prototype._onTouchMove = function (event) {
            // console.log(event);
            if (this.stage.$onTouchMove(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                this._catchedEvent[event.x + "_" + event.y] = true;
            }
        };
        Egret2DRenderer.prototype._onTouchEnd = function (event) {
            // console.log(event);
            if (this.stage.$onTouchEnd(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                this._catchedEvent[event.x + "_" + event.y] = true;
            }
        };
        /**
         * screen position to ui position
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 从屏幕坐标转换到当前2D系统的坐标
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Egret2DRenderer.prototype.screenPosToUIPos = function (pos, out) {
            if (out === void 0) { out = new egret3d.Vector2(); }
            out.x = pos.x / this._scaler;
            out.y = pos.y / this._scaler;
            return out;
        };
        Object.defineProperty(Egret2DRenderer.prototype, "scaler", {
            /**
             * 从屏幕坐标到当前2D系统的坐标的缩放系数
             */
            get: function () {
                return this._scaler;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        Egret2DRenderer.prototype.update = function (delta) {
            var stage2d = this.stage;
            var _a = egret3d.stage.screenViewport, w = _a.w, h = _a.h;
            if (this._stageWidth !== w || this._stageHeight !== h || this.screenAdapter.$dirty) {
                var result = { w: 0, h: 0, s: 0 };
                this.screenAdapter.calculateScaler(w, h, result);
                this.screenAdapter.$dirty = false;
                // this._scaler = this.root.scaleX = this.root.scaleY = result.s;
                stage2d.$displayList["offsetMatrix"].a = result.s;
                stage2d.$displayList["offsetMatrix"].d = result.s;
                this._scaler = result.s;
                var stageWidth = result.w;
                var stageHeight = result.h;
                stage2d.$stageWidth = stageWidth;
                stage2d.$stageHeight = stageHeight;
                // stage.$displayList.setClipRect(screenWidth, screenHeight);
                stage2d.pushResize(w, h);
                stage2d.dispatchEventWith(egret.Event.RESIZE);
                this._stageWidth = w;
                this._stageHeight = h;
            }
            // clear catched events
            this._catchedEvent = {};
        };
        /**
         * @internal
         */
        Egret2DRenderer.prototype.render = function (context, camera) {
            this._renderer.beforeRender();
            this.stage.drawToSurface();
            // WebGLRenderUtils.resetState(); // 清除3D渲染器中的标脏
        };
        return Egret2DRenderer;
    }(paper.BaseRenderer));
    egret3d.Egret2DRenderer = Egret2DRenderer;
    __reflect(Egret2DRenderer.prototype, "egret3d.Egret2DRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Egret2DRendererSystem = (function (_super) {
        __extends(Egret2DRendererSystem, _super);
        function Egret2DRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: egret3d.Egret2DRenderer }
            ];
            /**
             * TODO
             * @internal
             */
            _this.webInput = egret.Capabilities.runtimeType === egret.RuntimeType.WEB ? new egret["web"].HTMLInput() : null;
            return _this;
        }
        Egret2DRendererSystem.prototype.onAwake = function () {
            if (this.webInput) {
                this.webInput._initStageDelegateDiv(egret3d.WebGLCapabilities.canvas.parentNode, egret3d.WebGLCapabilities.canvas);
            }
        };
        Egret2DRendererSystem.prototype.onUpdate = function (deltaTime) {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                gameObject.getComponent(egret3d.Egret2DRenderer).update(deltaTime);
            }
        };
        return Egret2DRendererSystem;
    }(paper.BaseSystem));
    egret3d.Egret2DRendererSystem = Egret2DRendererSystem;
    __reflect(Egret2DRendererSystem.prototype, "egret3d.Egret2DRendererSystem");
})(egret3d || (egret3d = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var egret;
(function (egret) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var Renderer = (function () {
            function Renderer(context) {
                this.context = context;
                var egretWebGLRenderContext = this.egretWebGLRenderContext = egret.web.WebGLRenderContext.getInstance(0, 0);
                egretWebGLRenderContext.setContext(context);
                this.drawCmdManager = egretWebGLRenderContext.drawCmdManager;
                this.vao = egretWebGLRenderContext.vao;
                // egretWebGLRenderContext.drawFunc = this.$drawWebGL.bind(this);
                egretWebGLRenderContext.$drawWebGL = this.$drawWebGL.bind(this);
                egret.sys.RenderBuffer = egret.web.WebGLRenderBuffer;
                egret.sys.systemRenderer = new egret.web.WebGLRenderer();
                egret.sys.canvasRenderer = new egret.CanvasRenderer();
                egret.sys.customHitTestBuffer = new egret.web.WebGLRenderBuffer(3, 3);
                egret.sys.canvasHitTestBuffer = new egret.web.CanvasRenderBuffer(3, 3);
                egret.Capabilities['$renderMode'] = "webgl";
                this.vertexBuffer = context.createBuffer();
                this.indexBuffer = context.createBuffer();
                // app.addEventListener("beforeRender", function() {
                //     egret.ticker.update();
                // }, this);
            }
            Renderer.getInstance = function (context) {
                if (!this._instance) {
                    this._instance = new Renderer(context);
                }
                return this._instance;
            };
            Renderer.prototype.beforeRender = function () {
                var gl = this.context;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
                gl.enable(gl.BLEND);
                gl.disable(gl.STENCIL_TEST);
                gl.colorMask(true, true, true, true);
                this.setBlendMode("source-over");
                // 目前只使用0号材质单元，默认开启
                gl.activeTexture(gl.TEXTURE0);
                this.currentProgram = null;
            };
            Renderer.prototype.$drawWebGL = function () {
                if (this.drawCmdManager.drawDataLen == 0) {
                    return;
                }
                this.uploadVerticesArray(this.vao.getVertices());
                // 有mesh，则使用indicesForMesh
                if (this.vao.hasMesh) { //this.vao.isMesh()
                    this.uploadIndicesArray(this.vao.getMeshIndices());
                }
                var length = this.drawCmdManager.drawDataLen;
                var offset = 0;
                for (var i = 0; i < length; i++) {
                    var data = this.drawCmdManager.drawData[i];
                    if (!data) {
                        continue;
                    }
                    offset = this.drawData(data, offset);
                    // 计算draw call
                    if (data.type == 6 /* ACT_BUFFER */) {
                        this._activatedBuffer = data.buffer;
                        this.egretWebGLRenderContext.activatedBuffer = data.buffer;
                    }
                    if (data.type == 0 /* TEXTURE */ || data.type == 1 /* PUSH_MASK */ || data.type == 2 /* POP_MASK */) {
                        if (this._activatedBuffer && this._activatedBuffer.$computeDrawCall) {
                            this._activatedBuffer.$drawCalls++;
                        }
                    }
                }
                // 切换回默认indices
                if (this.vao.hasMesh) {//this.vao.isMesh()
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                // 清空数据
                this.drawCmdManager.clear();
                this.vao.clear();
            };
            /**
             * 执行绘制命令
             */
            Renderer.prototype.drawData = function (data, offset) {
                if (!data) {
                    return;
                }
                var gl = this.context;
                var program;
                var filter = data.filter;
                switch (data.type) {
                    case 0 /* TEXTURE */:
                        if (filter) {
                            if (filter.type === "custom") {
                                program = web.EgretWebGLProgram.getProgram(gl, filter.$vertexSrc, filter.$fragmentSrc, filter.$shaderKey);
                            }
                            else if (filter.type === "colorTransform") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.colorTransform_frag, "colorTransform");
                            }
                            else if (filter.type === "blurX") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "blurY") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "glow") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.glow_frag, "glow");
                            }
                        }
                        else {
                            program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.texture_frag, "texture");
                        }
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawTextureElements(data, offset);
                        break;
                    case 1 /* PUSH_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawPushMaskElements(data, offset);
                        break;
                    case 2 /* POP_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawPopMaskElements(data, offset);
                        break;
                    case 3 /* BLEND */:
                        this.setBlendMode(data.value);
                        break;
                    case 4 /* RESIZE_TARGET */:
                        data.buffer.rootRenderTarget.resize(data.width, data.height);
                        this.onResize(data.width, data.height);
                        break;
                    case 5 /* CLEAR_COLOR */:
                        if (this._activatedBuffer) {
                            var target = this._activatedBuffer.rootRenderTarget;
                            if (target.width != 0 || target.height != 0) {
                                target.clear(true);
                            }
                        }
                        break;
                    case 6 /* ACT_BUFFER */:
                        this.activateBuffer(data.buffer, data.width, data.height);
                        break;
                    case 7 /* ENABLE_SCISSOR */:
                        var buffer = this._activatedBuffer;
                        if (buffer) {
                            if (buffer.rootRenderTarget) {
                                buffer.rootRenderTarget.enabledStencil();
                            }
                            buffer.enableScissor(data.x, data.y, data.width, data.height);
                        }
                        break;
                    case 8 /* DISABLE_SCISSOR */:
                        buffer = this._activatedBuffer;
                        if (buffer) {
                            buffer.disableScissor();
                        }
                        break;
                    default:
                        break;
                }
                return offset;
            };
            Renderer.prototype.activeProgram = function (gl, program) {
                if (program != this.currentProgram) {
                    gl.useProgram(program.id);
                    // 目前所有attribute buffer的绑定方法都是一致的
                    var attribute = program.attributes;
                    for (var key in attribute) {
                        if (key === "aVertexPosition") {
                            gl.vertexAttribPointer(attribute["aVertexPosition"].location, 2, gl.FLOAT, false, 4 * 4, 0);
                            gl.enableVertexAttribArray(attribute["aVertexPosition"].location);
                        }
                        else if (key === "aTextureCoord") {
                            gl.vertexAttribPointer(attribute["aTextureCoord"].location, 2, gl.UNSIGNED_SHORT, true, 4 * 4, 2 * 4);
                            gl.enableVertexAttribArray(attribute["aTextureCoord"].location);
                        }
                        else if (key === "aColor") {
                            gl.vertexAttribPointer(attribute["aColor"].location, 1, gl.FLOAT, false, 4 * 4, 3 * 4);
                            gl.enableVertexAttribArray(attribute["aColor"].location);
                        }
                        else if (key === "aParticlePosition") {
                            gl.vertexAttribPointer(attribute["aParticlePosition"].location, 2, gl.FLOAT, false, 22 * 4, 0);
                            gl.enableVertexAttribArray(attribute["aParticlePosition"].location);
                        }
                        else if (key === "aParticleTextureCoord") {
                            gl.vertexAttribPointer(attribute["aParticleTextureCoord"].location, 2, gl.FLOAT, false, 22 * 4, 2 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleTextureCoord"].location);
                        }
                        else if (key === "aParticleScale") {
                            gl.vertexAttribPointer(attribute["aParticleScale"].location, 2, gl.FLOAT, false, 22 * 4, 4 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleScale"].location);
                        }
                        else if (key === "aParticleRotation") {
                            gl.vertexAttribPointer(attribute["aParticleRotation"].location, 2, gl.FLOAT, false, 22 * 4, 6 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleRotation"].location);
                        }
                        else if (key === "aParticleRed") {
                            gl.vertexAttribPointer(attribute["aParticleRed"].location, 2, gl.FLOAT, false, 22 * 4, 8 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleRed"].location);
                        }
                        else if (key === "aParticleGreen") {
                            gl.vertexAttribPointer(attribute["aParticleGreen"].location, 2, gl.FLOAT, false, 22 * 4, 10 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleGreen"].location);
                        }
                        else if (key === "aParticleBlue") {
                            gl.vertexAttribPointer(attribute["aParticleBlue"].location, 2, gl.FLOAT, false, 22 * 4, 12 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleBlue"].location);
                        }
                        else if (key === "aParticleAlpha") {
                            gl.vertexAttribPointer(attribute["aParticleAlpha"].location, 2, gl.FLOAT, false, 22 * 4, 14 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleAlpha"].location);
                        }
                        else if (key === "aParticleEmitRotation") {
                            gl.vertexAttribPointer(attribute["aParticleEmitRotation"].location, 2, gl.FLOAT, false, 22 * 4, 16 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleEmitRotation"].location);
                        }
                        else if (key === "aParticleEmitRadius") {
                            gl.vertexAttribPointer(attribute["aParticleEmitRadius"].location, 2, gl.FLOAT, false, 22 * 4, 18 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleEmitRadius"].location);
                        }
                        else if (key === "aParticleTime") {
                            gl.vertexAttribPointer(attribute["aParticleTime"].location, 2, gl.FLOAT, false, 22 * 4, 20 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleTime"].location);
                        }
                        //===== particle end =====
                    }
                    this.currentProgram = program;
                }
            };
            Renderer.prototype.syncUniforms = function (program, filter, data) {
                var uniforms = program.uniforms;
                for (var key in uniforms) {
                    if (key === "projectionVector") {
                        uniforms[key].setValue({ x: this.projectionX, y: this.projectionY });
                    }
                    else if (key === "uTextureSize") {
                        uniforms[key].setValue({ x: data.textureWidth, y: data.textureHeight });
                    }
                    else if (key === "uSampler") {
                    }
                    else if (key === "uGlobalMatrix") {
                        uniforms[key].setValue([data.a, data.c, data.tx, data.b, data.d, data.ty, 0, 0, 1]);
                    }
                    else if (key === "uGlobalAlpha") {
                        uniforms[key].setValue(data.alpha);
                    }
                    else {
                        var value = filter.$uniforms[key];
                        if (value !== undefined) {
                            uniforms[key].setValue(value);
                        }
                        else {
                            // egret.warn("filter custom: uniform " + key + " not defined!");
                        }
                    }
                }
            };
            /**
             * 画texture
             **/
            Renderer.prototype.drawTextureElements = function (data, offset) {
                var gl = this.context;
                gl.bindTexture(gl.TEXTURE_2D, data.texture);
                var size = data.count * 3;
                gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                return size;
            };
            /**
             * 启用RenderBuffer
             */
            Renderer.prototype.activateBuffer = function (buffer, width, height) {
                buffer.rootRenderTarget.activate();
                if (!this.bindIndices) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                buffer.restoreStencil();
                buffer.restoreScissor();
                this.onResize(width, height);
            };
            Renderer.prototype.onResize = function (width, height) {
                this.projectionX = width / 2;
                this.projectionY = -height / 2;
                if (this.context) {
                    this.context.viewport(0, 0, width, height);
                }
            };
            /**
             * 上传顶点数据
             */
            Renderer.prototype.uploadVerticesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ARRAY_BUFFER, array, gl.STREAM_DRAW);
            };
            /**
             * 上传索引数据
             */
            Renderer.prototype.uploadIndicesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);
                this.bindIndices = true;
            };
            /**
             * 画push mask
             **/
            Renderer.prototype.drawPushMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this._activatedBuffer;
                if (buffer) {
                    if (buffer.rootRenderTarget) {
                        buffer.rootRenderTarget.enabledStencil();
                    }
                    if (buffer.stencilHandleCount == 0) {
                        buffer.enableStencil();
                        gl.clear(gl.STENCIL_BUFFER_BIT); // clear
                    }
                    var level = buffer.stencilHandleCount;
                    buffer.stencilHandleCount++;
                    gl.colorMask(false, false, false, false);
                    gl.stencilFunc(gl.EQUAL, level, 0xFF);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                    // gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                    gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                    gl.colorMask(true, true, true, true);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                }
                return size;
            };
            /**
             * 画pop mask
             **/
            Renderer.prototype.drawPopMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this._activatedBuffer;
                if (buffer) {
                    buffer.stencilHandleCount--;
                    if (buffer.stencilHandleCount == 0) {
                        buffer.disableStencil(); // skip this draw
                    }
                    else {
                        var level = buffer.stencilHandleCount;
                        gl.colorMask(false, false, false, false);
                        gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                        // gl.bindTexture(gl.TEXTURE_2D, null);
                        gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                        gl.stencilFunc(gl.EQUAL, level, 0xFF);
                        gl.colorMask(true, true, true, true);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                    }
                }
                return size;
            };
            /**
             * 设置混色
             */
            Renderer.prototype.setBlendMode = function (value) {
                var gl = this.context;
                var blendModeWebGL = Renderer.blendModesForGL[value];
                if (blendModeWebGL) {
                    gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
                }
            };
            Renderer.initBlendMode = function () {
                Renderer.blendModesForGL = {};
                Renderer.blendModesForGL["source-over"] = [1, 771];
                Renderer.blendModesForGL["lighter"] = [1, 1];
                Renderer.blendModesForGL["lighter-in"] = [770, 771];
                Renderer.blendModesForGL["destination-out"] = [0, 771];
                Renderer.blendModesForGL["destination-in"] = [0, 770];
            };
            Renderer.blendModesForGL = null;
            return Renderer;
        }());
        web.Renderer = Renderer;
        __reflect(Renderer.prototype, "egret.web.Renderer");
        Renderer.initBlendMode();
    })(web = egret.web || (egret.web = {}));
})(egret || (egret = {}));
var egret3d;
(function (egret3d) {
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 恒定像素的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ConstantAdapter = (function () {
        function ConstantAdapter() {
            this.$dirty = true;
            this._scaleFactor = 1;
        }
        Object.defineProperty(ConstantAdapter.prototype, "scaleFactor", {
            /**
             * scaleFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置缩放值
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._scaleFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        ConstantAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler = this._scaleFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ConstantAdapter;
    }());
    egret3d.ConstantAdapter = ConstantAdapter;
    __reflect(ConstantAdapter.prototype, "egret3d.ConstantAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 拉伸扩展的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ExpandAdapter = (function () {
        function ExpandAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ExpandAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ExpandAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasHeight / this._resolution.y;
            }
            else {
                scaler = canvasWidth / this._resolution.x;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ExpandAdapter;
    }());
    egret3d.ExpandAdapter = ExpandAdapter;
    __reflect(ExpandAdapter.prototype, "egret3d.ExpandAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ShrinkAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 缩放的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ShrinkAdapter = (function () {
        function ShrinkAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ShrinkAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ShrinkAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasWidth / this._resolution.x;
            }
            else {
                scaler = canvasHeight / this._resolution.y;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ShrinkAdapter;
    }());
    egret3d.ShrinkAdapter = ShrinkAdapter;
    __reflect(ShrinkAdapter.prototype, "egret3d.ShrinkAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * MatchWidthOrHeightAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 适应宽高适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var MatchWidthOrHeightAdapter = (function () {
        function MatchWidthOrHeightAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
            this._matchFactor = 0; // width : height
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MatchWidthOrHeightAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        Object.defineProperty(MatchWidthOrHeightAdapter.prototype, "matchFactor", {
            /**
             * matchFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置匹配系数，0-1之间，越小越倾向以宽度适配，越大越倾向以高度适配。
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._matchFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        MatchWidthOrHeightAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler1 = canvasWidth / this._resolution.x;
            var scaler2 = canvasHeight / this._resolution.y;
            var scaler = scaler1 + (scaler2 - scaler1) * this._matchFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return MatchWidthOrHeightAdapter;
    }());
    egret3d.MatchWidthOrHeightAdapter = MatchWidthOrHeightAdapter;
    __reflect(MatchWidthOrHeightAdapter.prototype, "egret3d.MatchWidthOrHeightAdapter", ["egret3d.IScreenAdapter"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 实体。
     */
    var GameObject = (function (_super) {
        __extends(GameObject, _super);
        /**
         * 请使用 `paper.GameObject.create()` 创建实例。
         * @see paper.GameObject.create()
         * @deprecated
         */
        function GameObject(name, tag, scene) {
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (tag === void 0) { tag = "" /* Untagged */; }
            if (scene === void 0) { scene = null; }
            var _this = _super.call(this) || this;
            /**
             * 是否是静态模式。
             */
            _this.isStatic = false;
            /**
             *
             */
            _this.hideFlags = 0 /* None */;
            /**
             * 层级。
             * - 用于各种层遮罩。
             */
            _this.layer = 2 /* Default */;
            /**
             * 名称。
             */
            _this.name = "";
            /**
             * 标签。
             */
            _this.tag = "";
            /**
             * 变换组件。
             * @readonly
             */
            _this.transform = null;
            /**
             * 渲染组件。
             * @readonly
             */
            _this.renderer = null;
            /**
             * 额外数据，仅保存在编辑器环境，项目发布该数据将被移除。
             */
            _this.extras = paper.Application.playerMode === 2 /* Editor */ ? {} : undefined;
            _this._activeSelf = true;
            /**
             * @internal
             */
            _this._activeInHierarchy = true;
            /**
             * @internal
             */
            _this._activeDirty = true;
            _this._components = [];
            _this._cachedComponents = [];
            _this._scene = null;
            _this.name = name;
            _this.tag = tag;
            //
            _this._addToScene(scene || paper.Application.sceneManager.activeScene);
            //
            _this.addComponent(egret3d.Transform);
            return _this;
        }
        /**
         * 创建 GameObject，并添加到当前场景中。
         */
        GameObject.create = function (name, tag, scene) {
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (tag === void 0) { tag = "" /* Untagged */; }
            if (scene === void 0) { scene = null; }
            var gameObect;
            // if (this._instances.length > 0) {
            //     gameObect = this._instances.pop()!;
            //     gameObect.name = name;
            //     gameObect.tag = tag;
            //     gameObect._addToScene(scene);
            //     gameObect.addComponent(egret3d.Transform);
            // }
            // else {
            gameObect = new GameObject(name, tag, scene);
            // gameObect = new GameObject();
            // }
            // gameObect.name = name;
            // gameObect.tag = tag;
            // gameObect._addToScene(Application.sceneManager.activeScene);
            // gameObect.addComponent(egret3d.Transform);
            return gameObect;
        };
        GameObject._raycast = function (ray, gameObject, maxDistance, cullingMask, raycastMesh, raycastInfos) {
            if (maxDistance === void 0) { maxDistance = 0.0; }
            if (cullingMask === void 0) { cullingMask = 16777215 /* Everything */; }
            if (raycastMesh === void 0) { raycastMesh = false; }
            if ((gameObject.hideFlags === 3 /* HideAndDontSave */ && gameObject.tag === "Editor Only" /* EditorOnly */ &&
                (!gameObject.transform.parent || gameObject.transform.parent.gameObject.activeInHierarchy)) ? gameObject.activeSelf : !gameObject.activeInHierarchy) {
                return;
            }
            var raycastInfo = egret3d.RaycastInfo.create();
            raycastInfo.transform = null;
            raycastInfo.collider = null;
            if (gameObject.layer & cullingMask) {
                if (raycastMesh) {
                    if (gameObject.renderer && gameObject.renderer.enabled &&
                        gameObject.renderer.raycast(ray, raycastInfo, raycastMesh)) {
                        raycastInfo.transform = gameObject.transform;
                    }
                }
                else {
                    var boxCollider = gameObject.getComponent(egret3d.BoxCollider); // TODO 支持多碰撞区域
                    if (boxCollider) {
                        if (boxCollider.enabled && boxCollider.raycast(ray, raycastInfo)) {
                            raycastInfo.transform = gameObject.transform;
                            raycastInfo.collider = boxCollider;
                        }
                    }
                    else {
                        var sphereCollider = gameObject.getComponent(egret3d.SphereCollider); // TODO 支持多碰撞区域
                        if (sphereCollider) {
                            if (sphereCollider.enabled && sphereCollider.raycast(ray, raycastInfo)) {
                                raycastInfo.transform = gameObject.transform;
                                raycastInfo.collider = sphereCollider;
                            }
                        }
                    }
                }
            }
            if (raycastInfo.transform) {
                if (maxDistance <= 0.0 || raycastInfo.distance <= maxDistance) {
                    raycastInfos.push(raycastInfo);
                }
                else {
                    raycastInfo.transform = null;
                    raycastInfo.release();
                }
            }
            else {
                raycastInfo.transform = null;
                raycastInfo.release();
            }
            if (!raycastInfo.transform) {
                for (var _i = 0, _a = gameObject.transform.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    this._raycast(ray, child.gameObject, maxDistance, cullingMask, raycastMesh, raycastInfos);
                }
            }
        };
        GameObject._sortRaycastInfo = function (a, b) {
            // TODO renderQueue.
            return a.distance - b.distance;
        };
        /**
         * 用世界空间坐标系的射线检测指定的实体或变换组件列表。
         * @param ray 世界空间坐标系的射线。
         * @param gameObjectsOrTransforms 实体或变换组件列表。
         * @param maxDistance 最大相交点检测距离。（）
         * @param cullingMask 只对特定层的实体检测。
         * @param raycastMesh 是否检测网格。
         */
        GameObject.raycast = function (ray, gameObjectsOrTransforms, maxDistance, cullingMask, raycastMesh) {
            if (maxDistance === void 0) { maxDistance = 0.0; }
            if (cullingMask === void 0) { cullingMask = 16777215 /* Everything */; }
            if (raycastMesh === void 0) { raycastMesh = false; }
            var raycastInfos = [];
            for (var _i = 0, gameObjectsOrTransforms_1 = gameObjectsOrTransforms; _i < gameObjectsOrTransforms_1.length; _i++) {
                var gameObjectOrTransform = gameObjectsOrTransforms_1[_i];
                this._raycast(ray, gameObjectOrTransform instanceof GameObject ? gameObjectOrTransform : gameObjectOrTransform.gameObject, maxDistance, cullingMask, raycastMesh, raycastInfos);
            }
            raycastInfos.sort(this._sortRaycastInfo);
            return raycastInfos;
        };
        Object.defineProperty(GameObject, "globalGameObject", {
            /**
             * 全局实体。
             * - 全局实体不可被销毁。
             * - 静态组件都会添加到全局实体上。
             */
            get: function () {
                if (!this._globalGameObject) {
                    this._globalGameObject = GameObject.create("Global" /* Global */, "Global" /* Global */, paper.Application.sceneManager.globalScene);
                    this._globalGameObject.dontDestroy = true;
                }
                return this._globalGameObject;
            },
            enumerable: true,
            configurable: true
        });
        GameObject.prototype._destroy = function () {
            this._scene._removeGameObject(this);
            for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                child.gameObject._destroy();
            }
            for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                var component = _c[_b];
                if (!component) {
                    continue;
                }
                this._removeComponent(component, null);
            }
            GameObject.globalGameObject.getOrAddComponent(paper.DisposeCollecter).gameObjects.push(this);
            // 销毁的第一时间就将组件和场景清除，场景的有无来判断实体是否已经销毁。
            this._components.length = 0;
            this._scene = null;
        };
        GameObject.prototype._addToScene = function (value) {
            if (this._scene) {
                this._scene._removeGameObject(this);
            }
            this._scene = value;
            this._scene._addGameObject(this);
        };
        GameObject.prototype._canRemoveComponent = function (value) {
            if (value === this.transform) {
                console.warn("Cannot remove the transform component from a game object.");
                return false;
            }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (!component) {
                    continue;
                }
                if (component.constructor === paper.GroupComponent) {
                    component = component.components[0]; // 只检查第一个。
                }
                var requireComponents = component.constructor.requireComponents;
                if (requireComponents && requireComponents.indexOf(value.constructor) >= 0) {
                    console.warn("Cannot remove the " + egret.getQualifiedClassName(value) + " component from the game object (" + this.path + "), because it is required from the " + egret.getQualifiedClassName(component) + " component.");
                    return false;
                }
            }
            return true;
        };
        GameObject.prototype._removeComponent = function (value, groupComponent) {
            value.enabled = false;
            value.gameObject = null;
            if (value === this.renderer) {
                this.renderer = null;
            }
            GameObject.globalGameObject.getOrAddComponent(paper.DisposeCollecter).components.push(value);
            if (groupComponent) {
                groupComponent._removeComponent(value);
                if (groupComponent.components.length === 0) {
                    this._removeComponent(groupComponent, null);
                }
            }
            else if (value.constructor === paper.GroupComponent) {
                groupComponent = value;
                delete this._components[groupComponent.componentIndex];
                for (var _i = 0, _a = groupComponent.components; _i < _a.length; _i++) {
                    var componentInGroup = _a[_i];
                    this._removeComponent(componentInGroup, groupComponent);
                }
            }
            else {
                delete this._components[value.constructor.__index];
            }
        };
        GameObject.prototype._getComponent = function (componentClass) {
            var componentIndex = componentClass.__index;
            return componentIndex < 0 ? null : this._components[componentIndex];
        };
        /**
         * @internal
         */
        GameObject.prototype._activeInHierarchyDirty = function (prevActive) {
            this._activeDirty = true;
            var currentActive = this.activeInHierarchy;
            if (currentActive !== prevActive) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.enabled) {
                        paper.EventPool.dispatchEvent(currentActive ? "__enabled__" /* Enabled */ : "__disabled__" /* Disabled */, component);
                    }
                    if (component.constructor === paper.GroupComponent) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            if (componentInGroup.enabled) {
                                paper.EventPool.dispatchEvent(currentActive ? "__enabled__" /* Enabled */ : "__disabled__" /* Disabled */, componentInGroup);
                            }
                        }
                    }
                }
            }
            for (var _d = 0, _e = this.transform.children; _d < _e.length; _d++) {
                var child = _e[_d];
                child.gameObject._activeInHierarchyDirty(prevActive);
            }
        };
        /**
         * 实体被销毁后，内部卸载。
         * @internal
         */
        GameObject.prototype.uninitialize = function () {
            this.isStatic = false;
            this.hideFlags = 0 /* None */;
            this.layer = 2 /* Default */;
            this.name = "";
            this.tag = "";
            this.transform = null;
            this.renderer = null;
            if (this.extras) {
                this.extras = {};
            }
            this._activeSelf = true;
            this._activeInHierarchy = true;
            this._activeDirty = true;
            this._cachedComponents.length = 0;
            this._scene = null;
        };
        /**
         * 销毁实体。
         */
        GameObject.prototype.destroy = function () {
            if (this.isDestroyed) {
                console.warn("The game object has been destroyed.");
                return false;
            }
            if (this === GameObject._globalGameObject) {
                console.warn("Cannot destroy global game object.");
                return false;
            }
            var parent = this.transform.parent;
            if (parent) {
                parent._children.splice(parent._children.indexOf(this.transform), 1);
            }
            this._destroy();
            return true;
        };
        /**
         * 添加一个指定组件实例。
         * @param componentClass 组件类。
         * @param config Behaviour 组件 `onAwake(config?: any)` 的可选参数。
         */
        GameObject.prototype.addComponent = function (componentClass, config) {
            paper.registerClass(componentClass);
            // SingletonComponent.
            if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                return GameObject.globalGameObject.getOrAddComponent(componentClass, config);
            }
            var componentIndex = componentClass.__index;
            var existedComponent = this._components[componentIndex];
            // disallowMultipleComponents.
            if (!componentClass.allowMultiple && existedComponent) {
                console.warn("Cannot add the " + egret.getQualifiedClassName(componentClass) + " component to the game object (" + this.path + ") again.");
                return existedComponent;
            }
            // requireComponents.
            if (componentClass.requireComponents) {
                for (var _i = 0, _a = componentClass.requireComponents; _i < _a.length; _i++) {
                    var requireComponentClass = _a[_i];
                    this.getOrAddComponent(requireComponentClass);
                }
            }
            // Linked reference.
            var component = paper.BaseComponent.create(componentClass, this);
            if (componentClass === egret3d.Transform) {
                this.transform = component;
            }
            else if (component instanceof paper.BaseRenderer) {
                this.renderer = component;
            }
            // Add component.
            if (existedComponent) {
                if (existedComponent.constructor === paper.GroupComponent) {
                    existedComponent._addComponent(component);
                }
                else {
                    paper.registerClass(paper.GroupComponent);
                    var groupComponent = paper.BaseComponent.create(paper.GroupComponent, this);
                    groupComponent.initialize();
                    groupComponent.componentIndex = componentIndex;
                    groupComponent.componentClass = componentClass;
                    groupComponent._addComponent(existedComponent);
                    groupComponent._addComponent(component);
                    this._components[componentIndex] = groupComponent;
                }
            }
            else {
                this._components[componentIndex] = component;
            }
            if (config) {
                component.initialize(config);
            }
            else {
                component.initialize();
            }
            if (component.isActiveAndEnabled) {
                paper.EventPool.dispatchEvent("__enabled__" /* Enabled */, component);
            }
            return component;
        };
        /**
         * 移除一个指定组件实例。
         * @param componentInstanceOrClass 组件类或组件实例。
         * @param isExtends 是否尝试移除全部派生自此组件的实例。
         */
        GameObject.prototype.removeComponent = function (componentInstanceOrClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentInstanceOrClass instanceof paper.BaseComponent) {
                var componentClass = componentInstanceOrClass.constructor;
                // SingletonComponent.
                if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                    GameObject.globalGameObject.removeComponent(componentInstanceOrClass, isExtends);
                    return;
                }
                if (!this._canRemoveComponent(componentInstanceOrClass)) {
                    return;
                }
                this._removeComponent(componentInstanceOrClass, null);
            }
            else {
                // SingletonComponent.
                if (componentInstanceOrClass.__isSingleton && this !== GameObject._globalGameObject) {
                    return GameObject.globalGameObject.removeComponent(componentInstanceOrClass, isExtends);
                }
                if (isExtends) {
                    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (!component) {
                            continue;
                        }
                        var groupComponent = null;
                        if (component.constructor === paper.GroupComponent) {
                            groupComponent = component;
                            component = groupComponent.components[0];
                        }
                        if (groupComponent) {
                            if (!(groupComponent.components[0] instanceof componentInstanceOrClass) ||
                                (groupComponent.components.length === 1 && !this._canRemoveComponent(groupComponent.components[0]))) {
                                continue;
                            }
                        }
                        else if (!(component instanceof componentInstanceOrClass) ||
                            !this._canRemoveComponent(component)) {
                            continue;
                        }
                        this._removeComponent(component, groupComponent);
                    }
                }
                else {
                    var component = this._getComponent(componentInstanceOrClass);
                    if (!component) {
                        return;
                    }
                    var groupComponent = null;
                    if (component.constructor === paper.GroupComponent) {
                        groupComponent = component;
                        component = groupComponent.components[0];
                    }
                    if (groupComponent) {
                        if (groupComponent.components.length === 1 && !this._canRemoveComponent(groupComponent.components[0])) {
                            return;
                        }
                    }
                    else if (!this._canRemoveComponent(component)) {
                        return;
                    }
                    this._removeComponent(component, groupComponent);
                }
            }
        };
        /**
         * 移除全部指定组件的实例。
         * - 通常只有该组件类允许同一个实体添加多个组件实例时才需要此操作。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试移除全部派生自此组件的实例。
         */
        GameObject.prototype.removeAllComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentClass) {
                // SingletonComponent.
                if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                    GameObject.globalGameObject.removeAllComponents(componentClass, isExtends);
                    return;
                }
                if (isExtends) {
                    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (!component) {
                            continue;
                        }
                        if (component.constructor === paper.GroupComponent) {
                            var groupComponent = component;
                            if (!(groupComponent.components[0] instanceof componentClass) ||
                                !this._canRemoveComponent(groupComponent.components[0])) {
                                continue;
                            }
                        }
                        else if (!this._canRemoveComponent(component)) {
                            continue;
                        }
                        this._removeComponent(component, null);
                    }
                }
                else {
                    var component = this._getComponent(componentClass);
                    if (!component) {
                        return;
                    }
                    if (component.constructor === paper.GroupComponent) {
                        var groupComponent = component;
                        if (!this._canRemoveComponent(groupComponent.components[0])) {
                            return;
                        }
                    }
                    else if (!this._canRemoveComponent(component)) {
                        return;
                    }
                    this._removeComponent(component, null);
                }
            }
            else {
                for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                    var component = _c[_b];
                    if (!component || component.constructor === egret3d.Transform) {
                        continue;
                    }
                    this._removeComponent(component, null);
                }
            }
        };
        /**
         * 获取一个指定组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            // SingletonComponent.
            if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                return GameObject.globalGameObject.getComponent(componentClass, isExtends);
            }
            if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component_1 = _a[_i];
                    if (!component_1) {
                        continue;
                    }
                    if (component_1.constructor === paper.GroupComponent) {
                        var groupComponent = component_1;
                        if (groupComponent.components[0] instanceof componentClass) {
                            return groupComponent.components[0];
                        }
                    }
                    else if (component_1 instanceof componentClass) {
                        return component_1;
                    }
                }
                return null;
            }
            var componentClassIndex = componentClass.__index;
            if (componentClassIndex < 0) {
                return null;
            }
            var component = this._components[componentClassIndex];
            if (!component) {
                return null;
            }
            if (component.constructor === paper.GroupComponent) {
                return component.components[0];
            }
            return component;
        };
        /**
         * 获取全部指定组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            // SingletonComponent.
            if (componentClass.__isSingleton && this !== GameObject._globalGameObject) {
                return GameObject.globalGameObject.getComponents(componentClass, isExtends);
            }
            var components = [];
            if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.constructor === paper.GroupComponent && component.components[0] instanceof componentClass) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            components.push(componentInGroup);
                        }
                    }
                    else if (component instanceof componentClass) {
                        components.push(component);
                    }
                }
            }
            else {
                var component = this._getComponent(componentClass);
                if (component) {
                    if (component.constructor === paper.GroupComponent && component.components[0] instanceof componentClass) {
                        for (var _d = 0, _e = component.components; _d < _e.length; _d++) {
                            var componentInGroup = _e[_d];
                            components.push(componentInGroup);
                        }
                    }
                    else if (component instanceof componentClass) {
                        components.push(component);
                    }
                }
            }
            return components;
        };
        /**
         * 获取一个自己或父级中指定的组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponentInParent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var result = null;
            var parent = this.transform.parent;
            while (!result && parent) {
                result = parent.gameObject.getComponent(componentClass, isExtends); // 
                parent = parent.parent;
            }
            return result;
        };
        /**
         * 获取一个自己或子（孙）级中指定的组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponentInChildren = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var component = this.getComponent(componentClass, isExtends);
            if (!component) {
                for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    component = child.gameObject.getComponentInChildren(componentClass, isExtends);
                    if (component) {
                        break;
                    }
                }
            }
            return component;
        };
        /**
         * 获取全部自己和子（孙）级中指定的组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponentsInChildren = function (componentClass, isExtends, components) {
            if (isExtends === void 0) { isExtends = false; }
            if (components === void 0) { components = null; }
            components = components || [];
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (!component) {
                    continue;
                }
                if (component.constructor === paper.GroupComponent) {
                    var groupComponent = component;
                    if (isExtends ? groupComponent.components[0] instanceof componentClass : groupComponent.componentClass === componentClass) {
                        for (var _b = 0, _c = groupComponent.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            components.push(componentInGroup);
                        }
                    }
                }
                else if (isExtends ? component instanceof componentClass : component.constructor === componentClass) {
                    components.push(component);
                }
            }
            for (var _d = 0, _e = this.transform.children; _d < _e.length; _d++) {
                var child = _e[_d];
                child.gameObject.getComponentsInChildren(componentClass, isExtends, components);
            }
            return components;
        };
        /**
         * 从该实体已注册的全部组件中获取一个指定组件实例，如果未添加该组件，则添加该组件。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getOrAddComponent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            return this.getComponent(componentClass, isExtends) || this.addComponent(componentClass, isExtends);
        };
        /**
         * 向该实体已激活的全部 Behaviour 组件发送消息。
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.sendMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (component && component.isActiveAndEnabled && component.constructor instanceof paper.Behaviour) {
                    if (methodName in component) {
                        component[methodName](parameter);
                    }
                    else if (requireReceiver) {
                        console.warn(this.name, egret.getQualifiedClassName(component), methodName); // TODO
                    }
                }
            }
        };
        /**
         * 向该实体和其父级的 Behaviour 组件发送消息。
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.sendMessageUpwards = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            this.sendMessage(methodName, parameter, requireReceiver);
            //
            var parent = this.transform.parent;
            if (parent && parent.gameObject.activeInHierarchy) {
                parent.gameObject.sendMessage(methodName, parameter, requireReceiver);
            }
        };
        /**
         * 向该实体和的其子（孙）级的 Behaviour 组件发送消息。
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.broadcastMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            this.sendMessage(methodName, parameter, requireReceiver);
            for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child.gameObject.activeInHierarchy) {
                    child.gameObject.broadcastMessage(methodName, parameter, requireReceiver);
                }
            }
        };
        Object.defineProperty(GameObject.prototype, "isDestroyed", {
            /**
             * 该实体是否已经被销毁。
             */
            get: function () {
                return !this._scene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "dontDestroy", {
            /**
             * 该实体是否可以被销毁。
             * - 当此值为 `true` 时，将会被添加到全局场景，反之将被添加到激活场景。
             * - 设置此属性时，可能改变该实体的父级。
             */
            get: function () {
                return this._scene === paper.Application.sceneManager.globalScene;
            },
            set: function (value) {
                if (this.dontDestroy === value) {
                    return;
                }
                if (this.transform.parent && this.transform.parent.gameObject.dontDestroy !== value) {
                    this.transform.parent = null;
                }
                if (value) {
                    this._addToScene(paper.Application.sceneManager.globalScene);
                }
                else {
                    if (this === GameObject._globalGameObject) {
                        console.warn("Cannot change the `dontDestroy` value of the global game object.", this.name, this.uuid);
                        return;
                    }
                    this._addToScene(paper.Application.sceneManager.activeScene);
                }
                for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child.gameObject.dontDestroy = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "activeSelf", {
            /**
             * 该实体自身的激活状态。
             */
            get: function () {
                return this._activeSelf;
            },
            set: function (value) {
                if (this._activeSelf === value) {
                    return;
                }
                var parent = this.transform.parent;
                if (!parent || parent.gameObject.activeInHierarchy) {
                    var prevActive = this._activeSelf;
                    this._activeSelf = value;
                    this._activeInHierarchyDirty(prevActive);
                }
                else {
                    this._activeSelf = value; //TODO
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "activeInHierarchy", {
            /**
             * 该实体在场景中的激活状态。
             */
            get: function () {
                if (this._activeDirty) {
                    var parent_1 = this.transform.parent;
                    if (!parent_1 || parent_1.gameObject.activeInHierarchy) {
                        this._activeInHierarchy = this._activeSelf;
                    }
                    else {
                        this._activeInHierarchy = false;
                    }
                    this._activeDirty = false;
                }
                return this._activeInHierarchy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "path", {
            /**
             * 该实体的路径。
             */
            get: function () {
                var path = this.name;
                if (this.transform) {
                    var parent_2 = this.transform.parent;
                    while (parent_2) {
                        path = parent_2.gameObject.name + "/" + path;
                        parent_2 = parent_2.parent;
                    }
                    return this._scene.name + "/" + path;
                }
                return path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "components", {
            /**
             * 该实体已添加的全部组件。
             */
            get: function () {
                this._cachedComponents.length = 0;
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.constructor === paper.GroupComponent) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            this._cachedComponents.push(componentInGroup);
                        }
                    }
                    else {
                        this._cachedComponents.push(component);
                    }
                }
                return this._cachedComponents;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "parent", {
            /**
             * 该实体的父级。
             */
            get: function () {
                return this.transform.parent ? this.transform.parent.gameObject : null;
            },
            set: function (gameObject) {
                this.transform.parent = gameObject ? gameObject.transform : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "scene", {
            /**
             * 该实体所属的场景。
             */
            get: function () {
                return this._scene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "globalGameObject", {
            /**
             * 全局实体。
             * - 全局实体不可被销毁。
             * - 静态组件都会添加到全局实体上。
             */
            get: function () {
                return GameObject.globalGameObject;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         * @see paper.Scene#find()
         */
        GameObject.find = function (name, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).find(name);
        };
        /**
         * @deprecated
         * @see paper.Scene#findWithTag()
         */
        GameObject.findWithTag = function (tag, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).findWithTag(tag);
        };
        /**
         * @deprecated
         * @see paper.Scene#findGameObjectsWithTag()
         */
        GameObject.findGameObjectsWithTag = function (tag, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).findGameObjectsWithTag(tag);
        };
        /**
         * @internal
         */
        GameObject._instances = [];
        GameObject._globalGameObject = null;
        __decorate([
            paper.serializedField,
            paper.editor.property(4 /* CHECKBOX */)
        ], GameObject.prototype, "isStatic", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "hideFlags", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(10 /* LIST */, { listItems: paper.editor.getItemsFromEnum(paper.Layer) })
        ], GameObject.prototype, "layer", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(3 /* TEXT */)
        ], GameObject.prototype, "name", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(10 /* LIST */, { listItems: paper.editor.getItemsFromEnum(paper.DefaultTags) })
        ], GameObject.prototype, "tag", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "extras", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "_activeSelf", void 0);
        __decorate([
            paper.editor.property(4 /* CHECKBOX */)
        ], GameObject.prototype, "activeSelf", null);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], GameObject.prototype, "components", null);
        return GameObject;
    }(paper.BaseObject));
    paper.GameObject = GameObject;
    __reflect(GameObject.prototype, "paper.GameObject");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DirectionalLight = (function (_super) {
        __extends(DirectionalLight, _super);
        function DirectionalLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.renderTarget = new egret3d.GlRenderTarget("DirectionalLight", 1024, 1024, true); // TODO
            return _this;
        }
        DirectionalLight.prototype.update = function (camera, faceIndex) {
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.size = this.shadowCameraSize;
            camera.fov = Math.PI * 0.25;
            camera.opvalue = 0.0;
            _super.prototype.update.call(this, camera, faceIndex);
        };
        return DirectionalLight;
    }(egret3d.BaseLight));
    egret3d.DirectionalLight = DirectionalLight;
    __reflect(DirectionalLight.prototype, "egret3d.DirectionalLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _targets = [
        new egret3d.Vector3(-1, 0, 0), new egret3d.Vector3(1, 0, 0), new egret3d.Vector3(0, 1, 0),
        new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, 0, 1), new egret3d.Vector3(0, 0, -1)
    ];
    var _ups = [
        new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, 0, 1),
        new egret3d.Vector3(0, 0, -1), new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, -1, 0)
    ];
    /**
     *
     */
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        function PointLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.decay = 2.0;
            /**
             *
             */
            _this.distance = 0.0;
            _this.renderTarget = new egret3d.GlRenderTarget("PointLight", 1024, 1024, true); // TODO
            return _this;
        }
        PointLight.prototype.update = function (camera, faceIndex) {
            var position = this.gameObject.transform.getPosition();
            egret3d.helpVector3A.set(position.x + _targets[faceIndex].x, position.y + _targets[faceIndex].y, position.z + _targets[faceIndex].z);
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.size = this.shadowCameraSize;
            camera.fov = Math.PI * 0.5;
            camera.opvalue = 1.0;
            camera.gameObject.transform.setPosition(position); // TODO support copy matrix.
            camera.gameObject.transform.setRotation(this.gameObject.transform.getRotation());
            camera.gameObject.transform.lookAt(egret3d.helpVector3A, _ups[faceIndex]);
            _super.prototype.update.call(this, camera, faceIndex);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0 })
        ], PointLight.prototype, "decay", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0 })
        ], PointLight.prototype, "distance", void 0);
        return PointLight;
    }(egret3d.BaseLight));
    egret3d.PointLight = PointLight;
    __reflect(PointLight.prototype, "egret3d.PointLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var SpotLight = (function (_super) {
        __extends(SpotLight, _super);
        function SpotLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.decay = 2.0;
            /**
             *
             */
            _this.distance = 0.0;
            /**
             *
             */
            _this.angle = Math.PI / 3.0;
            /**
             *
             */
            _this.penumbra = 0.0;
            return _this;
        }
        SpotLight.prototype.update = function (camera, faceIndex) {
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.size = this.shadowCameraSize;
            camera.fov = this.angle;
            camera.opvalue = 1.0;
            camera.gameObject.transform.getWorldMatrix().copy(this.gameObject.transform.getWorldMatrix()); //
            _super.prototype.update.call(this, camera, faceIndex);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0 })
        ], SpotLight.prototype, "decay", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0 })
        ], SpotLight.prototype, "distance", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */)
        ], SpotLight.prototype, "angle", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.01 })
        ], SpotLight.prototype, "penumbra", void 0);
        return SpotLight;
    }(egret3d.BaseLight));
    egret3d.SpotLight = SpotLight;
    __reflect(SpotLight.prototype, "egret3d.SpotLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var MeshFilterEventType;
    (function (MeshFilterEventType) {
        MeshFilterEventType["Mesh"] = "mesh";
    })(MeshFilterEventType = egret3d.MeshFilterEventType || (egret3d.MeshFilterEventType = {}));
    /**
     * MeshFilter 组件
     */
    var MeshFilter = (function (_super) {
        __extends(MeshFilter, _super);
        function MeshFilter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._mesh = null;
            return _this;
        }
        MeshFilter.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._mesh) {
                // this._mesh.dispose(); //TODO shaderdMesh暂时没法dispose
            }
            this._mesh = null;
        };
        Object.defineProperty(MeshFilter.prototype, "mesh", {
            /**
             * 组件挂载的 mesh 模型
             */
            get: function () {
                return this._mesh;
            },
            set: function (value) {
                if (this._mesh === value) {
                    return;
                }
                if (this._mesh) {
                    // this._mesh.dispose();//TODO shaderdMesh暂时没法dispose
                }
                this._mesh = value;
                paper.EventPool.dispatchEvent("mesh" /* Mesh */, this);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], MeshFilter.prototype, "_mesh", void 0);
        __decorate([
            paper.editor.property(18 /* MESH */)
        ], MeshFilter.prototype, "mesh", null);
        return MeshFilter;
    }(paper.BaseComponent));
    egret3d.MeshFilter = MeshFilter;
    __reflect(MeshFilter.prototype, "egret3d.MeshFilter");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 雾的模式。
     */
    var FogMode;
    (function (FogMode) {
        FogMode[FogMode["NONE"] = 0] = "NONE";
        FogMode[FogMode["FOG"] = 1] = "FOG";
        FogMode[FogMode["FOG_EXP2"] = 2] = "FOG_EXP2";
    })(FogMode = paper.FogMode || (paper.FogMode = {}));
    /**
     * 场景。
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        /**
         * 请使用 `paper.Scene.createEmpty()` 创建实例。
         * @see paper.Scene.createEmpty()
         * @see paper.Scene.create()
         */
        function Scene(name) {
            var _this = _super.call(this) || this;
            /**
             * Light map 表现的光照强度。
             */
            _this.lightmapIntensity = 1.0;
            /**
             * 名称。
             */
            _this.name = "";
            /**
             * 环境光。
             */
            _this.ambientColor = egret3d.Color.create(0.20, 0.20, 0.25, 1);
            /**
             * Light map 列表。
             */
            _this.lightmaps = [];
            /**
             * 雾的模式。
             */
            _this.fogMode = 0 /* NONE */;
            /**
             * 雾的颜色。
             */
            _this.fogColor = egret3d.Color.create(0.5, 0.5, 0.5, 1);
            /**
             *
             */
            _this.fogDensity = 0.01;
            /**
             *
             */
            _this.fogNear = 0.001;
            /**
             *
             */
            _this.fogFar = 100.0;
            /**
             * 额外数据，仅保存在编辑器环境，项目发布该数据将被移除。
             */
            _this.extras = paper.Application.playerMode === 2 /* Editor */ ? {} : undefined;
            /**
             * TODO
             * @internal
             */
            _this._gameObjects = [];
            _this.name = name;
            return _this;
        }
        /**
         * 创建空场景。
         */
        Scene.createEmpty = function (name, isActive) {
            // const exScene = Application.sceneManager.getSceneByName(name); TODO
            // if (exScene) {
            //     console.warn("The scene with the same name already exists.");
            //     return exScene;
            // }
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (isActive === void 0) { isActive = true; }
            var scene = new Scene(name);
            paper.Application.sceneManager._addScene(scene, isActive);
            return scene;
        };
        /**
         * 通过创建资源创建指定场景。
         */
        Scene.create = function (name, combineStaticObjects) {
            if (combineStaticObjects === void 0) { combineStaticObjects = true; }
            var exScene = paper.Application.sceneManager.getScene(name);
            if (exScene) {
                console.warn("The scene with the same name already exists.");
                return exScene;
            }
            var rawScene = paper.Asset.find(name);
            if (rawScene && rawScene instanceof paper.RawScene) {
                var scene = rawScene.createInstance();
                if (scene) {
                    if (combineStaticObjects && paper.Application.playerMode !== 2 /* Editor */) {
                        egret3d.combine(scene.gameObjects);
                    }
                    return scene;
                }
            }
            else {
                console.warn("The scene don't exists.", name);
            }
            return null;
        };
        Object.defineProperty(Scene, "globalScene", {
            /**
             * 全局静态场景。
             */
            get: function () {
                return paper.Application.sceneManager.globalScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene, "editorScene", {
            /**
             *
             */
            get: function () {
                return paper.Application.sceneManager.editorScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene, "activeScene", {
            /**
             * 当前激活场景。
             */
            get: function () {
                return paper.Application.sceneManager.activeScene;
            },
            set: function (value) {
                paper.Application.sceneManager.activeScene = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @internal
         */
        Scene.prototype._addGameObject = function (gameObject) {
            if (this._gameObjects.indexOf(gameObject) >= 0) {
                console.warn("Add game object error.", gameObject.path);
            }
            this._gameObjects.push(gameObject);
        };
        /**
         * @internal
         */
        Scene.prototype._removeGameObject = function (gameObject) {
            var index = this._gameObjects.indexOf(gameObject);
            if (index < 0) {
                console.warn("Remove game object error.", gameObject.path);
            }
            this._gameObjects.splice(index, 1);
        };
        /**
         * @internal
         */
        Scene.prototype.uninitialize = function () {
            this.lightmapIntensity = 1.0;
            // this.name = "";
            this.ambientColor.set(0.20, 0.20, 0.25, 1);
            this.lightmaps.length = 0;
            // this.extras
        };
        /**
         * 销毁该场景和场景中的全部实体。
         */
        Scene.prototype.destroy = function () {
            if (!paper.Application.sceneManager._removeScene(this)) {
                return false;
            }
            var i = this._gameObjects.length;
            while (i--) {
                var gameObject = this._gameObjects[i];
                if (!gameObject || gameObject.transform.parent) {
                    continue;
                }
                gameObject.destroy();
            }
            //
            this._gameObjects.length = 0;
            paper.GameObject.globalGameObject.getOrAddComponent(paper.DisposeCollecter).scenes.push(this);
            return true;
        };
        /**
         * 获取该场景指定名称或路径的实体。
         * - 只返回第一个符合的实体。
         */
        Scene.prototype.find = function (nameOrPath) {
            var index = nameOrPath.indexOf("/");
            if (index > 0) {
                var firstName = nameOrPath.slice(0, index);
                for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    if (gameObject.name === firstName) {
                        var child = gameObject.transform.find(nameOrPath.slice(index + 1));
                        return child ? child.gameObject : null;
                    }
                }
            }
            else {
                for (var _b = 0, _c = this._gameObjects; _b < _c.length; _b++) {
                    var gameObject = _c[_b];
                    if (gameObject.name === nameOrPath) {
                        return gameObject;
                    }
                }
            }
            return null;
        };
        /**
         * 获取指定该场景标识的实体。
         * - 只返回第一个符合的实体。
         */
        Scene.prototype.findWithTag = function (tag) {
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.tag === tag) {
                    return gameObject;
                }
            }
            return null;
        };
        /**
         * 获取该场景指定标识的实体。
         * - 返回全部符合的实体。
         */
        Scene.prototype.findGameObjectsWithTag = function (tag) {
            var gameObjects = [];
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.tag === tag) {
                    gameObjects.push(gameObject);
                }
            }
            return gameObjects;
        };
        /**
         * 该场景当前的全部根实体。
         */
        Scene.prototype.getRootGameObjects = function () {
            var gameObjects = [];
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (!gameObject.transform.parent) {
                    gameObjects.push(gameObject);
                }
            }
            return gameObjects;
        };
        Object.defineProperty(Scene.prototype, "gameObjectCount", {
            /**
             * 该场景当前的实体总数。
             */
            get: function () {
                return this._gameObjects.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene.prototype, "gameObjects", {
            /**
             * 该场景当前的全部实体。
             */
            get: function () {
                return this._gameObjects;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0 })
        ], Scene.prototype, "lightmapIntensity", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "name", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(9 /* COLOR */)
        ], Scene.prototype, "ambientColor", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "lightmaps", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(10 /* LIST */, { listItems: paper.editor.getItemsFromEnum(paper.FogMode) })
        ], Scene.prototype, "fogMode", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(9 /* COLOR */)
        ], Scene.prototype, "fogColor", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.0 })
        ], Scene.prototype, "fogDensity", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.001, step: 1.0 })
        ], Scene.prototype, "fogNear", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(2 /* FLOAT */, { minimum: 0.001, step: 1.0 })
        ], Scene.prototype, "fogFar", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "extras", void 0);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Scene.prototype, "gameObjects", null);
        return Scene;
    }(paper.BaseObject));
    paper.Scene = Scene;
    __reflect(Scene.prototype, "paper.Scene");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var MeshRendererSystem = (function (_super) {
        __extends(MeshRendererSystem, _super);
        function MeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: egret3d.MeshFilter,
                    listeners: [
                        {
                            type: "mesh" /* Mesh */, listener: function (component) {
                                _this._updateDrawCalls(component.gameObject);
                                if (component.gameObject.renderer) {
                                    component.gameObject.renderer._aabbDirty = true;
                                }
                            }
                        }
                    ]
                },
                {
                    componentClass: egret3d.MeshRenderer,
                    listeners: [
                        { type: "materials" /* Materials */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } }
                    ]
                },
            ];
            _this._drawCalls = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.DrawCalls);
            return _this;
        }
        MeshRendererSystem.prototype._updateDrawCalls = function (gameObject) {
            if (!this._enabled || !this._groups[0].hasGameObject(gameObject)) {
                return;
            }
            var filter = gameObject.getComponent(egret3d.MeshFilter);
            var renderer = gameObject.renderer;
            var materials = renderer.materials;
            this._drawCalls.removeDrawCalls(renderer);
            if (!filter.mesh || materials.length === 0) {
                return;
            }
            filter.mesh._createBuffer();
            this._drawCalls.renderers.push(renderer);
            //
            var subMeshIndex = 0;
            for (var _i = 0, _a = filter.mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var drawCall = {
                    renderer: renderer,
                    subMeshIndex: subMeshIndex++,
                    mesh: filter.mesh,
                    material: materials[primitive.material] || egret3d.DefaultMaterials.MISSING,
                    zdist: -1,
                };
                this._drawCalls.drawCalls.push(drawCall);
            }
        };
        MeshRendererSystem.prototype.onEnable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._updateDrawCalls(gameObject);
            }
        };
        MeshRendererSystem.prototype.onAddGameObject = function (gameObject) {
            this._updateDrawCalls(gameObject);
        };
        MeshRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            this._drawCalls.removeDrawCalls(gameObject.renderer);
        };
        MeshRendererSystem.prototype.onDisable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._drawCalls.removeDrawCalls(gameObject.renderer);
            }
        };
        return MeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.MeshRendererSystem = MeshRendererSystem;
    __reflect(MeshRendererSystem.prototype, "egret3d.MeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpVector3C = egret3d.Vector3.create();
    var _helpMatrix = egret3d.Matrix4.create();
    /**
     * Skinned Mesh Renderer Component
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 蒙皮网格的渲染组件
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var SkinnedMeshRenderer = (function (_super) {
        __extends(SkinnedMeshRenderer, _super);
        function SkinnedMeshRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 强制使用 cpu 蒙皮。
             * - 骨骼数超过硬件支持的最大骨骼数量，或顶点权重大于 4 个，需要使用 CPU 蒙皮。
             */
            _this.forceCPUSkin = false;
            /**
             *
             */
            _this.boneMatrices = null;
            _this._bones = [];
            _this._rootBone = null;
            _this._inverseBindMatrices = null;
            /**
             * @internal
             */
            _this._retargetBoneNames = null;
            _this._mesh = null;
            _this._rawVertices = null;
            return _this;
        }
        /**
         * @internal
         */
        SkinnedMeshRenderer.prototype._update = function () {
            var bones = this._bones;
            var inverseBindMatrices = this._inverseBindMatrices;
            var boneMatrices = this.boneMatrices;
            for (var i = 0, l = bones.length; i < l; ++i) {
                var offset = i * 16;
                var bone = bones[i];
                var matrix = bone ? bone.getWorldMatrix() : egret3d.Matrix4.IDENTITY;
                _helpMatrix.fromArray(inverseBindMatrices, offset).premultiply(matrix).toArray(boneMatrices, offset);
            }
            if (this.forceCPUSkin) {
                var vA = _helpVector3A;
                var vB = _helpVector3A;
                var vC = _helpVector3C;
                var mA = _helpMatrix;
                var indices = this._mesh.getIndices();
                var vertices = this._mesh.getVertices();
                var joints = this._mesh.getAttributes("JOINTS_0" /* JOINTS_0 */);
                var weights = this._mesh.getAttributes("WEIGHTS_0" /* WEIGHTS_0 */);
                if (!this._rawVertices) {
                    this._rawVertices = new Float32Array(vertices.length);
                    this._rawVertices.set(vertices);
                }
                for (var _i = 0, _a = indices; _i < _a.length; _i++) {
                    var index = _a[_i];
                    var vertexIndex = index * 3;
                    var jointIndex = index * 4;
                    vA.fromArray(this._rawVertices, vertexIndex);
                    vB.set(0.0, 0.0, 0.0)
                        .add(vC.applyMatrix(mA.fromArray(boneMatrices, joints[jointIndex + 0] * 16), vA).multiplyScalar(weights[jointIndex + 0]))
                        .add(vC.applyMatrix(mA.fromArray(boneMatrices, joints[jointIndex + 1] * 16), vA).multiplyScalar(weights[jointIndex + 1]))
                        .add(vC.applyMatrix(mA.fromArray(boneMatrices, joints[jointIndex + 2] * 16), vA).multiplyScalar(weights[jointIndex + 2]))
                        .add(vC.applyMatrix(mA.fromArray(boneMatrices, joints[jointIndex + 3] * 16), vA).multiplyScalar(weights[jointIndex + 3]))
                        .toArray(vertices, vertexIndex);
                }
                this._mesh.uploadVertexBuffer();
            }
        };
        SkinnedMeshRenderer.prototype.initialize = function (reset) {
            _super.prototype.initialize.call(this, reset);
            if (!reset) {
                return;
            }
            this._bones.length = 0;
            this._rootBone = null;
            this.boneMatrices = null;
            this._inverseBindMatrices = null;
            if (this._mesh) {
                var config = this._mesh.config;
                var skin = config.skins[0];
                var children = this.gameObject.transform.parent.getAllChildren({});
                if (skin.skeleton !== undefined) {
                    var rootNode = config.nodes[skin.skeleton];
                    if (rootNode.name in children) {
                        var transforms = children[rootNode.name];
                        this._rootBone = Array.isArray(transforms) ? transforms[0] : transforms;
                    }
                }
                for (var _i = 0, _a = skin.joints; _i < _a.length; _i++) {
                    var joint = _a[_i];
                    var node = config.nodes[joint];
                    if (node.name in children) {
                        var transforms = children[node.name];
                        this._bones.push(Array.isArray(transforms) ? transforms[0] : transforms);
                    }
                    else {
                        this._bones.push(null);
                    }
                }
                this._inverseBindMatrices = this._mesh.createTypeArrayFromAccessor(this._mesh.getAccessor(skin.inverseBindMatrices));
                this.boneMatrices = new Float32Array(this._bones.length * 16);
                if (this._bones.length > egret3d.SkinnedMeshRendererSystem.maxBoneCount) {
                    // TODO
                    this.forceCPUSkin = true;
                    console.warn("");
                }
                // this._update(); TODO
            }
        };
        SkinnedMeshRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            // TODO
            if (this._mesh) {
                // this._mesh.dispose();
            }
            this._bones.length = 0;
            this._rootBone = null;
            this.boneMatrices = null;
            this._inverseBindMatrices = null;
            this._retargetBoneNames = null;
            this._mesh = null;
        };
        SkinnedMeshRenderer.prototype.recalculateAABB = function () {
            // TODO
            if (this._mesh) {
                this._aabb.clear();
                var vertices = this._mesh.getVertices(); // T pose mesh aabb.
                var position = egret3d.helpVector3A;
                for (var i = 0, l = vertices.length; i < l; i += 3) {
                    position.set(vertices[i], vertices[i + 1], vertices[i + 2]);
                    this._aabb.add(position);
                }
            }
        };
        SkinnedMeshRenderer.prototype.raycast = function (p1, p2, p3) {
            if (!this._mesh) {
                return false;
            }
            var raycastMesh = false;
            var raycastInfo = undefined;
            var worldMatrix = this.gameObject.transform.worldMatrix;
            var localRay = egret3d.MeshRenderer._helpRay.applyMatrix(_helpMatrix.inverse(worldMatrix), p1); // TODO transform inverse world matrix.
            var aabb = this.aabb;
            if (p2) {
                if (p2 === true) {
                    raycastMesh = true;
                }
                else {
                    raycastMesh = p3 || false;
                    raycastInfo = p2;
                }
            }
            if (raycastMesh) {
                return aabb.raycast(localRay) && this._mesh.raycast(p1, raycastInfo, this.forceCPUSkin ? null : this.boneMatrices);
            }
            else if (aabb.raycast(localRay, raycastInfo)) {
                if (raycastInfo) {
                    raycastInfo.position.applyMatrix(worldMatrix);
                    raycastInfo.distance = p1.origin.getDistance(raycastInfo.position);
                }
                return true;
            }
            return false;
        };
        Object.defineProperty(SkinnedMeshRenderer.prototype, "bones", {
            get: function () {
                return this._bones;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "rootBone", {
            get: function () {
                return this._rootBone;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "mesh", {
            /**
             *
             */
            get: function () {
                return this._mesh;
            },
            set: function (mesh) {
                if (mesh && !mesh.config.scenes && !mesh.config.nodes && !mesh.config.skins) {
                    console.warn("Invalid skinned mesh.", mesh.name);
                    return;
                }
                if (this._mesh === mesh) {
                    return;
                }
                if (this._mesh) {
                    // this._mesh.dispose(); TODO
                }
                this._mesh = mesh;
                paper.EventPool.dispatchEvent("mesh" /* Mesh */, this);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "_mesh", void 0);
        return SkinnedMeshRenderer;
    }(egret3d.MeshRenderer));
    egret3d.SkinnedMeshRenderer = SkinnedMeshRenderer;
    __reflect(SkinnedMeshRenderer.prototype, "egret3d.SkinnedMeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * TODO 需要完善
     */
    var SkinnedMeshRendererSystem = (function (_super) {
        __extends(SkinnedMeshRendererSystem, _super);
        function SkinnedMeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: egret3d.SkinnedMeshRenderer,
                    listeners: [
                        {
                            type: "mesh" /* Mesh */, listener: function (component) {
                                _this._updateDrawCalls(component.gameObject);
                                if (component.gameObject.renderer) {
                                    component.gameObject.renderer._aabbDirty = true;
                                }
                            }
                        },
                        { type: "materials" /* Materials */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } },
                    ]
                }
            ];
            _this._drawCalls = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.DrawCalls);
            return _this;
        }
        SkinnedMeshRendererSystem.prototype._updateDrawCalls = function (gameObject) {
            if (!this._enabled || !this._groups[0].hasGameObject(gameObject)) {
                return;
            }
            var renderer = gameObject.renderer;
            this._drawCalls.removeDrawCalls(renderer);
            if (!renderer.mesh || renderer.materials.length === 0) {
                return;
            }
            renderer.mesh._createBuffer();
            this._drawCalls.renderers.push(renderer);
            //
            var subMeshIndex = 0;
            for (var _i = 0, _a = renderer.mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var material = renderer.materials[primitive.material];
                var drawCall = {
                    renderer: renderer,
                    matrix: egret3d.Matrix4.IDENTITY,
                    subMeshIndex: subMeshIndex++,
                    mesh: renderer.mesh,
                    material: material || egret3d.DefaultMaterials.MISSING,
                    zdist: -1,
                };
                if (!renderer.forceCPUSkin) {
                    material.addDefine("USE_SKINNING" /* USE_SKINNING */).addDefine("MAX_BONES" /* MAX_BONES */ + " " + Math.min(SkinnedMeshRendererSystem.maxBoneCount, renderer.bones.length));
                }
                this._drawCalls.drawCalls.push(drawCall);
            }
        };
        SkinnedMeshRendererSystem.prototype.onEnable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._updateDrawCalls(gameObject);
            }
        };
        SkinnedMeshRendererSystem.prototype.onAddGameObject = function (gameObject) {
            var renderer = gameObject.renderer;
            if (renderer.mesh && !renderer.boneMatrices) {
                renderer.initialize(true);
            }
            this._updateDrawCalls(gameObject);
        };
        SkinnedMeshRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            this._drawCalls.removeDrawCalls(gameObject.renderer);
        };
        SkinnedMeshRendererSystem.prototype.onUpdate = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                gameObject.renderer._update();
            }
        };
        SkinnedMeshRendererSystem.prototype.onDisable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._drawCalls.removeDrawCalls(gameObject.renderer);
            }
        };
        /**
         *
         */
        SkinnedMeshRendererSystem.maxBoneCount = 36;
        return SkinnedMeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.SkinnedMeshRendererSystem = SkinnedMeshRendererSystem;
    __reflect(SkinnedMeshRendererSystem.prototype, "egret3d.SkinnedMeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var BlendLayer = (function (_super) {
        __extends(BlendLayer, _super);
        function BlendLayer() {
            var _this = _super.call(this) || this;
            _this.dirty = 0;
            _this.layer = 0;
            _this.leftWeight = 0.0;
            _this.layerWeight = 0.0;
            _this.blendWeight = 0.0;
            return _this;
        }
        BlendLayer.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new BlendLayer();
        };
        BlendLayer.prototype.clear = function () {
            this.dirty = 0;
            this.layer = 0;
            this.leftWeight = 0.0;
            this.layerWeight = 0.0;
            this.blendWeight = 0.0;
        };
        BlendLayer.prototype.update = function (animationState) {
            var animationLayer = animationState.layer;
            var animationWeight = animationState._globalWeight;
            if (this.dirty > 0) {
                if (this.leftWeight > 0.0) {
                    if (animationState.additive && this.layer !== animationLayer) {
                        if (this.layerWeight >= this.leftWeight) {
                            this.leftWeight = 0.0;
                            return false;
                        }
                        this.layer = animationLayer;
                        this.leftWeight -= this.layerWeight;
                        this.layerWeight = animationWeight * this.leftWeight;
                    }
                    animationWeight *= this.leftWeight;
                    this.dirty++;
                    this.blendWeight = animationWeight;
                    return true;
                }
                return false;
            }
            this.dirty++;
            this.layer = animationLayer;
            this.leftWeight = 1.0;
            this.layerWeight = animationWeight;
            this.blendWeight = animationWeight;
        };
        BlendLayer._instances = [];
        return BlendLayer;
    }(paper.BaseRelease));
    __reflect(BlendLayer.prototype, "BlendLayer");
    /**
     *
     */
    var AnimationChannel = (function (_super) {
        __extends(AnimationChannel, _super);
        function AnimationChannel() {
            var _this = _super.call(this) || this;
            _this.update = null;
            return _this;
        }
        AnimationChannel.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new AnimationChannel();
        };
        AnimationChannel._instances = [];
        return AnimationChannel;
    }(paper.BaseRelease));
    __reflect(AnimationChannel.prototype, "AnimationChannel");
    var _animationChannels = [];
    /**
     * 动画混合节点。
     */
    var BlendNode = (function () {
        function BlendNode() {
            /**
             * @private
             */
            this.additive = false;
            /**
             * 动画混合模式。（根节点有效）
             */
            this.layer = 0;
            /**
             * 节点权重。
             */
            this.weight = 1.0;
            /**
             * 淡入淡出的时间。
             */
            this.fadeTotalTime = 1.0;
            /**
             * 父节点。
             */
            this.parent = null;
            /**
             * -1: Fade in, 0: Fade complete, 1: Fade out;
             * @internal
             */
            this._fadeState = -1;
            /**
             * -1: Fade start, 0: Fading, 1: Fade complete;
             * @internal
             */
            this._subFadeState = -1;
            /**
             * 累计权重。
             * @internal
             */
            this._globalWeight = 0.0;
            /**
             * 融合进度。
             * @internal
             */
            this._fadeProgress = 0.0;
            /**
             * 本地融合时间。
             */
            this._fadeTime = 0.0;
        }
        BlendNode.prototype._onFadeStateChange = function () {
        };
        /**
         * @internal
         */
        BlendNode.prototype._update = function (deltaTime) {
            if (this._fadeState !== 0 || this._subFadeState !== 0) {
                var isFadeOut = this._fadeState > 0;
                if (this._subFadeState < 0) {
                    this._subFadeState = 0;
                    this._onFadeStateChange();
                }
                if (deltaTime < 0.0) {
                    deltaTime = -deltaTime;
                }
                this._fadeTime += deltaTime;
                if (this._fadeTime >= this.fadeTotalTime) {
                    this._subFadeState = 1;
                    this._fadeProgress = isFadeOut ? 0.0 : 1.0;
                }
                else if (this._fadeTime > 0.0) {
                    this._fadeProgress = isFadeOut ? (1.0 - this._fadeTime / this.fadeTotalTime) : (this._fadeTime / this.fadeTotalTime);
                }
                else {
                    this._fadeProgress = isFadeOut ? 1.0 : 0.0;
                }
                if (this._subFadeState > 0) {
                    if (!isFadeOut) {
                        this._fadeState = 0;
                        this._onFadeStateChange();
                    }
                }
            }
            this._globalWeight = this.weight * this._fadeProgress;
            if (this.parent) {
                this._globalWeight *= this.parent._globalWeight;
            }
        };
        BlendNode.prototype.fadeOut = function (fadeOutTime) {
            if (fadeOutTime < 0.0 || fadeOutTime !== fadeOutTime) {
                fadeOutTime = 0.0;
            }
            if (this._fadeState > 0) {
                if (fadeOutTime > this.fadeTotalTime - this._fadeTime) {
                    return;
                }
            }
            else {
                this._fadeState = 1;
                this._subFadeState = -1;
                if (fadeOutTime <= 0.0 || this._fadeProgress <= 0.0) {
                    this._fadeProgress = 0.000001; // Modify fade progress to different value.
                }
            }
            this.fadeTotalTime = this._fadeProgress > 0.000001 ? fadeOutTime / this._fadeProgress : 0.0;
            this._fadeTime = this.fadeTotalTime * (1.0 - this._fadeProgress);
        };
        return BlendNode;
    }());
    egret3d.BlendNode = BlendNode;
    __reflect(BlendNode.prototype, "egret3d.BlendNode");
    /**
     * 动画混合树节点。
     */
    var BlendTree = (function (_super) {
        __extends(BlendTree, _super);
        function BlendTree() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._blendNodes = [];
            return _this;
        }
        return BlendTree;
    }(BlendNode));
    egret3d.BlendTree = BlendTree;
    __reflect(BlendTree.prototype, "egret3d.BlendTree");
    /**
     * 动画状态。
     */
    var AnimationState = (function (_super) {
        __extends(AnimationState, _super);
        function AnimationState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.layer = 0;
            /**
             * 动画总播放次数。
             */
            _this.playTimes = 0;
            /**
             * 动画当前播放次数。
             */
            _this.currentPlayTimes = 0;
            /**
             * 播放速度。
             */
            _this.timeScale = 1.0;
            /**
             * @private
             */
            _this.animationAsset = null;
            /**
             * 播放的动画数据。
             */
            _this.animation = null;
            /**
             * 播放的动画剪辑。
             */
            _this.animationClip = null;
            /**
             * 是否允许播放。
             */
            _this._isPlaying = true;
            /**
             * 播放状态。
             * -1: start, 0: playing, 1: complete;
             */
            _this._playState = -1;
            /**
             * 本地播放时间。
             */
            _this._time = 0.0;
            /**
             * 当前动画时间。
             */
            _this._currentTime = 0.0;
            // TODO cache.
            _this._channels = [];
            _this._animationComponent = null;
            return _this;
        }
        AnimationState.prototype._onUpdateTranslation = function (channel, animationState) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            if (animationState._currentTime <= inputBuffer[0]) {
            }
            else if (animationState._currentTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (animationState._currentTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var isComponents = Array.isArray(channel.components);
            var offset = frameIndex * 3;
            var x = outputBuffer[offset++];
            var y = outputBuffer[offset++];
            var z = outputBuffer[offset++];
            if (isInterpolation) {
                var progress = (animationState._currentTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                x += (outputBuffer[offset++] - x) * progress;
                y += (outputBuffer[offset++] - y) * progress;
                z += (outputBuffer[offset++] - z) * progress;
            }
            if (isComponents) {
                for (var _i = 0, _a = channel.components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    component.setLocalPosition(x, y, z);
                }
            }
            else {
                channel.components.setLocalPosition(x, y, z);
            }
        };
        AnimationState.prototype._onUpdateRotation = function (channel, animationState) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            if (animationState._currentTime <= inputBuffer[0]) {
            }
            else if (animationState._currentTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (animationState._currentTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var isComponents = Array.isArray(channel.components);
            var offset = frameIndex * 4;
            var x = outputBuffer[offset++];
            var y = outputBuffer[offset++];
            var z = outputBuffer[offset++];
            var w = outputBuffer[offset++];
            if (isInterpolation) {
                var progress = (animationState._currentTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                x += (outputBuffer[offset++] - x) * progress;
                y += (outputBuffer[offset++] - y) * progress;
                z += (outputBuffer[offset++] - z) * progress;
                w += (outputBuffer[offset++] - w) * progress;
            }
            if (isComponents) {
                for (var _i = 0, _a = channel.components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    component.setLocalRotation(x, y, z, w);
                }
            }
            else {
                channel.components.setLocalRotation(x, y, z, w);
            }
        };
        AnimationState.prototype._onUpdateScale = function (channel, animationState) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            if (animationState._currentTime <= inputBuffer[0]) {
            }
            else if (animationState._currentTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (animationState._currentTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var isComponents = Array.isArray(channel.components);
            var offset = frameIndex * 3;
            var x = outputBuffer[offset++];
            var y = outputBuffer[offset++];
            var z = outputBuffer[offset++];
            if (isInterpolation) {
                var progress = (animationState._currentTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                x += (outputBuffer[offset++] - x) * progress;
                y += (outputBuffer[offset++] - y) * progress;
                z += (outputBuffer[offset++] - z) * progress;
            }
            if (isComponents) {
                for (var _i = 0, _a = channel.components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    component.setLocalScale(x, y, z);
                }
            }
            else {
                channel.components.setLocalScale(x, y, z);
            }
        };
        AnimationState.prototype._onUpdateActive = function (channel, animationState) {
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            if (animationState._currentTime <= inputBuffer[0]) {
            }
            else if (animationState._currentTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (animationState._currentTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var isComponents = Array.isArray(channel.components);
            var activeSelf = outputBuffer[frameIndex] !== 0;
            if (isComponents) {
                for (var _i = 0, _a = channel.components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    component.gameObject.activeSelf = activeSelf;
                }
            }
            else {
                channel.components.gameObject.activeSelf = activeSelf;
            }
        };
        /**
         * @internal
         */
        AnimationState.prototype.initialize = function (animationComponent, animationAsset, animationClip) {
            var assetConfig = animationAsset.config;
            //
            this.animationAsset = animationAsset;
            this.animationClip = animationClip;
            this.animation = assetConfig.animations[0]; // TODO 动画数据暂不合并。
            //
            this._fadeTime = 0.0;
            this._time = 0.0;
            this._animationComponent = animationComponent;
            if (this.animation.channels) {
                var rootGameObject = this._animationComponent.gameObject;
                var children = rootGameObject.transform.getAllChildren({});
                children["__root__"] = rootGameObject.transform;
                for (var _i = 0, _a = this.animation.channels; _i < _a.length; _i++) {
                    var glTFChannel = _a[_i];
                    var node = this.animationAsset.getNode(glTFChannel.target.node || 0);
                    if (!(node.name in children)) {
                        continue;
                    }
                    var transforms = children[node.name];
                    var channel = _animationChannels.length > 0 ? _animationChannels.pop() : AnimationChannel.create();
                    var pathName = glTFChannel.target.path;
                    channel.glTFChannel = glTFChannel;
                    channel.glTFSampler = this.animation.samplers[glTFChannel.sampler];
                    channel.components = transforms; // TODO 更多组件
                    channel.inputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.input));
                    channel.outputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.output));
                    switch (pathName) {
                        case "translation":
                            channel.blendLayer = this._animationComponent._getBlendlayer(pathName, node.name);
                            channel.update = this._onUpdateTranslation;
                            break;
                        case "rotation":
                            channel.blendLayer = this._animationComponent._getBlendlayer(pathName, node.name);
                            channel.update = this._onUpdateRotation;
                            break;
                        case "scale":
                            channel.blendLayer = this._animationComponent._getBlendlayer(pathName, node.name);
                            channel.update = this._onUpdateScale;
                            break;
                        case "weights":
                            // TODO
                            break;
                        case "custom":
                            switch (channel.glTFChannel.extensions.paper.type) {
                                case "paper.GameObject":
                                    switch (channel.glTFChannel.extensions.paper.property) {
                                        case "activeSelf":
                                            channel.update = this._onUpdateActive;
                                            break;
                                    }
                                    break;
                            }
                            break;
                        default:
                            console.warn("Unknown animation channel.", channel.glTFChannel.target.path);
                            break;
                    }
                    this._channels.push(channel);
                }
            }
        };
        /**
         * @internal
         */
        AnimationState.prototype._update = function (deltaTime) {
            _super.prototype._update.call(this, deltaTime);
            // Update time.
            if (this._isPlaying) {
                deltaTime *= this.timeScale * this._animationComponent.timeScale;
                this._time += deltaTime;
            }
            var prevPlayState = this._playState;
            // const prevPlayTimes = this.currentPlayTimes;
            var duration = this.animationClip.duration;
            var totalTime = this.playTimes * duration;
            if (this.playTimes > 0 && (this._time >= totalTime || this._time <= -totalTime)) {
                if (this._playState <= 0 && this._isPlaying) {
                    this._playState = 1;
                }
                this.currentPlayTimes = this.playTimes;
                if (this._time >= totalTime) {
                    // currentTime = duration + 0.000001; // Precision problem.
                    this._currentTime = duration; // TODO CHECK.
                }
                else {
                    this._currentTime = 0.0;
                }
            }
            else {
                if (this._playState !== 0 && this._isPlaying) {
                    this._playState = 0;
                }
                if (this._time < 0.0) {
                    this._time = -this._time;
                    this.currentPlayTimes = Math.floor(this._time / duration);
                    this._currentTime = duration - (this._time % duration);
                }
                else {
                    this.currentPlayTimes = Math.floor(this._time / duration);
                    this._currentTime = this._time % duration;
                }
            }
            this._currentTime += this.animationClip.position;
            if (this.weight !== 0.0) {
                for (var _i = 0, _a = this._channels; _i < _a.length; _i++) {
                    var channel = _a[_i];
                    if (channel.update) {
                        channel.update(channel, this);
                    }
                }
            }
            if (prevPlayState !== this._playState && this._playState === 1) {
                this._animationComponent._dispatchEvent("complete", this); // TODO buffer event.
                var animationNames = this._animationComponent._animationNames;
                if (animationNames.length > 0) {
                    var animationName = animationNames.shift();
                    this._animationComponent.play(animationName);
                }
            }
        };
        AnimationState.prototype.play = function () {
            this._isPlaying = true;
        };
        AnimationState.prototype.stop = function () {
            this._isPlaying = false;
        };
        AnimationState.prototype.fateOut = function () {
            this._fadeState = 1;
            this._subFadeState = -1;
        };
        Object.defineProperty(AnimationState.prototype, "isPlaying", {
            get: function () {
                return this._isPlaying && this._playState !== 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "isCompleted", {
            get: function () {
                return this._playState !== 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "totalTime", {
            get: function () {
                return this.animationClip.duration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "currentTime", {
            get: function () {
                return this._currentTime;
            },
            enumerable: true,
            configurable: true
        });
        return AnimationState;
    }(BlendNode));
    egret3d.AnimationState = AnimationState;
    __reflect(AnimationState.prototype, "egret3d.AnimationState");
    /**
     * 动画组件。
     */
    var Animation = (function (_super) {
        __extends(Animation, _super);
        function Animation() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.autoPlay = false;
            /**
             * 动画速度。
             */
            _this.timeScale = 1.0;
            /**
             * 动画数据列表。
             */
            _this._animations = [];
            /**
             * 混合节点列表。
             */
            _this._blendNodes = [];
            /**
             * @internal
             */
            _this._animationNames = [];
            /**
             * 骨骼姿势列表。
             * @internal
             */
            _this._blendLayers = {};
            /**
             * 最后一个播放的动画状态。
             * - 当进行动画混合时，该值通常没有任何意义。
             */
            _this._lastAnimationState = null;
            return _this;
        }
        /**
         * TODO more event type.
         * sendMessage.
         * @internal
         */
        Animation.prototype._dispatchEvent = function (type, animationState, eventObject) {
            for (var _i = 0, _a = this.gameObject.getComponents(paper.Behaviour, true); _i < _a.length; _i++) {
                var component = _a[_i];
                if (component.onAnimationEvent) {
                    component.onAnimationEvent(type, animationState, eventObject);
                }
            }
        };
        /**
         * @internal
         */
        Animation.prototype._getBlendlayer = function (type, name) {
            if (!(type in this._blendLayers)) {
                this._blendLayers[type] = {};
            }
            var blendLayers = this._blendLayers[type];
            if (!(name in blendLayers)) {
                blendLayers[name] = BlendLayer.create();
            }
            return blendLayers[name];
        };
        /**
         * @internal
         */
        Animation.prototype._update = function (globalTime) {
            var blendNodes = this._blendNodes;
            var blendNodeCount = blendNodes.length;
            if (blendNodeCount === 1) {
                var blendNode = blendNodes[0];
                if (blendNode._fadeState > 0 && blendNode._subFadeState > 0) {
                    blendNodes.length = 0;
                    if (this._lastAnimationState === blendNode) {
                        this._lastAnimationState = null;
                    }
                }
                else {
                    blendNode._update(globalTime);
                }
            }
            else if (blendNodeCount > 1) {
                for (var i = 0, r = 0; i < blendNodeCount; ++i) {
                    var blendNode = blendNodes[i];
                    if (blendNode._fadeState > 0 && blendNode._subFadeState > 0) {
                        r++;
                        if (this._lastAnimationState === blendNode) {
                            this._lastAnimationState = null;
                        }
                    }
                    else {
                        if (r > 0) {
                            blendNodes[i - r] = blendNode;
                        }
                        blendNode._update(globalTime);
                    }
                    if (i === blendNodeCount - 1 && r > 0) {
                        blendNodes.length -= r;
                        if (this._lastAnimationState === null && blendNodes.length > 0) {
                            var blendNode_1 = blendNodes[blendNodes.length - 1];
                            if (blendNode_1 instanceof AnimationState) {
                                this._lastAnimationState = blendNode_1;
                            }
                        }
                    }
                }
            }
            else {
            }
        };
        Animation.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            // TODO
            // for (const blendLayer in this._blendLayers) {
            //     blendLayer.release();
            // }
            // this._blendLayers.length = 0;
        };
        Animation.prototype.fadeIn = function (animationName, fadeTime, playTimes, layer, additive) {
            if (animationName === void 0) { animationName = null; }
            if (playTimes === void 0) { playTimes = -1; }
            if (layer === void 0) { layer = 0; }
            if (additive === void 0) { additive = false; }
            var animationAsset = null;
            var animationClip = null;
            for (var _i = 0, _a = this._animations; _i < _a.length; _i++) {
                var animation = _a[_i];
                animationAsset = animation;
                if (animationName) {
                    animationClip = animation.getAnimationClip(animationName);
                    if (animationClip !== null) {
                        break;
                    }
                }
                else {
                    animationClip = animation.getAnimationClip("");
                    break;
                }
            }
            if (!animationAsset || !animationClip) {
                return null;
            }
            for (var _b = 0, _c = this._blendNodes; _b < _c.length; _b++) {
                var blendNode = _c[_b];
                if ((!blendNode.parent && blendNode.layer === layer)) {
                    blendNode.fadeOut(fadeTime);
                }
            }
            var animationState = new AnimationState();
            animationState.initialize(this, animationAsset, animationClip);
            animationState.additive = additive;
            animationState.fadeTotalTime = fadeTime;
            animationState.playTimes = playTimes < 0 ? (animationClip.playTimes || 0) : playTimes;
            // TODO sort by layer and blend tree.
            this._blendNodes.push(animationState);
            this._lastAnimationState = animationState;
            return animationState;
        };
        Animation.prototype.play = function (animationNameOrNames, playTimes) {
            if (animationNameOrNames === void 0) { animationNameOrNames = null; }
            if (playTimes === void 0) { playTimes = -1; }
            this._animationNames.length = 0;
            if (Array.isArray(animationNameOrNames)) {
                if (animationNameOrNames.length > 0) {
                    for (var _i = 0, animationNameOrNames_1 = animationNameOrNames; _i < animationNameOrNames_1.length; _i++) {
                        var animationName = animationNameOrNames_1[_i];
                        this._animationNames.push(animationName);
                    }
                    return this.fadeIn(this._animationNames.shift(), 0.0, playTimes);
                }
                return this.fadeIn(null, 0.0, playTimes);
            }
            return this.fadeIn(animationNameOrNames, 0.0, playTimes);
        };
        Animation.prototype.stop = function () {
            for (var _i = 0, _a = this._blendNodes; _i < _a.length; _i++) {
                var blendNode = _a[_i];
                if (!blendNode.parent && blendNode instanceof AnimationState) {
                    blendNode.stop();
                }
            }
        };
        Object.defineProperty(Animation.prototype, "lastAnimationnName", {
            get: function () {
                return this._lastAnimationState ? this._lastAnimationState.animationClip.name : "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "animations", {
            get: function () {
                return this._animations;
            },
            /**
             * 动画数据列表。
             */
            set: function (animations) {
                for (var i = 0, l = animations.length; i < l; i++) {
                    this._animations[i] = animations[i];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "lastAnimationState", {
            get: function () {
                return this._lastAnimationState;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Animation.prototype, "autoPlay", void 0);
        __decorate([
            paper.editor.property(2 /* FLOAT */)
        ], Animation.prototype, "timeScale", void 0);
        __decorate([
            paper.serializedField
        ], Animation.prototype, "_animations", void 0);
        Animation = __decorate([
            paper.allowMultiple
        ], Animation);
        return Animation;
    }(paper.BaseComponent));
    egret3d.Animation = Animation;
    __reflect(Animation.prototype, "egret3d.Animation");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 动画系统。
     */
    var AnimationSystem = (function (_super) {
        __extends(AnimationSystem, _super);
        function AnimationSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: egret3d.Animation }
            ];
            return _this;
        }
        AnimationSystem.prototype.onAddComponent = function (component) {
            if (component.autoPlay && (!component.lastAnimationState || !component.lastAnimationState.isPlaying)) {
                component.play();
            }
        };
        AnimationSystem.prototype.onUpdate = function (deltaTime) {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                for (var _b = 0, _c = gameObject.getComponents(egret3d.Animation); _b < _c.length; _b++) {
                    var animation = _c[_b];
                    animation._update(deltaTime);
                }
            }
        };
        return AnimationSystem;
    }(paper.BaseSystem));
    egret3d.AnimationSystem = AnimationSystem;
    __reflect(AnimationSystem.prototype, "egret3d.AnimationSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         * @private
         * 渲染类型为Mesh的属性格式
         */
        var MeshShaderAttributeFormat = [
            { key: "POSITION" /* POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "COLOR_0" /* COLOR_0 */, type: "VEC4" /* VEC4 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "_START_POSITION" /* _START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_START_VELOCITY" /* _START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "_START_COLOR" /* _START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "_START_SIZE" /* _START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "_START_ROTATION" /* _START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "_TIME" /* _TIME */, type: "VEC2" /* VEC2 */ },
            { key: "_RANDOM0" /* _RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "_RANDOM1" /* _RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "_WORLD_POSITION" /* _WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_WORLD_ROTATION" /* _WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        /**
         * @private
         * 渲染类型为Billboard的属性格式
         */
        var BillboardShaderAttributeFormat = [
            { key: "_CORNER" /* _CORNER */, type: "VEC2" /* VEC2 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "_START_POSITION" /* _START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_START_VELOCITY" /* _START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "_START_COLOR" /* _START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "_START_SIZE" /* _START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "_START_ROTATION" /* _START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "_TIME" /* _TIME */, type: "VEC2" /* VEC2 */ },
            { key: "_RANDOM0" /* _RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "_RANDOM1" /* _RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "_WORLD_POSITION" /* _WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_WORLD_ROTATION" /* _WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        /**
        * @internal
        */
        function createBatchMesh(renderer, maxParticleCount) {
            var meshAttributes = [];
            var meshAttributesType = {};
            if (renderer._renderMode === 4 /* Mesh */) {
                var mesh = renderer.mesh;
                var orginIndexBuffer = mesh.getIndices();
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _i = 0, MeshShaderAttributeFormat_1 = MeshShaderAttributeFormat; _i < MeshShaderAttributeFormat_1.length; _i++) {
                    var attribute = MeshShaderAttributeFormat_1[_i];
                    meshAttributes.push(attribute.key);
                    meshAttributesType[attribute.key] = attribute.type;
                }
                var totalVertexCount = mesh.vertexCount * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = new egret3d.Mesh(totalVertexCount, totalIndexCount, meshAttributes, meshAttributesType, 35048 /* Dynamic */);
                //
                var index = 0;
                //提前填充
                var orginPostionBuffer = mesh.getAttributes("POSITION" /* POSITION */);
                var orginUVBuffer = mesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                var orginColorBuffer = mesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var positionBuffer = batchMesh.getAttributes("POSITION" /* POSITION */);
                var colorBuffer = batchMesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var vector2Offset = i * 2;
                    var vector3Offset = i * 3;
                    var vector4Offset = i * 4;
                    var orginVertexIndex = i % mesh.vertexCount;
                    positionBuffer[vector3Offset] = orginPostionBuffer[orginVertexIndex * 3];
                    positionBuffer[vector3Offset + 1] = orginPostionBuffer[orginVertexIndex * 3 + 1];
                    positionBuffer[vector3Offset + 2] = orginPostionBuffer[orginVertexIndex * 3 + 2];
                    if (orginUVBuffer) {
                        uvBuffer[vector2Offset] = orginUVBuffer[orginVertexIndex * 2];
                        uvBuffer[vector2Offset + 1] = orginUVBuffer[orginVertexIndex * 2 + 1];
                    }
                    if (orginColorBuffer) {
                        colorBuffer[vector4Offset] = orginColorBuffer[orginVertexIndex * 4];
                        colorBuffer[vector4Offset + 1] = orginColorBuffer[orginVertexIndex * 4 + 1];
                        colorBuffer[vector4Offset + 2] = orginColorBuffer[orginVertexIndex * 4 + 2];
                        colorBuffer[vector4Offset + 3] = orginColorBuffer[orginVertexIndex * 4 + 3];
                    }
                    else {
                        colorBuffer[vector4Offset] = 1;
                        colorBuffer[vector4Offset + 1] = 1;
                        colorBuffer[vector4Offset + 2] = 1;
                        colorBuffer[vector4Offset + 3] = 1;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * mesh.vertexCount;
                    for (var j = 0; j < orginIndexBufferCount; j++) {
                        indexBuffer[index++] = orginIndexBuffer[j] + indexOffset;
                    }
                }
                return batchMesh;
            }
            else {
                var orginIndexBuffer = [0, 2, 1, 0, 3, 2];
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _a = 0, BillboardShaderAttributeFormat_1 = BillboardShaderAttributeFormat; _a < BillboardShaderAttributeFormat_1.length; _a++) {
                    var attribute = BillboardShaderAttributeFormat_1[_a];
                    meshAttributes.push(attribute.key);
                    meshAttributesType[attribute.key] = attribute.type;
                }
                var vertexStride = 4;
                var totalVertexCount = vertexStride * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = new egret3d.Mesh(totalVertexCount, totalIndexCount, meshAttributes, meshAttributesType, 35048 /* Dynamic */);
                var cornerBuffer = batchMesh.getAttributes("_CORNER" /* _CORNER */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var orginVertexIndex = i % vertexStride;
                    var vector2Offset = i * 2;
                    switch (orginVertexIndex) {
                        case 0:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                        case 1:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                        case 2:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                        case 3:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * 6;
                    var firstVertex = i * vertexStride;
                    var secondVertex = firstVertex + 2;
                    indexBuffer[indexOffset + 0] = firstVertex;
                    indexBuffer[indexOffset + 1] = secondVertex;
                    indexBuffer[indexOffset + 2] = firstVertex + 1;
                    indexBuffer[indexOffset + 3] = firstVertex;
                    indexBuffer[indexOffset + 4] = firstVertex + 3;
                    indexBuffer[indexOffset + 5] = secondVertex;
                }
                return batchMesh;
            }
        }
        particle.createBatchMesh = createBatchMesh;
        /**
         * @internal
         */
        function generatePositionAndDirection(position, direction, shape) {
            if (!shape.enable) {
                position.x = position.y = position.z = 0;
                direction.x = direction.y = 0;
                direction.z = 1.0;
                return;
            }
            //
            switch (shape.shapeType) {
                case 4 /* Cone */:
                case 7 /* ConeShell */:
                    {
                        _generateConeParticlePosition(shape, position, direction);
                    }
                    break;
                case 8 /* ConeVolume */:
                case 9 /* ConeVolumeShell */:
                    {
                        _generateConeVolumeParticlePosition(shape, position, direction);
                    }
                    break;
                case 5 /* Box */:
                    {
                        _generateBoxParticlePosition(shape, position, direction);
                    }
                    break;
                case 0 /* Sphere */:
                case 1 /* SphereShell */:
                    {
                        _generateSphereParticlePosition(shape, position, direction);
                    }
                    break;
                case 10 /* Circle */:
                    {
                        _generateCircleParticlePosition(shape, position, direction);
                    }
                    break;
                default:
                    {
                        position.x = position.y = position.z = 0;
                        direction.x = direction.y = 0;
                        direction.z = 1;
                    }
            }
        }
        particle.generatePositionAndDirection = generatePositionAndDirection;
        function _randomPostionCircle(out) {
            var angle = Math.random() * Math.PI * 2;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideCircle(out) {
            _randomPostionCircle(out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionArcCircle(arc, out) {
            var angle = Math.random() * arc;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideArcCircle(arc, out) {
            _randomPositionArcCircle(arc, out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionSphere(out) {
            var ranZ = Math.random() * 2 - 1.0;
            var angle = Math.random() * Math.PI * 2;
            var range = Math.sqrt(1.0 - ranZ * ranZ);
            out.x = Math.cos(angle) * range;
            out.y = Math.sin(angle) * range;
            out.z = ranZ;
        }
        function _randomPositionInsideSphere(out) {
            _randomPositionSphere(out);
            var range = Math.pow(Math.random(), 1.0 / 3.0);
            out.x = out.x * range;
            out.y = out.y * range;
            out.z = out.z * range;
        }
        function _generateConeParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType === 4 /* Cone */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = temp.z * shape.radius;
            var angle = shape.angle * Math.PI / 180.0;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            if (shape.randomDirection) {
                _randomPositionInsideCircle(direction);
                direction.x = direction.x * sinValue;
                direction.y = direction.y * sinValue;
                direction.z = cosValue;
            }
            else {
                direction.x = temp.x * sinValue;
                direction.y = temp.y * sinValue;
                direction.z = cosValue;
            }
        }
        function _generateConeVolumeParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType === 8 /* ConeVolume */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            var angle = shape.angle * Math.PI / 180.0;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            direction.x = temp.x * sinValue;
            direction.y = temp.y * sinValue;
            direction.z = cosValue;
            egret3d.Vector3.normalize(direction);
            var len = Math.random() * shape.length;
            direction.x = direction.x * len;
            direction.y = direction.y * len;
            direction.z = direction.z * len;
            position.x += direction.x;
            position.y += direction.y;
            position.z += direction.z;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
        }
        function _generateBoxParticlePosition(shape, position, direction) {
            position.x = shape.box.x * (Math.random() - 0.5);
            position.y = shape.box.y * (Math.random() - 0.5);
            position.z = shape.box.z * (Math.random() - 0.5);
            if (shape.randomDirection) {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
            else {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
        }
        function _generateSphereParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (!shape.spherizeDirection) {
                if (shape.shapeType === 0 /* Sphere */) {
                    _randomPositionInsideSphere(position);
                }
                else {
                    _randomPositionSphere(position);
                }
            }
            position.x = position.x * shape.radius;
            position.y = position.y * shape.radius;
            position.z = position.z * shape.radius;
            if (shape.randomDirection || shape.spherizeDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
        function _generateCircleParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType === 10 /* Circle */) {
                _randomPositionInsideArcCircle(shape.radiusSpread, temp);
            }
            else {
                _randomPositionArcCircle(shape.radiusSpread, temp);
            }
            position.x = -temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        var colorHelper1 = egret3d.Color.create();
        var colorHelper2 = egret3d.Color.create();
        var CurveMode;
        (function (CurveMode) {
            CurveMode[CurveMode["Constant"] = 0] = "Constant";
            CurveMode[CurveMode["Curve"] = 1] = "Curve";
            CurveMode[CurveMode["TwoCurves"] = 2] = "TwoCurves";
            CurveMode[CurveMode["TwoConstants"] = 3] = "TwoConstants";
        })(CurveMode = particle.CurveMode || (particle.CurveMode = {}));
        var ColorGradientMode;
        (function (ColorGradientMode) {
            ColorGradientMode[ColorGradientMode["Color"] = 0] = "Color";
            ColorGradientMode[ColorGradientMode["Gradient"] = 1] = "Gradient";
            ColorGradientMode[ColorGradientMode["TwoColors"] = 2] = "TwoColors";
            ColorGradientMode[ColorGradientMode["TwoGradients"] = 3] = "TwoGradients";
            ColorGradientMode[ColorGradientMode["RandomColor"] = 4] = "RandomColor";
        })(ColorGradientMode = particle.ColorGradientMode || (particle.ColorGradientMode = {}));
        var SimulationSpace;
        (function (SimulationSpace) {
            SimulationSpace[SimulationSpace["Local"] = 0] = "Local";
            SimulationSpace[SimulationSpace["World"] = 1] = "World";
            SimulationSpace[SimulationSpace["Custom"] = 2] = "Custom";
        })(SimulationSpace = particle.SimulationSpace || (particle.SimulationSpace = {}));
        var ScalingMode;
        (function (ScalingMode) {
            ScalingMode[ScalingMode["Hierarchy"] = 0] = "Hierarchy";
            ScalingMode[ScalingMode["Local"] = 1] = "Local";
            ScalingMode[ScalingMode["Shape"] = 2] = "Shape";
        })(ScalingMode = particle.ScalingMode || (particle.ScalingMode = {}));
        var ShapeType;
        (function (ShapeType) {
            ShapeType[ShapeType["None"] = -1] = "None";
            ShapeType[ShapeType["Sphere"] = 0] = "Sphere";
            ShapeType[ShapeType["SphereShell"] = 1] = "SphereShell";
            ShapeType[ShapeType["Hemisphere"] = 2] = "Hemisphere";
            ShapeType[ShapeType["HemisphereShell"] = 3] = "HemisphereShell";
            ShapeType[ShapeType["Cone"] = 4] = "Cone";
            ShapeType[ShapeType["Box"] = 5] = "Box";
            ShapeType[ShapeType["Mesh"] = 6] = "Mesh";
            ShapeType[ShapeType["ConeShell"] = 7] = "ConeShell";
            ShapeType[ShapeType["ConeVolume"] = 8] = "ConeVolume";
            ShapeType[ShapeType["ConeVolumeShell"] = 9] = "ConeVolumeShell";
            ShapeType[ShapeType["Circle"] = 10] = "Circle";
            ShapeType[ShapeType["CircleEdge"] = 11] = "CircleEdge";
            ShapeType[ShapeType["SingleSidedEdge"] = 12] = "SingleSidedEdge";
            ShapeType[ShapeType["MeshRenderer"] = 13] = "MeshRenderer";
            ShapeType[ShapeType["SkinnedMeshRenderer"] = 14] = "SkinnedMeshRenderer";
            ShapeType[ShapeType["BoxShell"] = 15] = "BoxShell";
            ShapeType[ShapeType["BoxEdge"] = 16] = "BoxEdge";
        })(ShapeType = particle.ShapeType || (particle.ShapeType = {}));
        var ShapeMultiModeValue;
        (function (ShapeMultiModeValue) {
            ShapeMultiModeValue[ShapeMultiModeValue["Random"] = 0] = "Random";
            ShapeMultiModeValue[ShapeMultiModeValue["Loop"] = 1] = "Loop";
            ShapeMultiModeValue[ShapeMultiModeValue["PingPong"] = 2] = "PingPong";
            ShapeMultiModeValue[ShapeMultiModeValue["BurstSpread"] = 3] = "BurstSpread";
        })(ShapeMultiModeValue = particle.ShapeMultiModeValue || (particle.ShapeMultiModeValue = {}));
        var AnimationType;
        (function (AnimationType) {
            AnimationType[AnimationType["WholeSheet"] = 0] = "WholeSheet";
            AnimationType[AnimationType["SingleRow"] = 1] = "SingleRow";
        })(AnimationType = particle.AnimationType || (particle.AnimationType = {}));
        var UVChannelFlags;
        (function (UVChannelFlags) {
            UVChannelFlags[UVChannelFlags["UV0"] = 1] = "UV0";
            UVChannelFlags[UVChannelFlags["UV1"] = 2] = "UV1";
            UVChannelFlags[UVChannelFlags["UV2"] = 4] = "UV2";
            UVChannelFlags[UVChannelFlags["UV3"] = 8] = "UV3";
        })(UVChannelFlags = particle.UVChannelFlags || (particle.UVChannelFlags = {}));
        var GradientMode;
        (function (GradientMode) {
            GradientMode[GradientMode["Blend"] = 0] = "Blend";
            GradientMode[GradientMode["Fixed"] = 1] = "Fixed";
        })(GradientMode = particle.GradientMode || (particle.GradientMode = {}));
        var Keyframe = (function () {
            function Keyframe() {
            }
            Keyframe.prototype.serialize = function () {
                return [this.time, this.value];
            };
            Keyframe.prototype.deserialize = function (element) {
                this.time = element[0];
                this.value = element[1];
                return this;
            };
            Keyframe.prototype.clone = function (source) {
                this.time = source.time;
                this.value = source.value;
            };
            return Keyframe;
        }());
        particle.Keyframe = Keyframe;
        __reflect(Keyframe.prototype, "egret3d.particle.Keyframe", ["paper.ISerializable"]);
        var AnimationCurve = (function () {
            function AnimationCurve() {
                /**
                 * 功能与效率平衡长度取4
                 */
                this._keys = new Array();
                this._floatValues = new Float32Array(8);
            }
            AnimationCurve.prototype.serialize = function () {
                return this._keys.map(function (keyFrame) { return keyFrame.serialize(); });
            };
            AnimationCurve.prototype.deserialize = function (element) {
                this._keys.length = 0;
                for (var i = 0, l = element.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.deserialize(element[i]);
                    this._keys.push(keyframe);
                }
                return this;
            };
            AnimationCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this._keys.length; i < l; i++) {
                    var curKeyFrame = this._keys[i];
                    if (curKeyFrame.time < t) {
                        continue;
                    }
                    //
                    var lastIndex = i === 0 ? 0 : i - 1;
                    var lastKeyFrame = this._keys[lastIndex];
                    var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                    return egret3d.numberLerp(lastKeyFrame.value, curKeyFrame.value, tt);
                }
                throw "AnimationCurve: invalid t or keys.length is 0";
            };
            Object.defineProperty(AnimationCurve.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    var offset = 0;
                    for (var _i = 0, _a = this._keys; _i < _a.length; _i++) {
                        var keyFrame = _a[_i];
                        res[offset++] = keyFrame.time;
                        res[offset++] = keyFrame.value;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            AnimationCurve.prototype.clone = function (source) {
                this._keys.length = 0;
                var sourceKeys = source._keys;
                for (var i = 0, l = sourceKeys.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.time = sourceKeys[i].time;
                    keyframe.value = sourceKeys[i].value;
                    this._keys.push(keyframe);
                }
            };
            return AnimationCurve;
        }());
        particle.AnimationCurve = AnimationCurve;
        __reflect(AnimationCurve.prototype, "egret3d.particle.AnimationCurve", ["paper.ISerializable"]);
        var GradientColorKey = (function (_super) {
            __extends(GradientColorKey, _super);
            function GradientColorKey() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.color = egret3d.Color.create();
                return _this;
            }
            GradientColorKey.prototype.deserialize = function (element) {
                this.color.deserialize(element.color);
                this.time = element.time;
                return this;
            };
            __decorate([
                paper.serializedField
            ], GradientColorKey.prototype, "time", void 0);
            __decorate([
                paper.serializedField
            ], GradientColorKey.prototype, "color", void 0);
            return GradientColorKey;
        }(paper.BaseObject));
        particle.GradientColorKey = GradientColorKey;
        __reflect(GradientColorKey.prototype, "egret3d.particle.GradientColorKey");
        var GradientAlphaKey = (function (_super) {
            __extends(GradientAlphaKey, _super);
            function GradientAlphaKey() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            GradientAlphaKey.prototype.deserialize = function (element) {
                this.alpha = element.alpha;
                this.time = element.time;
                return this;
            };
            __decorate([
                paper.serializedField
            ], GradientAlphaKey.prototype, "alpha", void 0);
            __decorate([
                paper.serializedField
            ], GradientAlphaKey.prototype, "time", void 0);
            return GradientAlphaKey;
        }(paper.BaseObject));
        particle.GradientAlphaKey = GradientAlphaKey;
        __reflect(GradientAlphaKey.prototype, "egret3d.particle.GradientAlphaKey");
        var Gradient = (function (_super) {
            __extends(Gradient, _super);
            function Gradient() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 0 /* Blend */;
                _this.alphaKeys = new Array();
                _this.colorKeys = new Array();
                _this._alphaValue = new Float32Array(8);
                _this._colorValue = new Float32Array(16);
                return _this;
            }
            Gradient.prototype.deserialize = function (element) {
                this.colorKeys.length = 0;
                for (var i = 0, l = element.colorKeys.length; i < l; i++) {
                    var color = new GradientColorKey();
                    color.deserialize(element.colorKeys[i]);
                    this.colorKeys.push(color);
                }
                //
                this.alphaKeys.length = 0;
                for (var i = 0, l = element.alphaKeys.length; i < l; i++) {
                    var alpha = new GradientAlphaKey();
                    alpha.deserialize(element.alphaKeys[i]);
                    this.alphaKeys.push(alpha);
                }
                return this;
            };
            Gradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this.alphaKeys.length; i < l; i++) {
                    var curKeyFrame = this.alphaKeys[i];
                    if (curKeyFrame.time > t) {
                        var lastIndex = i === 0 ? 0 : i - 1;
                        var lastKeyFrame = this.alphaKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                        out.a = egret3d.numberLerp(lastKeyFrame.alpha, curKeyFrame.alpha, tt);
                        break;
                    }
                }
                for (var i = 0, l = this.colorKeys.length; i < l; i++) {
                    var colorKey = this.colorKeys[i];
                    if (colorKey.time > t) {
                        var lastIndex = i === 0 ? 0 : i - 1;
                        var lastKeyFrame = this.colorKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (colorKey.time - lastKeyFrame.time);
                        out.r = egret3d.numberLerp(lastKeyFrame.color.r, colorKey.color.r, tt);
                        out.g = egret3d.numberLerp(lastKeyFrame.color.g, colorKey.color.g, tt);
                        out.b = egret3d.numberLerp(lastKeyFrame.color.b, colorKey.color.b, tt);
                        break;
                    }
                }
                return out;
            };
            Object.defineProperty(Gradient.prototype, "alphaValues", {
                get: function () {
                    var res = this._alphaValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.alphaKeys; _i < _a.length; _i++) {
                        var alpha = _a[_i];
                        res[offset++] = alpha.time;
                        res[offset++] = alpha.alpha;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Gradient.prototype, "colorValues", {
                get: function () {
                    var res = this._colorValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.colorKeys; _i < _a.length; _i++) {
                        var color = _a[_i];
                        res[offset++] = color.time;
                        res[offset++] = color.color.r;
                        res[offset++] = color.color.g;
                        res[offset++] = color.color.b;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "alphaKeys", void 0);
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "colorKeys", void 0);
            return Gradient;
        }(paper.BaseObject));
        particle.Gradient = Gradient;
        __reflect(Gradient.prototype, "egret3d.particle.Gradient");
        var MinMaxCurve = (function (_super) {
            __extends(MinMaxCurve, _super);
            function MinMaxCurve() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 0 /* Constant */;
                _this.curve = new AnimationCurve();
                _this.curveMin = new AnimationCurve();
                _this.curveMax = new AnimationCurve();
                return _this;
            }
            MinMaxCurve.prototype.deserialize = function (element) {
                this.mode = element.mode;
                this.constant = element.constant || 0;
                this.constantMin = element.constantMin || 0;
                this.constantMax = element.constantMax || 0;
                element.curve && this.curve.deserialize(element.curve);
                element.curveMin && this.curveMin.deserialize(element.curveMin);
                element.curveMax && this.curveMax.deserialize(element.curveMax);
                return this;
            };
            MinMaxCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Constant */) {
                    return this.constant;
                }
                else if (this.mode === 3 /* TwoConstants */) {
                    return (Math.random() * (this.constantMax - this.constantMin) + this.constantMin);
                }
                else if (this.mode === 1 /* Curve */) {
                    return this.curve.evaluate(t);
                }
                else {
                    var min = this.curveMin.evaluate(t);
                    var max = this.curveMax.evaluate(t);
                    return (Math.random() * (min - max) + min);
                }
            };
            MinMaxCurve.prototype.clone = function (source) {
                this.mode = source.mode;
                this.constant = source.constant;
                this.constantMin = source.constantMin;
                this.constantMax = source.constantMax;
                this.curve.clone(source.curve);
                this.curveMin.clone(source.curveMin);
                this.curveMax.clone(source.curveMax);
            };
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constant", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constantMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constantMax", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curve", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curveMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curveMax", void 0);
            return MinMaxCurve;
        }(paper.BaseObject));
        particle.MinMaxCurve = MinMaxCurve;
        __reflect(MinMaxCurve.prototype, "egret3d.particle.MinMaxCurve");
        var MinMaxGradient = (function (_super) {
            __extends(MinMaxGradient, _super);
            function MinMaxGradient() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 1 /* Gradient */;
                _this.color = egret3d.Color.create();
                _this.colorMin = egret3d.Color.create();
                _this.colorMax = egret3d.Color.create();
                _this.gradient = new Gradient();
                _this.gradientMin = new Gradient();
                _this.gradientMax = new Gradient();
                return _this;
            }
            MinMaxGradient.prototype.deserialize = function (element) {
                // super.deserialize(element);
                this.mode = element.mode;
                if (element.color) {
                    this.color.deserialize(element.color);
                }
                if (element.colorMin) {
                    this.colorMin.deserialize(element.colorMin);
                }
                if (element.colorMax) {
                    this.colorMax.deserialize(element.colorMax);
                }
                if (element.gradient) {
                    this.gradient.deserialize(element.gradient);
                }
                if (element.gradientMin) {
                    this.gradientMin.deserialize(element.gradientMin);
                }
                if (element.gradientMax) {
                    this.gradientMax.deserialize(element.gradientMax);
                }
                return this;
            };
            MinMaxGradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Color */) {
                    out.r = this.color.r;
                    out.g = this.color.g;
                    out.b = this.color.b;
                    out.a = this.color.a;
                }
                else if (this.mode === 2 /* TwoColors */) {
                    out.r = Math.random() * (this.colorMax.r - this.colorMin.r) + this.colorMin.r;
                    out.g = Math.random() * (this.colorMax.g - this.colorMin.g) + this.colorMin.g;
                    out.b = Math.random() * (this.colorMax.b - this.colorMin.b) + this.colorMin.b;
                    out.a = Math.random() * (this.colorMax.a - this.colorMin.a) + this.colorMin.a;
                }
                else if (this.mode === 1 /* Gradient */) {
                    return this.gradient.evaluate(t, out);
                }
                else if (this.mode === 3 /* TwoGradients */) {
                    this.gradientMin.evaluate(t, colorHelper1);
                    this.gradientMax.evaluate(t, colorHelper2);
                    out.r = (Math.random() * (colorHelper1.r - colorHelper2.r) + colorHelper1.r);
                    out.g = (Math.random() * (colorHelper1.g - colorHelper2.g) + colorHelper1.g);
                    out.b = (Math.random() * (colorHelper1.b - colorHelper2.b) + colorHelper1.b);
                    out.a = (Math.random() * (colorHelper1.a - colorHelper2.a) + colorHelper1.a);
                }
                else {
                    out.r = Math.random();
                    out.g = Math.random();
                    out.b = Math.random();
                    out.a = Math.random();
                }
                return out;
            };
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "color", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "colorMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "colorMax", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradient", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradientMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradientMax", void 0);
            return MinMaxGradient;
        }(paper.BaseObject));
        particle.MinMaxGradient = MinMaxGradient;
        __reflect(MinMaxGradient.prototype, "egret3d.particle.MinMaxGradient");
        var Burst = (function () {
            function Burst() {
            }
            Burst.prototype.serialize = function () {
                return [this.time, this.minCount, this.maxCount, this.cycleCount, this.repeatInterval];
            };
            Burst.prototype.deserialize = function (element) {
                this.time = element[0];
                this.minCount = element[1];
                this.maxCount = element[2];
                this.cycleCount = element[3];
                this.repeatInterval = element[4];
                return this;
            };
            return Burst;
        }());
        particle.Burst = Burst;
        __reflect(Burst.prototype, "egret3d.particle.Burst", ["paper.ISerializable"]);
        var ParticleSystemModule = (function (_super) {
            __extends(ParticleSystemModule, _super);
            function ParticleSystemModule(comp) {
                var _this = _super.call(this) || this;
                _this.enable = false;
                _this._comp = comp;
                return _this;
            }
            /**
             * @internal
             */
            ParticleSystemModule.prototype.initialize = function () { };
            ParticleSystemModule.prototype.deserialize = function (element) {
                this.enable = true;
                return this;
            };
            __decorate([
                paper.serializedField
            ], ParticleSystemModule.prototype, "enable", void 0);
            return ParticleSystemModule;
        }(paper.BaseObject));
        particle.ParticleSystemModule = ParticleSystemModule;
        __reflect(ParticleSystemModule.prototype, "egret3d.particle.ParticleSystemModule");
        var MainModule = (function (_super) {
            __extends(MainModule, _super);
            function MainModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.duration = 0.0;
                _this.loop = false;
                //
                _this.startDelay = new MinMaxCurve();
                //
                _this.startLifetime = new MinMaxCurve();
                //
                _this.startSpeed = new MinMaxCurve();
                //
                _this.startSizeX = new MinMaxCurve();
                _this.startSizeY = new MinMaxCurve();
                _this.startSizeZ = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._startRotation3D = false;
                _this.startRotationX = new MinMaxCurve();
                _this.startRotationY = new MinMaxCurve();
                _this.startRotationZ = new MinMaxCurve();
                //
                _this.startColor = new MinMaxGradient();
                //
                _this.gravityModifier = new MinMaxCurve(); //TODO
                /**
                 * @internal
                 */
                _this._simulationSpace = 0 /* Local */;
                /**
                 * @internal
                 */
                _this._scaleMode = 0 /* Hierarchy */;
                //
                _this.playOnAwake = false;
                /**
                 * @internal
                 */
                _this._maxParticles = 0;
                return _this;
            }
            MainModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.duration = element.duration;
                this.loop = element.loop || element.looping; // TODO 兼容代码 looping。
                this.startDelay.deserialize(element.startDelay);
                this.startLifetime.deserialize(element.startLifetime);
                this.startSpeed.deserialize(element.startSpeed);
                this.startSizeX.deserialize(element.startSizeX);
                this.startSizeY.deserialize(element.startSizeY);
                this.startSizeZ.deserialize(element.startSizeZ);
                this._startRotation3D = (element._startRotation3D || element.startRotation3D) || false;
                this.startRotationX.deserialize(element.startRotationX);
                this.startRotationY.deserialize(element.startRotationY);
                this.startRotationZ.deserialize(element.startRotationZ);
                this.startColor.deserialize(element.startColor);
                this.gravityModifier.deserialize(element.gravityModifier);
                this._simulationSpace = (element._simulationSpace || element.simulationSpace) || 0;
                this._scaleMode = (element._scaleMode || element.scaleMode) || 0 /* Hierarchy */;
                this.playOnAwake = element.playOnAwake;
                this._maxParticles = (element._maxParticles || element.maxParticles) || 0;
                return this;
            };
            Object.defineProperty(MainModule.prototype, "startRotation3D", {
                get: function () {
                    return this._startRotation3D;
                },
                set: function (value) {
                    if (this._startRotation3D !== value) {
                        this._startRotation3D = value;
                        paper.EventPool.dispatchEvent("rotation3DChanged" /* StartRotation3DChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "simulationSpace", {
                get: function () {
                    return this._simulationSpace;
                },
                set: function (value) {
                    if (this._simulationSpace !== value) {
                        this._simulationSpace = value;
                        paper.EventPool.dispatchEvent("simulationSpace" /* SimulationSpaceChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "scaleMode", {
                get: function () {
                    return this._scaleMode;
                },
                set: function (value) {
                    if (this._scaleMode !== value) {
                        this._scaleMode = value;
                        paper.EventPool.dispatchEvent("scaleMode" /* ScaleModeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "maxParticles", {
                get: function () {
                    return this._maxParticles;
                },
                set: function (value) {
                    if (this._maxParticles !== value) {
                        this._maxParticles = value;
                        paper.EventPool.dispatchEvent("maxParticles" /* MaxParticlesChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "duration", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "loop", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startDelay", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startLifetime", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSpeed", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_startRotation3D", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startColor", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "gravityModifier", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_simulationSpace", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_scaleMode", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "playOnAwake", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_maxParticles", void 0);
            return MainModule;
        }(ParticleSystemModule));
        particle.MainModule = MainModule;
        __reflect(MainModule.prototype, "egret3d.particle.MainModule");
        var EmissionModule = (function (_super) {
            __extends(EmissionModule, _super);
            function EmissionModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.rateOverTime = new MinMaxCurve();
                _this.bursts = new Array();
                return _this;
            }
            EmissionModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.rateOverTime.deserialize(element.rateOverTime);
                if (element.bursts) {
                    this.bursts.length = 0;
                    for (var i = 0, l = element.bursts.length; i < l; i++) {
                        var burst = new Burst();
                        burst.deserialize(element.bursts[i]);
                        this.bursts.push(burst);
                    }
                }
                return this;
            };
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "rateOverTime", void 0);
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "bursts", void 0);
            return EmissionModule;
        }(ParticleSystemModule));
        particle.EmissionModule = EmissionModule;
        __reflect(EmissionModule.prototype, "egret3d.particle.EmissionModule");
        var ShapeModule = (function (_super) {
            __extends(ShapeModule, _super);
            function ShapeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.shapeType = 0 /* Sphere */;
                _this.radius = 0.0;
                _this.angle = 0.0;
                _this.length = 0.0;
                _this.arcSpeed = new MinMaxCurve();
                _this.arcMode = 0 /* Random */;
                _this.radiusMode = 0 /* Random */;
                _this.box = new egret3d.Vector3();
                _this.randomDirection = false;
                _this.spherizeDirection = false;
                return _this;
            }
            ShapeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.shapeType = element.shapeType;
                this.radius = element.radius;
                this.angle = element.angle;
                this.length = element.length;
                this.arcSpeed.deserialize(element.arcSpeed);
                this.arcMode = element.arcMode;
                this.radiusSpread = element.radiusSpread;
                this.radiusMode = element.radiusMode;
                this.box.deserialize(element.box);
                this.randomDirection = element.randomDirection;
                this.spherizeDirection = element.spherizeDirection;
                return this;
            };
            ShapeModule.prototype.invalidUpdate = function () {
                paper.EventPool.dispatchEvent("shapeChanged" /* ShapeChanged */, this._comp);
            };
            ShapeModule.prototype.generatePositionAndDirection = function (position, direction) {
                particle.generatePositionAndDirection(position, direction, this);
            };
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "shapeType", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radius", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "angle", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "length", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcSpeed", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusSpread", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "box", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "randomDirection", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "spherizeDirection", void 0);
            return ShapeModule;
        }(ParticleSystemModule));
        particle.ShapeModule = ShapeModule;
        __reflect(ShapeModule.prototype, "egret3d.particle.ShapeModule");
        var VelocityOverLifetimeModule = (function (_super) {
            __extends(VelocityOverLifetimeModule, _super);
            function VelocityOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._mode = 0 /* Constant */;
                /**
                 * @internal
                 */
                _this._space = 0 /* Local */;
                /**
                 * @internal
                 */
                _this._x = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._y = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._z = new MinMaxCurve();
                return _this;
            }
            VelocityOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._mode = (element._mode || element.mode) || 0 /* Constant */;
                this._space = (element._space || element.space) || 0 /* Local */;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "mode", {
                get: function () {
                    return this._mode;
                },
                set: function (value) {
                    if (this._mode !== value) {
                        this._mode = value;
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "space", {
                get: function () {
                    return this._space;
                },
                set: function (value) {
                    if (this._space !== value) {
                        this._space = value;
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "x", {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._x !== value) {
                        this._x.clone(value);
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "y", {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._y !== value) {
                        this._y.clone(value);
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "z", {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    if (this._z !== value) {
                        this._z.clone(value);
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_mode", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_space", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_z", void 0);
            return VelocityOverLifetimeModule;
        }(ParticleSystemModule));
        particle.VelocityOverLifetimeModule = VelocityOverLifetimeModule;
        __reflect(VelocityOverLifetimeModule.prototype, "egret3d.particle.VelocityOverLifetimeModule");
        var ColorOverLifetimeModule = (function (_super) {
            __extends(ColorOverLifetimeModule, _super);
            function ColorOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._color = new MinMaxGradient();
                return _this;
            }
            ColorOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._color.deserialize(element._color || element.color);
                return this;
            };
            Object.defineProperty(ColorOverLifetimeModule.prototype, "color", {
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    if (this._color !== value) {
                        this._color = value;
                        paper.EventPool.dispatchEvent("colorChanged" /* ColorChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ColorOverLifetimeModule.prototype, "_color", void 0);
            return ColorOverLifetimeModule;
        }(ParticleSystemModule));
        particle.ColorOverLifetimeModule = ColorOverLifetimeModule;
        __reflect(ColorOverLifetimeModule.prototype, "egret3d.particle.ColorOverLifetimeModule");
        var SizeOverLifetimeModule = (function (_super) {
            __extends(SizeOverLifetimeModule, _super);
            function SizeOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._separateAxes = false;
                /**
                 * @internal
                 */
                _this._size = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._x = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._y = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._z = new MinMaxCurve();
                return _this;
            }
            SizeOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._size.deserialize(element._size || element.size);
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(SizeOverLifetimeModule.prototype, "separateAxes", {
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes !== value) {
                        this._separateAxes = value;
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "size", {
                get: function () {
                    return this._size;
                },
                set: function (value) {
                    if (this._size !== value) {
                        this._size.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "x", {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._x !== value) {
                        this._x.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "y", {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._y !== value) {
                        this._y.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "z", {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    if (this._z !== value) {
                        this._z.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_size", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_z", void 0);
            return SizeOverLifetimeModule;
        }(ParticleSystemModule));
        particle.SizeOverLifetimeModule = SizeOverLifetimeModule;
        __reflect(SizeOverLifetimeModule.prototype, "egret3d.particle.SizeOverLifetimeModule");
        var RotationOverLifetimeModule = (function (_super) {
            __extends(RotationOverLifetimeModule, _super);
            function RotationOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._x = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._y = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._z = new MinMaxCurve();
                return _this;
            }
            RotationOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(RotationOverLifetimeModule.prototype, "separateAxes", {
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes !== value) {
                        this._separateAxes = value;
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "x", {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._x !== value) {
                        this._x.clone(value);
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "y", {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._y !== value) {
                        this._y.clone(value);
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "z", {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    if (this._z !== value) {
                        this._z.clone(value);
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_z", void 0);
            return RotationOverLifetimeModule;
        }(ParticleSystemModule));
        particle.RotationOverLifetimeModule = RotationOverLifetimeModule;
        __reflect(RotationOverLifetimeModule.prototype, "egret3d.particle.RotationOverLifetimeModule");
        var TextureSheetAnimationModule = (function (_super) {
            __extends(TextureSheetAnimationModule, _super);
            function TextureSheetAnimationModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._animation = 0 /* WholeSheet */;
                /**
                 * @internal
                 */
                _this._frameOverTime = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._startFrame = new MinMaxCurve();
                _this._floatValues = new Float32Array(4);
                return _this;
            }
            TextureSheetAnimationModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._numTilesX = (element._numTilesX || element.numTilesX) || 0;
                this._numTilesY = (element._numTilesY || element.numTilesY) || 0;
                this._animation = (element._animation || element.animation) || 0 /* WholeSheet */;
                this._useRandomRow = (element._useRandomRow || element.useRandomRow) || false;
                this._frameOverTime.deserialize(element._frameOverTime || element.frameOverTime);
                this._startFrame.deserialize(element._startFrame || element.startFrame);
                this._cycleCount = (element._cycleCount || element.cycleCount) || 0;
                this._rowIndex = (element._rowIndex || element.rowIndex) || 0;
                return this;
            };
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesX", {
                get: function () {
                    return this._numTilesX;
                },
                set: function (value) {
                    if (this._numTilesX !== value) {
                        this._numTilesX = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesY", {
                get: function () {
                    return this._numTilesY;
                },
                set: function (value) {
                    if (this._numTilesY !== value) {
                        this._numTilesY = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "animation", {
                get: function () {
                    return this._animation;
                },
                set: function (value) {
                    if (this._animation !== value) {
                        this._animation = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "useRandomRow", {
                get: function () {
                    return this._useRandomRow;
                },
                set: function (value) {
                    if (this._useRandomRow !== value) {
                        this._useRandomRow = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "frameOverTime", {
                get: function () {
                    return this._frameOverTime;
                },
                set: function (value) {
                    if (this._frameOverTime !== value) {
                        this._frameOverTime.clone(value);
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "startFrame", {
                get: function () {
                    return this._startFrame;
                },
                set: function (value) {
                    if (this._startFrame !== value) {
                        this._startFrame.clone(value);
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "cycleCount", {
                get: function () {
                    return this._cycleCount;
                },
                set: function (value) {
                    if (this._cycleCount !== value) {
                        this._cycleCount = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "rowIndex", {
                get: function () {
                    return this._rowIndex;
                },
                set: function (value) {
                    if (this._rowIndex !== value) {
                        this._rowIndex = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    if (this.enable) {
                        var subU = 1.0 / this._numTilesX;
                        var subV = 1.0 / this._numTilesY;
                        var startFrmaeCount = Math.floor(this._startFrame.constant);
                        var startRow = 0;
                        switch (this._animation) {
                            case 1 /* SingleRow */:
                                {
                                    if (this._useRandomRow) {
                                        startRow = Math.floor(Math.random() * this._numTilesY);
                                    }
                                    else {
                                        startRow = this._rowIndex;
                                    }
                                    break;
                                }
                            case 0 /* WholeSheet */:
                                {
                                    startRow = Math.floor(startFrmaeCount / this._numTilesX);
                                    break;
                                }
                        }
                        var startCol = Math.floor(startFrmaeCount % this._numTilesX);
                        res[0] = subU;
                        res[1] = subV;
                        res[2] = startCol * subU;
                        res[3] = startRow * subV;
                    }
                    else {
                        res[0] = 1.0;
                        res[1] = 1.0;
                        res[2] = 0.0;
                        res[3] = 0.0;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesX", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesY", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_animation", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_useRandomRow", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_frameOverTime", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_startFrame", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_cycleCount", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_rowIndex", void 0);
            return TextureSheetAnimationModule;
        }(ParticleSystemModule));
        particle.TextureSheetAnimationModule = TextureSheetAnimationModule;
        __reflect(TextureSheetAnimationModule.prototype, "egret3d.particle.TextureSheetAnimationModule");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        //
        var positionHelper = new egret3d.Vector3();
        var velocityHelper = new egret3d.Vector3();
        var startSizeHelper = new egret3d.Vector3();
        var startColorHelper = egret3d.Color.create();
        var startRotationHelper = new egret3d.Vector3();
        var GRAVITY = new egret3d.Vector3(0, -9.81, 0); //TODO没有物理系统，暂时先放到这里
        /**
         * @internal
         */
        var ParticleBatcher = (function () {
            function ParticleBatcher() {
                this._dirty = false;
                this._time = 0.0;
                this._emittsionTime = 0;
                this._frameRateTime = 0;
                //最新存活位置
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                //最后存活位置
                this._lastAliveCursor = 0;
                this._forceUpdate = false;
                //原始顶点数量
                this._vertexStride = 0;
                //当前爆发的索引
                this._burstIndex = 0;
                //
                this._readEmitCount = 0;
                //最终重力
                this._finalGravity = new egret3d.Vector3();
            }
            /**
            * 计算粒子爆发数量
            * @param startTime
            * @param endTime
            */
            ParticleBatcher.prototype._getBurstCount = function (startTime, endTime) {
                var totalEmitCount = 0;
                var bursts = this._comp.emission.bursts;
                for (var l = bursts.length; this._burstIndex < l; this._burstIndex++) {
                    var burst = bursts[this._burstIndex];
                    if (burst.time >= startTime && burst.time < endTime) {
                        // totalEmitCount += numberLerp(burst.minCount, burst.maxCount, Math.random());
                        totalEmitCount += burst.maxCount;
                    }
                    else {
                        break;
                    }
                }
                return totalEmitCount;
            };
            /**
             * 判断粒子是否已经过期
             * @param particleIndex
             */
            ParticleBatcher.prototype._isParticleExpired = function (particleIndex) {
                var startTimeOffset = particleIndex * this._vertexStride * 2;
                return this._time - this._startTimeBuffer[startTimeOffset + 1] + 0.0001 > this._startTimeBuffer[startTimeOffset];
            };
            /**
             *
             * @param time 批量增加粒子
             * @param startCursor
             * @param endCursor
             */
            ParticleBatcher.prototype._addParticles = function (time, startCursor, count, lastEmittsionTime) {
                var comp = this._comp;
                var main = comp.main;
                var velocityModule = comp.velocityOverLifetime;
                var colorModule = comp.colorOverLifetime;
                var sizeModule = comp.sizeOverLifetime;
                var rotationModule = comp.rotationOverLifetime;
                var textureSheetModule = comp.textureSheetAnimation;
                var isVelocityRandom = velocityModule.enable && (velocityModule._mode === 3 /* TwoConstants */ || velocityModule._mode === 2 /* TwoCurves */);
                var isColorRandom = colorModule.enable && colorModule._color.mode === 3 /* TwoGradients */;
                var isSizeRandom = sizeModule.enable && (sizeModule._size.mode === 3 /* TwoConstants */ || sizeModule._size.mode === 2 /* TwoCurves */);
                var isRotationRandom = rotationModule.enable && (rotationModule._x.mode === 3 /* TwoConstants */ || rotationModule._x.mode === 2 /* TwoCurves */);
                var isTextureRandom = textureSheetModule.enable && (textureSheetModule._startFrame.mode === 3 /* TwoConstants */ || textureSheetModule._startFrame.mode === 2 /* TwoCurves */);
                var needRandom0 = isColorRandom || isSizeRandom || isRotationRandom || isTextureRandom;
                var worldPosition = this._worldPostionCache;
                var worldRotation = this._worldRotationCache;
                var isWorldSpace = main._simulationSpace === 1 /* World */;
                var startPositionBuffer = this._startPositionBuffer;
                var startVelocityBuffer = this._startVelocityBuffer;
                var startColorBuffer = this._startColorBuffer;
                var startSizeBuffer = this._startSizeBuffer;
                var startRotationBuffer = this._startRotationBuffer;
                var startTimeBuffer = this._startTimeBuffer;
                var random0Buffer = this._random0Buffer;
                var random1Buffer = this._random1Buffer;
                var worldPostionBuffer = this._worldPostionBuffer;
                var worldRoationBuffer = this._worldRoationBuffer;
                var age = Math.min(lastEmittsionTime / main.duration, 1.0);
                var vertexStride = this._vertexStride;
                var addCount = 0, startIndex = 0, endIndex = 0;
                var lifetime = 0.0;
                var startSpeed = 0.0;
                var randomVelocityX = 0.0, randomVelocityY = 0.0, randomVelocityZ = 0.0;
                var randomColor = 0.0, randomSize = 0.0, randomRotation = 0.0, randomTextureAnimation = 0.0;
                var vector2Offset = 0, vector3Offset = 0, vector4Offset = 0;
                while (addCount !== count) {
                    comp.shape.generatePositionAndDirection(positionHelper, velocityHelper);
                    main.startColor.evaluate(age, startColorHelper);
                    lifetime = main.startLifetime.evaluate(age);
                    startSpeed = main.startSpeed.evaluate(age);
                    velocityHelper.x *= startSpeed;
                    velocityHelper.y *= startSpeed;
                    velocityHelper.z *= startSpeed;
                    startSizeHelper.x = main.startSizeX.evaluate(age);
                    startSizeHelper.y = main.startSizeY.evaluate(age);
                    startSizeHelper.z = main.startSizeZ.evaluate(age);
                    startRotationHelper.x = main.startRotationX.evaluate(age);
                    startRotationHelper.y = main.startRotationY.evaluate(age);
                    startRotationHelper.z = main.startRotationZ.evaluate(age);
                    randomVelocityX = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityY = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityZ = isVelocityRandom ? Math.random() : 0.0;
                    randomColor = isColorRandom ? Math.random() : 0.0;
                    randomSize = isSizeRandom ? Math.random() : 0.0;
                    randomRotation = isRotationRandom ? Math.random() : 0.0;
                    randomTextureAnimation = isTextureRandom ? Math.random() : 0.0;
                    for (startIndex = startCursor * vertexStride, endIndex = startIndex + vertexStride; startIndex < endIndex; startIndex++) {
                        vector2Offset = startIndex * 2;
                        vector3Offset = startIndex * 3;
                        vector4Offset = startIndex * 4;
                        //
                        startPositionBuffer[vector3Offset] = positionHelper.x;
                        startPositionBuffer[vector3Offset + 1] = positionHelper.y;
                        startPositionBuffer[vector3Offset + 2] = positionHelper.z;
                        startVelocityBuffer[vector3Offset] = velocityHelper.x;
                        startVelocityBuffer[vector3Offset + 1] = velocityHelper.y;
                        startVelocityBuffer[vector3Offset + 2] = velocityHelper.z;
                        startColorBuffer[vector4Offset] = startColorHelper.r;
                        startColorBuffer[vector4Offset + 1] = startColorHelper.g;
                        startColorBuffer[vector4Offset + 2] = startColorHelper.b;
                        startColorBuffer[vector4Offset + 3] = startColorHelper.a;
                        startSizeBuffer[vector3Offset] = startSizeHelper.x;
                        startSizeBuffer[vector3Offset + 1] = startSizeHelper.y;
                        startSizeBuffer[vector3Offset + 2] = startSizeHelper.z;
                        startRotationBuffer[vector3Offset] = startRotationHelper.x;
                        startRotationBuffer[vector3Offset + 1] = startRotationHelper.y;
                        startRotationBuffer[vector3Offset + 2] = startRotationHelper.z;
                        startTimeBuffer[vector2Offset] = lifetime;
                        startTimeBuffer[vector2Offset + 1] = time;
                        //
                        if (needRandom0) {
                            random0Buffer[vector4Offset] = randomColor;
                            random0Buffer[vector4Offset + 1] = randomSize;
                            random0Buffer[vector4Offset + 2] = randomRotation;
                            random0Buffer[vector4Offset + 3] = randomTextureAnimation;
                        }
                        if (isVelocityRandom) {
                            random1Buffer[vector4Offset] = randomVelocityX;
                            random1Buffer[vector4Offset + 1] = randomVelocityY;
                            random1Buffer[vector4Offset + 2] = randomVelocityZ;
                            random1Buffer[vector4Offset + 3] = 0;
                        }
                        if (isWorldSpace) {
                            worldPostionBuffer[vector3Offset] = worldPosition.x;
                            worldPostionBuffer[vector3Offset + 1] = worldPosition.y;
                            worldPostionBuffer[vector3Offset + 2] = worldPosition.z;
                            worldRoationBuffer[vector4Offset] = worldRotation.x;
                            worldRoationBuffer[vector4Offset + 1] = worldRotation.y;
                            worldRoationBuffer[vector4Offset + 2] = worldRotation.z;
                            worldRoationBuffer[vector4Offset + 3] = worldRotation.w;
                        }
                    }
                    ;
                    startCursor++;
                    if (startCursor >= main._maxParticles) {
                        startCursor = 0;
                    }
                    addCount++;
                }
                //TODO理论上应该是每帧更新，不过现在没有物理系统，先放到这里
                var gravityModifier = main.gravityModifier.constant;
                this._finalGravity.x = GRAVITY.x * gravityModifier;
                this._finalGravity.y = GRAVITY.y * gravityModifier;
                this._finalGravity.z = GRAVITY.z * gravityModifier;
            };
            ParticleBatcher.prototype._tryEmit = function () {
                if (!this._isParticleExpired(this._firstAliveCursor)) {
                    return false;
                }
                //
                var maxParticles = this._comp.main._maxParticles;
                var nextCursor = this._firstAliveCursor + 1 >= maxParticles ? 0 : this._firstAliveCursor + 1;
                //
                if (nextCursor === this._lastAliveCursor) {
                    this._forceUpdate = true;
                }
                this._firstAliveCursor = nextCursor;
                return true;
            };
            ParticleBatcher.prototype.clean = function () {
                this._time = 0.0;
                this._dirty = false;
                this._emittsionTime = 0.0;
                this._frameRateTime = 0.0;
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                this._lastAliveCursor = 0;
                this._forceUpdate = false;
                this._vertexStride = 0;
                this._vertexAttributes = null;
                this._burstIndex = 0;
                this._readEmitCount = 0;
                this._startPositionBuffer = null;
                this._startVelocityBuffer = null;
                this._startColorBuffer = null;
                this._startSizeBuffer = null;
                this._startRotationBuffer = null;
                this._startTimeBuffer = null;
                this._random0Buffer = null;
                this._random1Buffer = null;
                this._worldPostionBuffer = null;
                this._worldRoationBuffer = null;
                this._worldPostionCache = null;
                this._worldRotationCache = null;
                this._comp = null;
                this._renderer = null;
            };
            ParticleBatcher.prototype.resetTime = function () {
                this._burstIndex = 0;
                this._emittsionTime = 0;
                this._readEmitCount = 0;
            };
            ParticleBatcher.prototype.init = function (comp, renderer) {
                this._comp = comp;
                this._renderer = renderer;
                var mesh = particle.createBatchMesh(renderer, comp.main._maxParticles);
                this._vertexStride = renderer._renderMode === 4 /* Mesh */ ? renderer.mesh.vertexCount : 4;
                this._startPositionBuffer = mesh.getAttributes("_START_POSITION" /* _START_POSITION */);
                this._startVelocityBuffer = mesh.getAttributes("_START_VELOCITY" /* _START_VELOCITY */);
                this._startColorBuffer = mesh.getAttributes("_START_COLOR" /* _START_COLOR */);
                this._startSizeBuffer = mesh.getAttributes("_START_SIZE" /* _START_SIZE */);
                this._startRotationBuffer = mesh.getAttributes("_START_ROTATION" /* _START_ROTATION */);
                this._startTimeBuffer = mesh.getAttributes("_TIME" /* _TIME */);
                this._random0Buffer = mesh.getAttributes("_RANDOM0" /* _RANDOM0 */);
                this._random1Buffer = mesh.getAttributes("_RANDOM1" /* _RANDOM1 */);
                this._worldPostionBuffer = mesh.getAttributes("_WORLD_POSITION" /* _WORLD_POSITION */);
                this._worldRoationBuffer = mesh.getAttributes("_WORLD_ROTATION" /* _WORLD_ROTATION */);
                var primitive = mesh.glTFMesh.primitives[0];
                this._vertexAttributes = [];
                for (var k in primitive.attributes) {
                    this._vertexAttributes.push(k);
                }
                renderer.batchMesh = mesh;
                renderer.batchMaterial = renderer.materials[0].clone();
                mesh.uploadSubIndexBuffer();
            };
            ParticleBatcher.prototype.update = function (elapsedTime) {
                if (!this._comp || this._comp.isPaused) {
                    return;
                }
                //
                this._time += elapsedTime;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                while (this._lastAliveCursor !== this._firstAliveCursor || this._forceUpdate) {
                    if (!this._isParticleExpired(this._lastAliveCursor)) {
                        break;
                    }
                    this._forceUpdate = false;
                    this._lastAliveCursor++;
                    if (this._lastAliveCursor >= mainModule._maxParticles) {
                        this._lastAliveCursor = 0;
                    }
                }
                var transform = comp.gameObject.transform;
                this._worldPostionCache = transform.getPosition();
                this._worldRotationCache = transform.getRotation();
                if (comp._isPlaying && this._time >= mainModule.startDelay.constant && comp.emission.enable) {
                    this._updateEmission(elapsedTime);
                }
                this._updateRender();
            };
            ParticleBatcher.prototype._updateEmission = function (elapsedTime) {
                var comp = this._comp;
                var mainModule = comp.main;
                var lastEmittsionTime = this._emittsionTime;
                this._emittsionTime += elapsedTime;
                var isOver = this._emittsionTime > mainModule.duration;
                var aliveParticleCount = this.aliveParticleCount;
                var totalEmitCount = 0;
                if (!isOver) {
                    if (comp.emission.bursts.length > 0) {
                        this._readEmitCount += this._getBurstCount(lastEmittsionTime, this._emittsionTime);
                    }
                }
                else {
                    if (mainModule.loop) {
                        this._readEmitCount = 0;
                        this._readEmitCount += this._getBurstCount(lastEmittsionTime, this._emittsionTime);
                        this._emittsionTime -= mainModule.duration;
                        this._burstIndex = 0;
                        this._readEmitCount += this._getBurstCount(0, this._emittsionTime);
                    }
                    else {
                        comp.stop(false);
                    }
                }
                //
                for (var i = 0; i < this._readEmitCount; i++) {
                    if (this._tryEmit()) {
                        totalEmitCount++;
                        this._readEmitCount--;
                    }
                }
                var rateOverTime = comp.emission.rateOverTime.constant;
                if (rateOverTime > 0) {
                    var minEmissionTime = 1 / rateOverTime;
                    this._frameRateTime += elapsedTime;
                    while (this._frameRateTime > minEmissionTime) {
                        if (!this._tryEmit()) {
                            break;
                        }
                        totalEmitCount++;
                        this._frameRateTime -= minEmissionTime;
                    }
                }
                totalEmitCount = Math.min(mainModule._maxParticles - aliveParticleCount, totalEmitCount);
                if (totalEmitCount > 0) {
                    this._addParticles(this._time, this._lastFrameFirstCursor, totalEmitCount, lastEmittsionTime);
                    this._dirty = true;
                }
            };
            ParticleBatcher.prototype._updateRender = function () {
                var renderer = this._renderer;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                if (this._dirty) {
                    renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes);
                    // const bufferOffset = this._lastFrameFirstCursor * this._vertexStride;
                    // const bufferOffset = this._lastFrameFirstCursor;
                    // if (this._firstAliveCursor > this._lastFrameFirstCursor) {
                    //     const bufferCount = (this._firstAliveCursor - this._lastFrameFirstCursor) * this._vertexStride;
                    //     // const bufferCount = (this._firstAliveCursor - this._lastFrameFirstCursor);
                    //     renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, bufferOffset, bufferCount);
                    // }
                    // else {
                    //     const addCount = mainModule._maxParticles - this._lastFrameFirstCursor;
                    //     renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, bufferOffset, addCount * this._vertexStride);
                    //     renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, 0, this._firstAliveCursor * this._vertexStride);
                    //     // renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, bufferOffset, addCount);
                    //     // renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, 0, this._firstAliveCursor);
                    // }
                    this._lastFrameFirstCursor = this._firstAliveCursor;
                    this._dirty = false;
                }
                var transform = comp.gameObject.transform;
                var material = renderer.batchMaterial;
                if (mainModule._simulationSpace === 0 /* Local */) {
                    material.setVector3("u_worldPosition" /* WORLD_POSITION */, this._worldPostionCache);
                    material.setVector4("u_worldRotation" /* WORLD_ROTATION */, this._worldRotationCache);
                }
                //
                switch (mainModule._scaleMode) {
                    case 1 /* Local */:
                        {
                            var scale = transform.getLocalScale();
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                    case 2 /* Shape */:
                        {
                            var scale = transform.getScale();
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, egret3d.Vector3.ONE);
                        }
                        break;
                    case 0 /* Hierarchy */:
                        {
                            var scale = transform.getScale();
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                }
                material.setFloat("u_currentTime" /* CURRENTTIME */, this._time);
                material.setVector3("u_gravity" /* GRAVIT */, this._finalGravity);
            };
            Object.defineProperty(ParticleBatcher.prototype, "aliveParticleCount", {
                get: function () {
                    if (this._firstAliveCursor >= this._lastAliveCursor) {
                        return this._firstAliveCursor - this._lastAliveCursor;
                    }
                    else {
                        return this._comp.main._maxParticles - this._lastAliveCursor + this._firstAliveCursor;
                    }
                },
                enumerable: true,
                configurable: true
            });
            return ParticleBatcher;
        }());
        particle.ParticleBatcher = ParticleBatcher;
        __reflect(ParticleBatcher.prototype, "egret3d.particle.ParticleBatcher");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        var ParticleCompEventType;
        (function (ParticleCompEventType) {
            ParticleCompEventType["MainChanged"] = "mainChanged";
            ParticleCompEventType["ColorChanged"] = "colorChanged";
            ParticleCompEventType["VelocityChanged"] = "velocityChanged";
            ParticleCompEventType["SizeChanged"] = "sizeChanged";
            ParticleCompEventType["RotationChanged"] = "rotationChanged";
            ParticleCompEventType["TextureSheetChanged"] = "textureSheetChanged";
            ParticleCompEventType["ShapeChanged"] = "shapeChanged";
            ParticleCompEventType["StartRotation3DChanged"] = "rotation3DChanged";
            ParticleCompEventType["SimulationSpaceChanged"] = "simulationSpace";
            ParticleCompEventType["ScaleModeChanged"] = "scaleMode";
            ParticleCompEventType["MaxParticlesChanged"] = "maxParticles";
        })(ParticleCompEventType = particle.ParticleCompEventType || (particle.ParticleCompEventType = {}));
        var ParticleComponent = (function (_super) {
            __extends(ParticleComponent, _super);
            function ParticleComponent() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                //主模块
                _this.main = new particle.MainModule(_this);
                //发射模块
                _this.emission = new particle.EmissionModule(_this);
                //发射形状模块
                _this.shape = new particle.ShapeModule(_this);
                //速率变换模块
                _this.velocityOverLifetime = new particle.VelocityOverLifetimeModule(_this);
                //旋转变换模块
                _this.rotationOverLifetime = new particle.RotationOverLifetimeModule(_this);
                //尺寸变化模块
                _this.sizeOverLifetime = new particle.SizeOverLifetimeModule(_this);
                //颜色变化模块
                _this.colorOverLifetime = new particle.ColorOverLifetimeModule(_this);
                //序列帧变化模块
                _this.textureSheetAnimation = new particle.TextureSheetAnimationModule(_this);
                /**
                 * @internal
                 */
                _this._isPlaying = false;
                /**
                 * @internal
                 */
                _this._isPaused = false;
                _this._batcher = new particle.ParticleBatcher();
                return _this;
            }
            /**
             * @internal
             */
            ParticleComponent.prototype._clean = function () {
                //
                this._batcher.clean();
                this._isPlaying = false;
                this._isPaused = false;
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                this._clean();
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.initialize = function () {
                _super.prototype.initialize.call(this);
                this._clean();
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.initBatcher = function () {
                this._clean();
                this._batcher.init(this, this.gameObject.getComponent(particle.ParticleRenderer));
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.update = function (elapsedTime) {
                this._batcher.update(elapsedTime);
            };
            ParticleComponent.prototype.play = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (this._isPaused) {
                    this._isPaused = false;
                }
                else {
                    this._isPlaying = true;
                    this._isPaused = false;
                    this._batcher.resetTime();
                }
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                        var child = children_1[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.play(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.pause = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPaused = true;
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
                        var child = children_2[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.pause(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.stop = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPlaying = false;
                this._batcher.resetTime();
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_3 = children; _i < children_3.length; _i++) {
                        var child = children_3[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.clear = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_4 = children; _i < children_4.length; _i++) {
                        var child = children_4[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            Object.defineProperty(ParticleComponent.prototype, "loop", {
                get: function () {
                    return this.main.loop;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isPlaying", {
                get: function () {
                    return this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isPaused", {
                get: function () {
                    return this._isPaused;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isAlive", {
                get: function () {
                    return this._batcher.aliveParticleCount > 0 || this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "main", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "emission", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "shape", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "velocityOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "rotationOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "sizeOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "colorOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "textureSheetAnimation", void 0);
            return ParticleComponent;
        }(paper.BaseComponent));
        particle.ParticleComponent = ParticleComponent;
        __reflect(ParticleComponent.prototype, "egret3d.particle.ParticleComponent");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        var _helpMatrix = egret3d.Matrix4.create();
        var ParticleRendererEventType;
        (function (ParticleRendererEventType) {
            ParticleRendererEventType["Mesh"] = "mesh";
            ParticleRendererEventType["Materials"] = "materials";
            ParticleRendererEventType["RenderMode"] = "renderMode";
            ParticleRendererEventType["LengthScaleChanged"] = "lengthScale";
            ParticleRendererEventType["VelocityScaleChanged"] = "velocityScale";
        })(ParticleRendererEventType = particle.ParticleRendererEventType || (particle.ParticleRendererEventType = {}));
        var ParticleRenderMode;
        (function (ParticleRenderMode) {
            ParticleRenderMode[ParticleRenderMode["Billboard"] = 0] = "Billboard";
            ParticleRenderMode[ParticleRenderMode["Stretch"] = 1] = "Stretch";
            ParticleRenderMode[ParticleRenderMode["HorizontalBillboard"] = 2] = "HorizontalBillboard";
            ParticleRenderMode[ParticleRenderMode["VerticalBillboard"] = 3] = "VerticalBillboard";
            ParticleRenderMode[ParticleRenderMode["Mesh"] = 4] = "Mesh";
            ParticleRenderMode[ParticleRenderMode["None"] = 5] = "None";
        })(ParticleRenderMode = particle.ParticleRenderMode || (particle.ParticleRenderMode = {}));
        /**
         * 粒子着色器用到的变量
         */
        var ParticleMaterialUniform;
        (function (ParticleMaterialUniform) {
            ParticleMaterialUniform["WORLD_POSITION"] = "u_worldPosition";
            ParticleMaterialUniform["WORLD_ROTATION"] = "u_worldRotation";
            ParticleMaterialUniform["POSITION_SCALE"] = "u_positionScale";
            ParticleMaterialUniform["SIZE_SCALE"] = "u_sizeScale";
            ParticleMaterialUniform["SCALING_MODE"] = "u_scalingMode";
            ParticleMaterialUniform["GRAVIT"] = "u_gravity";
            ParticleMaterialUniform["START_ROTATION3D"] = "u_startRotation3D";
            ParticleMaterialUniform["SIMULATION_SPACE"] = "u_simulationSpace";
            ParticleMaterialUniform["CURRENTTIME"] = "u_currentTime";
            ParticleMaterialUniform["ALPHAS_GRADIENT"] = "u_alphaGradient[0]";
            ParticleMaterialUniform["COLOR_GRADIENT"] = "u_colorGradient[0]";
            ParticleMaterialUniform["ALPHA_GRADIENT_MAX"] = "u_alphaGradientMax[0]";
            ParticleMaterialUniform["COLOR_GRADIENT_MAX"] = "u_colorGradientMax[0]";
            ParticleMaterialUniform["VELOCITY_CONST"] = "u_velocityConst";
            ParticleMaterialUniform["VELOCITY_CURVE_X"] = "u_velocityCurveX[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_Y"] = "u_velocityCurveY[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_Z"] = "u_velocityCurveZ[0]";
            ParticleMaterialUniform["VELOCITY_CONST_MAX"] = "u_velocityConstMax";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_X"] = "u_velocityCurveMaxX[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_Y"] = "u_velocityCurveMaxY[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_Z"] = "u_velocityCurveMaxZ[0]";
            ParticleMaterialUniform["SPACE_TYPE"] = "u_spaceType";
            ParticleMaterialUniform["SIZE_CURVE"] = "u_sizeCurve[0]";
            ParticleMaterialUniform["SIZE_CURVE_X"] = "u_sizeCurveX[0]";
            ParticleMaterialUniform["SIZE_CURVE_Y"] = "u_sizeCurveY[0]";
            ParticleMaterialUniform["SIZE_CURVE_Z"] = "u_sizeCurveZ[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX"] = "u_sizeCurveMax[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_X"] = "u_sizeCurveMaxX[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_Y"] = "u_sizeCurveMaxY[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_Z"] = "u_sizeCurveMaxZ[0]";
            ParticleMaterialUniform["ROTATION_CONST"] = "u_rotationConst";
            ParticleMaterialUniform["ROTATION_CONST_SEPRARATE"] = "u_rotationConstSeprarate";
            ParticleMaterialUniform["ROTATION_CURVE"] = "u_rotationCurve[0]";
            ParticleMaterialUniform["ROTATE_CURVE_X"] = "u_rotationCurveX[0]";
            ParticleMaterialUniform["ROTATE_CURVE_y"] = "u_rotationCurveY[0]";
            ParticleMaterialUniform["ROTATE_CURVE_Z"] = "u_rotationCurveZ[0]";
            ParticleMaterialUniform["ROTATE_CURVE_W"] = "u_rotationCurveW[0]";
            ParticleMaterialUniform["ROTATION_CONST_MAX"] = "u_rotationConstMax";
            ParticleMaterialUniform["ROTATION_CONST_MAX_SEPRARATE"] = "u_rotationConstMaxSeprarate";
            ParticleMaterialUniform["ROTATION_CURVE_MAX"] = "u_rotationCurveMax[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_X"] = "u_rotationCurveMaxX[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_Y"] = "u_rotationCurveMaxY[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_Z"] = "u_rotationCurveMaxZ[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_W"] = "u_rotationCurveMaxW[0]";
            ParticleMaterialUniform["CYCLES"] = "u_cycles";
            ParticleMaterialUniform["SUB_UV"] = "u_subUV";
            ParticleMaterialUniform["UV_CURVE"] = "u_uvCurve[0]";
            ParticleMaterialUniform["UV_CURVE_MAX"] = "u_uvCurveMax[0]";
            ParticleMaterialUniform["LENGTH_SCALE"] = "u_lengthScale";
            ParticleMaterialUniform["SPEED_SCALE"] = "u_speeaScale";
        })(ParticleMaterialUniform = particle.ParticleMaterialUniform || (particle.ParticleMaterialUniform = {}));
        /**
         * 粒子着色器用到的宏定义
         */
        var ParticleMaterialDefine;
        (function (ParticleMaterialDefine) {
            ParticleMaterialDefine["SPHERHBILLBOARD"] = "SPHERHBILLBOARD";
            ParticleMaterialDefine["STRETCHEDBILLBOARD"] = "STRETCHEDBILLBOARD";
            ParticleMaterialDefine["HORIZONTALBILLBOARD"] = "HORIZONTALBILLBOARD";
            ParticleMaterialDefine["VERTICALBILLBOARD"] = "VERTICALBILLBOARD";
            ParticleMaterialDefine["ROTATIONOVERLIFETIME"] = "ROTATIONOVERLIFETIME";
            ParticleMaterialDefine["ROTATIONCONSTANT"] = "ROTATIONCONSTANT";
            ParticleMaterialDefine["ROTATIONTWOCONSTANTS"] = "ROTATIONTWOCONSTANTS";
            ParticleMaterialDefine["ROTATIONSEPERATE"] = "ROTATIONSEPERATE";
            ParticleMaterialDefine["ROTATIONCURVE"] = "ROTATIONCURVE";
            ParticleMaterialDefine["ROTATIONTWOCURVES"] = "ROTATIONTWOCURVES";
            ParticleMaterialDefine["TEXTURESHEETANIMATIONCURVE"] = "TEXTURESHEETANIMATIONCURVE";
            ParticleMaterialDefine["TEXTURESHEETANIMATIONTWOCURVE"] = "TEXTURESHEETANIMATIONTWOCURVE";
            ParticleMaterialDefine["VELOCITYCONSTANT"] = "VELOCITYCONSTANT";
            ParticleMaterialDefine["VELOCITYCURVE"] = "VELOCITYCURVE";
            ParticleMaterialDefine["VELOCITYTWOCONSTANT"] = "VELOCITYTWOCONSTANT";
            ParticleMaterialDefine["VELOCITYTWOCURVE"] = "VELOCITYTWOCURVE";
            ParticleMaterialDefine["COLOROGRADIENT"] = "COLOROGRADIENT";
            ParticleMaterialDefine["COLORTWOGRADIENTS"] = "COLORTWOGRADIENTS";
            ParticleMaterialDefine["SIZECURVE"] = "SIZECURVE";
            ParticleMaterialDefine["SIZETWOCURVES"] = "SIZETWOCURVES";
            ParticleMaterialDefine["SIZECURVESEPERATE"] = "SIZECURVESEPERATE";
            ParticleMaterialDefine["SIZETWOCURVESSEPERATE"] = "SIZETWOCURVESSEPERATE";
            ParticleMaterialDefine["RENDERMESH"] = "RENDERMESH";
            ParticleMaterialDefine["SHAPE"] = "SHAPE";
        })(ParticleMaterialDefine = particle.ParticleMaterialDefine || (particle.ParticleMaterialDefine = {}));
        /**
         *
         */
        var ParticleRenderer = (function (_super) {
            __extends(ParticleRenderer, _super);
            function ParticleRenderer() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * TODO
                 */
                _this.frustumCulled = false;
                _this._materials = [];
                _this._renderMode = 0 /* Billboard */;
                return _this;
            }
            ParticleRenderer.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                this._mesh = null;
                this._materials.length = 0;
                this._renderMode = 0 /* Billboard */;
                this.velocityScale = 1.0;
                this.lengthScale = 1.0;
            };
            ParticleRenderer.prototype.recalculateAABB = function () {
                this._aabb.copy(egret3d.AABB.ONE);
            };
            ParticleRenderer.prototype.raycast = function (p1, p2, p3) {
                var raycastMesh = false;
                var raycastInfo = undefined;
                var worldMatrix = this.gameObject.transform.worldMatrix;
                var localRay = egret3d.helpRay.applyMatrix(_helpMatrix.inverse(worldMatrix), p1); // TODO transform inverse world matrix.
                var aabb = this.aabb;
                if (p2) {
                    if (p2 === true) {
                        raycastMesh = true;
                    }
                    else {
                        raycastMesh = p3 || false;
                        raycastInfo = p2;
                    }
                }
                if (aabb.raycast(localRay, raycastInfo)) {
                    if (raycastInfo) {
                        raycastInfo.position.applyMatrix(worldMatrix);
                        raycastInfo.distance = p1.origin.getDistance(raycastInfo.position);
                    }
                    return true;
                }
                return false;
            };
            Object.defineProperty(ParticleRenderer.prototype, "renderMode", {
                get: function () {
                    return this._renderMode;
                },
                set: function (value) {
                    if (this._renderMode === value) {
                        return;
                    }
                    this._renderMode = value;
                    paper.EventPool.dispatchEvent("renderMode" /* RenderMode */, this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleRenderer.prototype, "mesh", {
                /**
                 * mesh model
                 * @version paper 1.0
                 * @platform Web
                 * @language en_US
                 */
                /**
                 * 组件挂载的 mesh 模型
                 * @version paper 1.0
                 * @platform Web
                 * @language
                 */
                get: function () {
                    return this._mesh;
                },
                set: function (mesh) {
                    if (this._mesh === mesh) {
                        return;
                    }
                    this._mesh = mesh;
                    paper.EventPool.dispatchEvent("mesh" /* Mesh */, this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleRenderer.prototype, "materials", {
                /**
                 * material list
                 * @version paper 1.0
                 * @platform Web
                 * @language en_US
                 */
                /**
                 * 材质数组
                 * @version paper 1.0
                 * @platform Web
                 * @language
                 */
                get: function () {
                    return this._materials;
                },
                set: function (value) {
                    if (value === this._materials) {
                        return;
                    }
                    this._materials.length = 0;
                    for (var _i = 0, value_2 = value; _i < value_2.length; _i++) {
                        var material = value_2[_i];
                        this._materials.push(material);
                    }
                    paper.EventPool.dispatchEvent("materials" /* Materials */, this);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_mesh", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_materials", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "velocityScale", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_renderMode", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "lengthScale", void 0);
            __decorate([
                paper.editor.property(18 /* MESH */)
            ], ParticleRenderer.prototype, "mesh", null);
            __decorate([
                paper.editor.property(20 /* ARRAY */)
            ], ParticleRenderer.prototype, "materials", null);
            return ParticleRenderer;
        }(paper.BaseRenderer));
        particle.ParticleRenderer = ParticleRenderer;
        __reflect(ParticleRenderer.prototype, "egret3d.particle.ParticleRenderer");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 全局销毁信息收集组件。
     */
    var DisposeCollecter = (function (_super) {
        __extends(DisposeCollecter, _super);
        function DisposeCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 当前帧销毁的全部场景。
             */
            _this.scenes = [];
            /**
             * 当前帧销毁的全部实体。
             */
            _this.gameObjects = [];
            /**
             * 当前帧销毁的全部组件。
             */
            _this.components = [];
            /**
             *
             */
            _this.releases = DisposeCollecter._releases;
            return _this;
        }
        /**
         * @internal
         */
        DisposeCollecter.prototype.clear = function () {
            this.scenes.length = 0;
            this.gameObjects.length = 0;
            this.components.length = 0;
            this.releases.length = 0;
        };
        /**
         * @internal
         */
        DisposeCollecter._releases = [];
        return DisposeCollecter;
    }(paper.SingletonComponent));
    paper.DisposeCollecter = DisposeCollecter;
    __reflect(DisposeCollecter.prototype, "paper.DisposeCollecter");
})(paper || (paper = {}));
// namespace egret3d {
//     export class Audio extends paper.BaseComponent {
//     }
// } 
var egret3d;
(function (egret3d) {
    /**
     * WebGL窗口信息
     */
    var Stage3D = (function () {
        function Stage3D() {
            this.screenViewport = { x: 0, y: 0, w: 0, h: 0 };
            this.absolutePosition = { x: 0, y: 0, w: 0, h: 0 };
            this._resizeDirty = true;
        }
        /**
         * @internal
         */
        Stage3D.prototype.init = function (canvas, options) {
            var _this = this;
            this._canvas = canvas;
            window.addEventListener("resize", function () { return _this._resizeDirty = true; }, false);
            this.isLandscape = options.contentWidth > options.contentHeight;
            this.contentWidth = options.contentWidth;
            this.contentHeight = options.contentHeight;
        };
        Stage3D.prototype.update = function () {
            if (this._resizeDirty) {
                this._resize();
                this._resizeDirty = false;
            }
        };
        Stage3D.prototype._resize = function () {
            var displayWidth = window.innerWidth;
            var displayHeight = window.innerHeight;
            var absolutePosition = this.absolutePosition;
            absolutePosition.w = displayWidth;
            absolutePosition.h = displayHeight;
            // 计算视口区域
            var screenViewport = this.screenViewport;
            var shouldRotate = (this.isLandscape && window.innerHeight > window.innerWidth)
                || (!this.isLandscape && window.innerWidth > window.innerHeight);
            if (shouldRotate) {
                screenViewport.w = this.contentWidth;
                var screenH = Math.ceil(screenViewport.w / displayHeight * displayWidth);
                screenViewport.h = screenH;
            }
            else {
                screenViewport.w = this.contentWidth;
                var screenH = Math.ceil(screenViewport.w / displayWidth * displayHeight);
                screenViewport.h = screenH;
            }
            var canvas = this._canvas;
            canvas.width = screenViewport.w;
            canvas.height = screenViewport.h;
            // 设置canvas.style
            var x = absolutePosition.x, y = absolutePosition.y, w = absolutePosition.w, h = absolutePosition.h;
            canvas.style.top = y + "px";
            canvas.style.position = "absolute";
            canvas.style[egret.web.getPrefixStyleName("transformOrigin")] = "0% 0% 0px";
            if (shouldRotate) {
                // canvas.style.width = h + "px";
                // canvas.style.height = w + "px";
                canvas.style.left = window.innerWidth + "px";
                var transform = "matrix(0," + h / canvas.width + "," + -w / canvas.height + ",0,0,0)";
                canvas.style[egret.web.getPrefixStyleName("transform")] = transform;
            }
            else {
                // canvas.style.width = w + "px";
                // canvas.style.height = h + "px";
                // canvas.style[egret.web.getPrefixStyleName("transform")] = null;
                canvas.style.left = x + "px";
                var transform = "matrix(" + w / canvas.width + ",0,0," + h / canvas.height + ",0,0)";
                canvas.style[egret.web.getPrefixStyleName("transform")] = transform;
            }
            // 更新触摸信息
            var touchScaleX;
            var touchScaleY;
            if (shouldRotate) {
                touchScaleX = egret3d.stage.screenViewport.w / h;
                touchScaleY = egret3d.stage.screenViewport.h / w;
            }
            else {
                touchScaleX = egret3d.stage.screenViewport.w / w;
                touchScaleY = egret3d.stage.screenViewport.h / h;
            }
            egret3d.InputManager.touch.updateOffsetAndScale(x, y, touchScaleX, touchScaleY, shouldRotate);
            egret3d.InputManager.mouse.updateOffsetAndScale(x, y, touchScaleX, touchScaleY, shouldRotate);
            //
            var webInput = paper.Application.systemManager.getSystem(egret3d.Egret2DRendererSystem).webInput;
            if (webInput) {
                webInput.$updateSize();
            }
        };
        return Stage3D;
    }());
    egret3d.Stage3D = Stage3D;
    __reflect(Stage3D.prototype, "egret3d.Stage3D");
    egret3d.stage = new Stage3D();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _pattern = /#include +<([\w\d.]+)>/g;
    var _browserPrefixes = [
        "",
        "MOZ_",
        "OP_",
        "WEBKIT_",
    ];
    function _getExtension(gl, name) {
        for (var _i = 0, _browserPrefixes_1 = _browserPrefixes; _i < _browserPrefixes_1.length; _i++) {
            var prefixedName = _browserPrefixes_1[_i];
            var extension = gl.getExtension(prefixedName + name);
            if (extension) {
                return extension;
            }
        }
        return null;
    }
    function _getMaxShaderPrecision(gl, precision) {
        if (precision === void 0) { precision = "highp"; }
        if (precision === "highp") {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                return "highp";
            }
            precision = "mediump";
        }
        if (precision === "mediump") {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                return "mediump";
            }
        }
        return "lowp";
    }
    function _getConstDefines(maxPrecision) {
        var defines = "precision " + maxPrecision + " float; \n";
        defines += "precision " + maxPrecision + " int; \n";
        // defines += "#extension GL_OES_standard_derivatives : enable \n";
        return defines;
    }
    function _replace(_match, include) {
        if (!(include in egret3d.ShaderChunk)) {
            throw new Error("Can not resolve #include <" + include + ">");
        }
        return _parseIncludes(egret3d.ShaderChunk[include]);
    }
    function _parseIncludes(string) {
        return string.replace(_pattern, _replace);
    }
    function _getWebGLShader(type, webgl, gltfShader, defines) {
        var shader = webgl.createShader(type);
        webgl.shaderSource(shader, defines + _parseIncludes(gltfShader.uri));
        webgl.compileShader(shader);
        var parameter = webgl.getShaderParameter(shader, webgl.COMPILE_STATUS);
        if (!parameter) {
            if (confirm("Shader compile:" + gltfShader.name + " error! ->" + webgl.getShaderInfoLog(shader) + "\n" + ". did you want see the code?")) {
                alert(gltfShader.uri);
            }
            webgl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    function _extractAttributes(webgl, program) {
        var webglProgram = program.program;
        var attributes = program.attributes;
        var totalAttributes = webgl.getProgramParameter(webglProgram, webgl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < totalAttributes; i++) {
            var attribData = webgl.getActiveAttrib(webglProgram, i);
            var location_1 = webgl.getAttribLocation(webglProgram, attribData.name);
            attributes.push({ name: attribData.name, type: attribData.type, size: attribData.size, location: location_1 });
        }
    }
    function _extractUniforms(webgl, program, technique) {
        var webglProgram = program.program;
        var contextUniforms = program.contextUniforms;
        var uniforms = program.uniforms;
        var totalUniforms = webgl.getProgramParameter(webglProgram, webgl.ACTIVE_UNIFORMS);
        for (var i = 0; i < totalUniforms; i++) {
            var uniformData = webgl.getActiveUniform(webglProgram, i);
            var techniqueUniform = technique.uniforms[uniformData.name];
            var location_2 = webgl.getUniformLocation(webglProgram, uniformData.name);
            if (!techniqueUniform) {
                console.error("缺少Uniform定义：" + uniformData.name);
            }
            if (techniqueUniform.semantic) {
                contextUniforms.push({ name: uniformData.name, type: uniformData.type, size: uniformData.size, location: location_2 });
            }
            else {
                uniforms.push({ name: uniformData.name, type: uniformData.type, size: uniformData.size, location: location_2 });
            }
        }
    }
    function _extractTextureUnits(program) {
        var activeUniforms = program.contextUniforms.concat(program.uniforms);
        var samplerArrayKeys = [];
        var samplerKeys = [];
        //排序
        for (var _i = 0, activeUniforms_1 = activeUniforms; _i < activeUniforms_1.length; _i++) {
            var uniform = activeUniforms_1[_i];
            var key = uniform.name;
            if (uniform.type === 35678 /* SAMPLER_2D */ || uniform.type === 35680 /* SAMPLER_CUBE */) {
                if (key.indexOf("[") > -1) {
                    samplerArrayKeys.push(key);
                }
                else {
                    samplerKeys.push(key);
                }
            }
        }
        var textureUint = 0;
        var allKeys = samplerKeys.concat(samplerArrayKeys);
        for (var _a = 0, activeUniforms_2 = activeUniforms; _a < activeUniforms_2.length; _a++) {
            var uniform = activeUniforms_2[_a];
            if (allKeys.indexOf(uniform.name) < 0) {
                continue;
            }
            if (!uniform.textureUnits) {
                uniform.textureUnits = [];
            }
            uniform.textureUnits.length = uniform.size;
            for (var i = 0; i < uniform.size; i++) {
                uniform.textureUnits[i] = textureUint++;
            }
        }
    }
    /**
     * @private
     */
    var WebGLCapabilities = (function (_super) {
        __extends(WebGLCapabilities, _super);
        function WebGLCapabilities() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.precision = "highp";
            return _this;
        }
        WebGLCapabilities.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            var webgl = WebGLCapabilities.webgl;
            if (!webgl) {
                return;
            }
            this.version = parseFloat(/^WebGL\ ([0-9])/.exec(webgl.getParameter(webgl.VERSION))[1]);
            this.maxPrecision = _getMaxShaderPrecision(webgl, this.precision);
            this.maxTextures = webgl.getParameter(webgl.MAX_TEXTURE_IMAGE_UNITS);
            this.maxVertexTextures = webgl.getParameter(webgl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            this.maxTextureSize = webgl.getParameter(webgl.MAX_TEXTURE_SIZE);
            this.maxCubemapSize = webgl.getParameter(webgl.MAX_CUBE_MAP_TEXTURE_SIZE);
            this.maxVertexUniformVectors = webgl.getParameter(webgl.MAX_VERTEX_UNIFORM_VECTORS);
            this.floatTextures = !!_getExtension(webgl, "OES_texture_float");
            this.anisotropyExt = _getExtension(webgl, "EXT_texture_filter_anisotropic");
            this.shaderTextureLOD = _getExtension(webgl, "EXT_shader_texture_lod");
            this.maxAnisotropy = (this.anisotropyExt !== null) ? webgl.getParameter(this.anisotropyExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            // use dfdx and dfdy must enable OES_standard_derivatives
            _getExtension(webgl, "OES_standard_derivatives");
            // GL_OES_standard_derivatives
            _getExtension(webgl, "GL_OES_standard_derivatives");
            //TODO
            WebGLCapabilities.commonDefines = _getConstDefines(this.maxPrecision);
            egret3d.SkinnedMeshRendererSystem.maxBoneCount = Math.floor((this.maxVertexUniformVectors - 20) / 4);
            console.info("WebGL version:", this.version);
            console.info("Maximum shader precision:", this.maxPrecision);
            console.info("Maximum texture count:", this.maxTextures);
            console.info("Maximum vertex texture count:", this.maxVertexTextures);
            console.info("Maximum texture size:", this.maxTextureSize);
            console.info("Maximum cube map texture size:", this.maxCubemapSize);
            console.info("Maximum vertex uniform vectors:", this.maxVertexUniformVectors);
            console.info("Maximum GPU skinned bone count:", egret3d.SkinnedMeshRendererSystem.maxBoneCount);
        };
        WebGLCapabilities.canvas = null;
        WebGLCapabilities.webgl = null;
        WebGLCapabilities.commonDefines = "";
        return WebGLCapabilities;
    }(paper.SingletonComponent));
    egret3d.WebGLCapabilities = WebGLCapabilities;
    __reflect(WebGLCapabilities.prototype, "egret3d.WebGLCapabilities");
    /**
     * @private
     */
    var WebGLRenderState = (function (_super) {
        __extends(WebGLRenderState, _super);
        function WebGLRenderState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._stateEnables = [3042 /* BLEND */, 2884 /* CULL_FACE */, 2929 /* DEPTH_TEST */]; // TODO
            _this._programs = {};
            _this._vsShaders = {};
            _this._fsShaders = {};
            _this._cacheStateEnable = {};
            _this._cacheProgram = null;
            _this._cacheState = null;
            return _this;
        }
        WebGLRenderState.prototype._getWebGLProgram = function (vs, fs, customDefines) {
            var webgl = WebGLCapabilities.webgl;
            var program = webgl.createProgram();
            var key = vs.name + customDefines;
            var vertexShader = this._vsShaders[key];
            if (!vertexShader) {
                vertexShader = _getWebGLShader(webgl.VERTEX_SHADER, webgl, vs, WebGLCapabilities.commonDefines + customDefines + egret3d.ShaderChunk.common_vert_def);
                this._vsShaders[key] = vertexShader;
            }
            key = fs.name + customDefines;
            var fragmentShader = this._fsShaders[key];
            if (!fragmentShader) {
                fragmentShader = _getWebGLShader(webgl.FRAGMENT_SHADER, webgl, fs, WebGLCapabilities.commonDefines + customDefines + egret3d.ShaderChunk.common_frag_def);
                this._fsShaders[key] = fragmentShader;
            }
            webgl.attachShader(program, vertexShader);
            webgl.attachShader(program, fragmentShader);
            webgl.linkProgram(program);
            var parameter = webgl.getProgramParameter(program, webgl.LINK_STATUS);
            if (!parameter) {
                alert("program compile: " + vs.name + "_" + fs.name + " error! ->" + webgl.getProgramInfoLog(program));
                webgl.deleteProgram(program);
                return null;
            }
            return program;
        };
        WebGLRenderState.prototype.clearState = function () {
            for (var key in this._cacheStateEnable) {
                delete this._cacheStateEnable[key];
            }
            this._cacheProgram = null;
            this._cacheState = null;
        };
        WebGLRenderState.prototype.updateState = function (state) {
            if (this._cacheState === state) {
                return;
            }
            this._cacheState = state;
            var webgl = WebGLCapabilities.webgl;
            var stateEnables = this._stateEnables;
            var cacheStateEnable = this._cacheStateEnable;
            //TODO WebGLKit.draw(context, drawCall.material, drawCall.mesh, drawCall.subMeshIndex, drawType, transform._worldMatrixDeterminant < 0);
            for (var _i = 0, stateEnables_1 = stateEnables; _i < stateEnables_1.length; _i++) {
                var e = stateEnables_1[_i];
                var b = state ? state.enable && state.enable.indexOf(e) >= 0 : false;
                if (cacheStateEnable[e] !== b) {
                    cacheStateEnable[e] = b;
                    b ? webgl.enable(e) : webgl.disable(e);
                }
            }
            // Functions.
            if (state) {
                var functions = state.functions;
                if (functions) {
                    for (var fun in functions) {
                        webgl[fun].apply(webgl, functions[fun]);
                    }
                }
            }
        };
        WebGLRenderState.prototype.useProgram = function (program) {
            if (this._cacheProgram !== program) {
                this._cacheProgram = program;
                WebGLCapabilities.webgl.useProgram(program.program);
                return true;
            }
            return false;
        };
        WebGLRenderState.prototype.getProgram = function (material, technique, defines) {
            var shader = material._shader;
            var extensions = shader.config.extensions.KHR_techniques_webgl;
            var vertexShader = extensions.shaders[0];
            var fragShader = extensions.shaders[1];
            var name = vertexShader.name + "_" + fragShader.name + "_" + defines; //TODO材质标脏可以优化
            var webgl = WebGLCapabilities.webgl;
            var program = this._programs[name];
            if (!program) {
                var webglProgram = this._getWebGLProgram(vertexShader, fragShader, defines);
                if (webglProgram) {
                    program = new egret3d.GlProgram(webglProgram);
                    this._programs[name] = program;
                    _extractAttributes(webgl, program);
                    _extractUniforms(webgl, program, technique);
                    _extractTextureUnits(program);
                }
            }
            if (technique.program !== program.id) {
                technique.program = program.id;
            }
            return program;
        };
        WebGLRenderState.prototype.targetAndViewport = function (viewport, target) {
            var webgl = WebGLCapabilities.webgl;
            var w;
            var h;
            if (!target) {
                w = egret3d.stage.screenViewport.w;
                h = egret3d.stage.screenViewport.h;
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
            }
            else {
                w = target.width;
                h = target.height;
                target.use();
            }
            webgl.viewport(w * viewport.x, h * viewport.y, w * viewport.w, h * viewport.h);
            webgl.depthRange(0, 1);
        };
        WebGLRenderState.prototype.clear = function (clearOptColor, clearOptDepath, clearColor) {
            var webgl = WebGLCapabilities.webgl;
            if (clearOptColor && clearOptDepath) {
                webgl.depthMask(true);
                webgl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
                webgl.clearDepth(1.0);
                webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
            }
            else if (clearOptDepath) {
                webgl.depthMask(true);
                webgl.clearDepth(1.0);
                webgl.clear(webgl.DEPTH_BUFFER_BIT);
            }
            else if (clearOptColor) {
                webgl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
                webgl.clear(webgl.COLOR_BUFFER_BIT);
            }
        };
        return WebGLRenderState;
    }(paper.SingletonComponent));
    egret3d.WebGLRenderState = WebGLRenderState;
    __reflect(WebGLRenderState.prototype, "egret3d.WebGLRenderState");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 贝塞尔曲线，目前定义了三种：线性贝塞尔曲线(两个点形成),二次方贝塞尔曲线（三个点形成），三次方贝塞尔曲线（四个点形成）
     */
    var Curve3 = (function () {
        /**
         * @internal
         */
        function Curve3(beizerPoints, bezierPointNum) {
            this.beizerPoints = beizerPoints;
            this.bezierPointNum = bezierPointNum;
        }
        /**
         * 线性贝塞尔曲线
         */
        Curve3.createLinearBezier = function (start, end, indices) {
            indices = indices > 2 ? indices : 3;
            var bez = new Array();
            var equation = function (t, va10, va11) {
                var res = (1.0 - t) * va10 + t * va11;
                return res;
            };
            bez.push(start);
            for (var i = 1; i <= indices; i++) {
                bez.push(new egret3d.Vector3(equation(i / indices, start.x, end.x), equation(i / indices, start.y, start.y), equation(i / indices, start.z, start.z)));
            }
            return new Curve3(bez, indices);
        };
        /**
         * 二次方贝塞尔曲线路径
         * @param v0 起始点
         * @param v1 选中的节点
         * @param v2 结尾点
         * @param bezierPointNum 将贝塞尔曲线拆分bezierPointNum段，一共有bezierPointNum + 1个点
         * @returns 贝塞尔曲线对象
         */
        Curve3.createQuadraticBezier = function (v0, v1, v2, bezierPointNum) {
            bezierPointNum = bezierPointNum > 2 ? bezierPointNum : 3;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2) {
                var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        /**
         * 三次方贝塞尔曲线路径
         * @param v0 起始点
         * @param v1 第一个插值点
         * @param v2 第二个插值点
         * @param v3 终点
         * @param bezierPointNum 将贝塞尔曲线拆分bezierPointNum段，一共有bezierPointNum + 1个点
         * @returns 贝塞尔曲线对象
         */
        Curve3.createCubicBezier = function (v0, v1, v2, v3, bezierPointNum) {
            bezierPointNum = bezierPointNum > 3 ? bezierPointNum : 4;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2, val3) {
                var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x, v3.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y, v3.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z, v3.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        return Curve3;
    }());
    egret3d.Curve3 = Curve3;
    __reflect(Curve3.prototype, "egret3d.Curve3");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _points = [
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
    ];
    /**
     * 轴对称包围盒。
     */
    var AABB = (function (_super) {
        __extends(AABB, _super);
        /**
         * 请使用 `egret3d.AABB.create()` 创建实例。
         * @see egret3d.AABB.create()
         */
        function AABB() {
            var _this = _super.call(this) || this;
            _this._dirtyRadius = true;
            _this._dirtyCenter = true;
            _this._dirtySize = true;
            _this._boundingSphereRadius = 0.0;
            _this._minimum = egret3d.Vector3.create(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            _this._maximum = egret3d.Vector3.create(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            _this._center = egret3d.Vector3.create();
            _this._size = egret3d.Vector3.create();
            return _this;
        }
        /**
         *
         * @param minimum
         * @param maximum
         */
        AABB.create = function (minimum, maximum) {
            if (minimum === void 0) { minimum = null; }
            if (maximum === void 0) { maximum = null; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(minimum, maximum);
                instance._released = false;
                return instance;
            }
            return new AABB().set(minimum, maximum);
        };
        AABB.prototype.serialize = function () {
            return [this._minimum.x, this._minimum.y, this._minimum.z, this._maximum.x, this._maximum.y, this._maximum.z];
        };
        AABB.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        AABB.prototype.clone = function () {
            return AABB.create(this.minimum, this.maximum);
        };
        AABB.prototype.copy = function (value) {
            return this.set(value.minimum, value.maximum);
        };
        AABB.prototype.clear = function () {
            this._minimum.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            this._maximum.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            this._dirtySize = true;
            return this;
        };
        /**
         *
         */
        AABB.prototype.set = function (minimum, maximum) {
            if (minimum === void 0) { minimum = null; }
            if (maximum === void 0) { maximum = null; }
            if (minimum && minimum !== this._minimum) {
                this._minimum.copy(minimum);
            }
            if (maximum && maximum !== this._maximum) {
                this._maximum.copy(maximum);
            }
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            this._dirtySize = true;
            return this;
        };
        AABB.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this._minimum.fromArray(value, offset);
            this._maximum.fromArray(value, offset + 3);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            this._dirtySize = true;
            return this;
        };
        /**
         *
         */
        AABB.prototype.fromPoints = function (value) {
            this.clear();
            for (var _i = 0, _a = value; _i < _a.length; _i++) {
                var point = _a[_i];
                this.add(point);
            }
            return this;
        };
        AABB.prototype.applyMatrix = function (value, source) {
            if (!source) {
                source = this;
            }
            // transform of empty box is an empty box.
            if (source.isEmpty) {
                if (source !== this) {
                    this.copy(source);
                }
                return this;
            }
            var min = source.minimum;
            var max = source.maximum;
            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            _points[0].set(min.x, min.y, min.z).applyMatrix(value); // 000
            _points[1].set(min.x, min.y, max.z).applyMatrix(value); // 001
            _points[2].set(min.x, max.y, min.z).applyMatrix(value); // 010
            _points[3].set(min.x, max.y, max.z).applyMatrix(value); // 011
            _points[4].set(max.x, min.y, min.z).applyMatrix(value); // 100
            _points[5].set(max.x, min.y, max.z).applyMatrix(value); // 101
            _points[6].set(max.x, max.y, min.z).applyMatrix(value); // 110
            _points[7].set(max.x, max.y, max.z).applyMatrix(value); // 111
            this.fromPoints(_points);
            return this;
        };
        /**
         *
         */
        AABB.prototype.add = function (value, source) {
            if (!source) {
                source = this;
            }
            var min = source.minimum;
            var max = source.maximum;
            if (value instanceof AABB) {
                this._minimum.min(value._minimum, min);
                this._maximum.max(value._maximum, max);
            }
            else {
                this._minimum.min(value, min);
                this._maximum.max(value, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            this._dirtySize = true;
            return this;
        };
        /**
         *
         */
        AABB.prototype.expand = function (value, source) {
            if (!source) {
                source = this;
            }
            var min = source.minimum;
            var max = source.maximum;
            if (typeof value === "number") {
                this._minimum.addScalar(-value, min);
                this._maximum.addScalar(value, max);
            }
            else {
                this._minimum.subtract(value, min);
                this._maximum.add(value, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            this._dirtySize = true;
            return this;
        };
        /**
         *
         */
        AABB.prototype.offset = function (value, source) {
            if (!source) {
                source = this;
            }
            var min = source.minimum;
            var max = source.maximum;
            if (typeof value === "number") {
                this._minimum.addScalar(value, min);
                this._maximum.addScalar(value, max);
            }
            else {
                this._minimum.add(value, min);
                this._maximum.add(value, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            this._dirtySize = true;
            return this;
        };
        /**
         * check contains vector
         * @param value a world point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 检查是否包含点
         * @param value 世界坐标
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.contains = function (value) {
            var min = this._minimum;
            var max = this._maximum;
            if (value instanceof AABB) {
                var vMin = value.minimum;
                var vMax = value.maximum;
                return min.x <= vMin.x && vMax.x <= max.x &&
                    min.y <= vMin.y && vMax.y <= max.y &&
                    min.z <= vMin.z && vMax.z <= max.z;
            }
            return (value.x > min.x) && (value.x < max.x) &&
                (value.y > min.y) && (value.x < max.y) &&
                (value.z > min.z) && (value.z < max.z);
        };
        AABB.prototype.getDistance = function (value) {
            return egret3d.helpVector3A.clamp(this._minimum, this._maximum, value).subtract(value).length;
        };
        AABB.prototype.clampPoints = function (value, out) {
            return out.clamp(this._minimum, this._maximum, value);
        };
        AABB.prototype.raycast = function (ray, raycastInfo) {
            var tmin, tmax, tymin, tymax, tzmin, tzmax;
            var invdirx = 1.0 / ray.direction.x, invdiry = 1.0 / ray.direction.y, invdirz = 1.0 / ray.direction.z;
            var origin = ray.origin;
            if (invdirx >= 0.0) {
                tmin = (this.minimum.x - origin.x) * invdirx;
                tmax = (this.maximum.x - origin.x) * invdirx;
            }
            else {
                tmin = (this.maximum.x - origin.x) * invdirx;
                tmax = (this.minimum.x - origin.x) * invdirx;
            }
            if (invdiry >= 0.0) {
                tymin = (this.minimum.y - origin.y) * invdiry;
                tymax = (this.maximum.y - origin.y) * invdiry;
            }
            else {
                tymin = (this.maximum.y - origin.y) * invdiry;
                tymax = (this.minimum.y - origin.y) * invdiry;
            }
            if ((tmin > tymax) || (tymin > tmax))
                return false;
            // These lines also handle the case where tmin or tmax is NaN
            // (result of 0 * Infinity). x !== x returns true if x is NaN
            if (tymin > tmin || tmin !== tmin)
                tmin = tymin;
            if (tymax < tmax || tmax !== tmax)
                tmax = tymax;
            if (invdirz >= 0.0) {
                tzmin = (this.minimum.z - origin.z) * invdirz;
                tzmax = (this.maximum.z - origin.z) * invdirz;
            }
            else {
                tzmin = (this.maximum.z - origin.z) * invdirz;
                tzmax = (this.minimum.z - origin.z) * invdirz;
            }
            if ((tmin > tzmax) || (tzmin > tmax))
                return false;
            if (tzmin > tmin || tmin !== tmin)
                tmin = tzmin;
            if (tzmax < tmax || tmax !== tmax)
                tmax = tzmax;
            // return point closest to the ray (positive side)
            if (tmax < 0.0)
                return false;
            if (raycastInfo) {
                ray.at(raycastInfo.distance = tmin >= 0.0 ? tmin : tmax, raycastInfo.position);
            }
            return true;
        };
        Object.defineProperty(AABB.prototype, "isEmpty", {
            get: function () {
                // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
                return (this._maximum.x < this._minimum.x) || (this._maximum.y < this._minimum.y) || (this._maximum.z < this._minimum.z);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "boundingSphereRadius", {
            /**
             * Bounding sphere radius.
             */
            get: function () {
                if (this._dirtyRadius) {
                    egret3d.helpVector3A.subtract(this._maximum, this._minimum).multiplyScalar(0.5);
                    this._boundingSphereRadius = egret3d.helpVector3A.length;
                    this._dirtyRadius = false;
                }
                return this._boundingSphereRadius;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "minimum", {
            /**
             *
             */
            get: function () {
                return this._minimum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "maximum", {
            /**
             *
             */
            get: function () {
                return this._maximum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "center", {
            /**
             * get center
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 获取中心点位置
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                if (this._dirtyCenter) {
                    this._center.add(this._maximum, this._minimum).multiplyScalar(0.5);
                    this._dirtyCenter = false;
                }
                return this._center;
            },
            set: function (value) {
                var size = this.size;
                var center = this._center.copy(value);
                var halfSize = egret3d.helpVector3A.copy(size).multiplyScalar(0.5);
                this._minimum.copy(center).subtract(halfSize);
                this._maximum.copy(center).add(halfSize);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "size", {
            get: function () {
                if (this._dirtySize) {
                    this._size.subtract(this._maximum, this._minimum);
                    this._dirtySize = false;
                }
                return this._size;
            },
            set: function (value) {
                var center = this.center;
                var size = this._size.copy(value);
                var halfSize = egret3d.helpVector3A.copy(size).multiplyScalar(0.5);
                this._minimum.copy(center).subtract(halfSize);
                this._maximum.copy(center).add(halfSize);
                this._dirtyRadius = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        AABB.ONE = new AABB().set(egret3d.Vector3.MINUS_ONE.clone().multiplyScalar(0.5).release(), egret3d.Vector3.ONE.clone().multiplyScalar(0.5).release());
        AABB._instances = [];
        return AABB;
    }(paper.BaseRelease));
    egret3d.AABB = AABB;
    __reflect(AABB.prototype, "egret3d.AABB", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
    /**
     * @internal
     */
    egret3d.helpAABBA = AABB.create();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Spherical = (function (_super) {
        __extends(Spherical, _super);
        /**
         * 请使用 `egret3d.Spherical.create()` 创建实例。
         * @see egret3d.Spherical.create()
         */
        function Spherical() {
            var _this = _super.call(this) || this;
            /**
             *
             */
            _this.radius = 1.0;
            /**
             *
             */
            _this.phi = 0.0;
            /**
             *
             */
            _this.theta = 0.0;
            return _this;
        }
        /**
         *
         */
        Spherical.create = function (radius, phi, theta) {
            if (radius === void 0) { radius = 1.0; }
            if (phi === void 0) { phi = 0.0; }
            if (theta === void 0) { theta = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(radius, phi, theta);
                instance._released = false;
                return instance;
            }
            return new Spherical().set(radius, phi, theta);
        };
        Spherical.prototype.serialize = function () {
            return [this.radius, this.phi, this.theta];
        };
        Spherical.prototype.deserialize = function (value) {
            this.radius = value[0];
            this.phi = value[1];
            this.theta = value[2];
            return this;
        };
        Spherical.prototype.clone = function () {
            return Spherical.create(this.radius, this.phi, this.theta);
        };
        Spherical.prototype.copy = function (value) {
            return this.set(value.radius, value.phi, value.theta);
        };
        Spherical.prototype.set = function (radius, phi, theta) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
            return this;
        };
        Spherical.prototype.fromCartesianCoords = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                p3 = p1.z;
                p2 = p1.y;
                p1 = p1.z;
            }
            this.radius = Math.sqrt(p1 * p1 + p2 * p2 + p3 * p3);
            if (this.radius === 0.0) {
                this.theta = 0.0;
                this.phi = 0.0;
            }
            else {
                this.theta = Math.atan2(p1, p3); // TODO
                this.phi = Math.acos(egret3d.floatClamp(p2 / this.radius, -1.0, 1.0));
            }
            return this;
        };
        Spherical.prototype.makeSafe = function () {
            var EPS = 0.000001;
            this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
            return this;
        };
        Spherical._instances = [];
        return Spherical;
    }(paper.BaseRelease));
    egret3d.Spherical = Spherical;
    __reflect(Spherical.prototype, "egret3d.Spherical", ["paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Sphere = (function (_super) {
        __extends(Sphere, _super);
        /**
         * 请使用 `egret3d.Sphere.create()` 创建实例。
         * @see egret3d.Sphere.create()
         */
        function Sphere() {
            var _this = _super.call(this) || this;
            /**
             * 球半径。
             */
            _this.radius = 0.0;
            /**
             * 中心坐标。
             */
            _this.center = egret3d.Vector3.create();
            return _this;
        }
        /**
         *
         * @param center
         * @param radius
         */
        Sphere.create = function (center, radius) {
            if (center === void 0) { center = egret3d.Vector3.ZERO; }
            if (radius === void 0) { radius = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(center, radius);
                instance._released = false;
                return instance;
            }
            return new Sphere().set(center, radius);
        };
        Sphere.prototype.serialize = function () {
            return [this.center.x, this.center.y, this.center.z, this.radius];
        };
        Sphere.prototype.deserialize = function (value) {
            this.radius = value[3];
            this.center.fromArray(value);
            return this;
        };
        Sphere.prototype.clone = function () {
            return Sphere.create(this.center, this.radius);
        };
        Sphere.prototype.copy = function (value) {
            return this.set(value.center, value.radius);
        };
        Sphere.prototype.set = function (center, radius) {
            this.radius = radius;
            this.center.copy(center);
            return this;
        };
        Sphere.prototype.fromPoints = function (points, center) {
            if (center) {
                this.center.copy(center);
            }
            else {
                this.center.copy(egret3d.helpAABBA.fromPoints(points).center);
            }
            var maxRadiusSqrt = 0.0;
            for (var i = 0, l = points.length; i < l; i++) {
                maxRadiusSqrt = Math.max(maxRadiusSqrt, this.center.getDistance(points[i]));
            }
            this.radius = Math.sqrt(maxRadiusSqrt);
            return this;
        };
        Sphere.prototype.applyMatrix = function (matrix) {
            this.center.applyMatrix(matrix);
            this.radius = this.radius * matrix.getMaxScaleOnAxis();
            return this;
        };
        Sphere.prototype.contains = function (value) {
            if (value instanceof Sphere) {
                var radiusDelta = this.radius - value.radius;
                if (radiusDelta >= 0.0) {
                    this.center.getSquaredDistance(value.center) <= (radiusDelta * radiusDelta);
                }
                return false;
            }
            return this.center.getSquaredDistance(value) <= this.radius * this.radius;
        };
        Sphere.prototype.getDistance = function (value) {
            return this.center.getDistance(value) - this.radius;
        };
        Sphere.prototype.clampPoint = function (point, out) {
            var squaredDistance = this.center.getSquaredDistance(point);
            if (squaredDistance > (this.radius * this.radius)) {
                out.subtract(this.center, point).normalize();
                out.multiplyScalar(this.radius).add(this.center);
            }
            else {
                out.copy(point);
            }
            return out;
        };
        Sphere.prototype.raycast = function (ray, raycastInfo) {
            var v1 = egret3d.helpVector3A.subtract(this.center, ray.origin);
            var tca = v1.dot(ray.direction);
            var d2 = v1.dot(v1) - tca * tca;
            var radius2 = this.radius * this.radius;
            if (d2 > radius2)
                return false;
            var thc = Math.sqrt(radius2 - d2);
            // t0 = first intersect point - entrance on front of sphere
            var t0 = tca - thc;
            // t1 = second intersect point - exit point on back of sphere
            var t1 = tca + thc;
            // test to see if both t0 and t1 are behind the ray - if so, return null
            if (t0 < 0.0 && t1 < 0.0)
                return false;
            // test to see if t0 is behind the ray:
            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
            // in order to always return an intersect point that is in front of the ray.
            // else t0 is in front of the ray, so return the first collision point scaled by t0
            if (raycastInfo) {
                ray.at(raycastInfo.distance = t0 < 0.0 ? t1 : t0, raycastInfo.position);
            }
            return true;
            // let center_ori = helpVec3_1;
            // Vector3.subtract(center, this.origin, center_ori);
            // let raydist = Vector3.dot(this.direction, center_ori);
            // if (raydist < 0) return false; // 到圆心的向量在方向向量上的投影为负，夹角不在-90与90之间
            // let orilen2 = Vector3.getSqrLength(center_ori);
            // let rad2 = radius * radius;
            // if (orilen2 < rad2) return true; // 射线起点在球里
            // let d = rad2 - (orilen2 - raydist * raydist);
            // if (d < 0) return false;
            // return true;
        };
        Sphere._instances = [];
        return Sphere;
    }(paper.BaseRelease));
    egret3d.Sphere = Sphere;
    __reflect(Sphere.prototype, "egret3d.Sphere", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * Shader 通用宏定义。
     */
    var ShaderDefine;
    (function (ShaderDefine) {
        ShaderDefine["USE_COLOR"] = "USE_COLOR";
        ShaderDefine["USE_MAP"] = "USE_MAP";
        ShaderDefine["USE_SKINNING"] = "USE_SKINNING";
        ShaderDefine["USE_LIGHTMAP"] = "USE_LIGHTMAP";
        ShaderDefine["USE_SHADOWMAP"] = "USE_SHADOWMAP";
        ShaderDefine["USE_SIZEATTENUATION"] = "USE_SIZEATTENUATION";
        //
        ShaderDefine["MAX_BONES"] = "MAX_BONES";
        //
        ShaderDefine["FLIP_V"] = "FLIP_V";
        //
        ShaderDefine["NUM_POINT_LIGHTS"] = "NUM_POINT_LIGHTS";
        ShaderDefine["NUM_SPOT_LIGHTS"] = "NUM_SPOT_LIGHTS";
        ShaderDefine["SHADOWMAP_TYPE_PCF"] = "SHADOWMAP_TYPE_PCF";
        ShaderDefine["SHADOWMAP_TYPE_PCF_SOFT"] = "SHADOWMAP_TYPE_PCF_SOFT";
        ShaderDefine["DEPTH_PACKING_3200"] = "DEPTH_PACKING 3200";
        ShaderDefine["DEPTH_PACKING_3201"] = "DEPTH_PACKING 3201";
        //
        ShaderDefine["USE_FOG"] = "USE_FOG";
        ShaderDefine["FOG_EXP2"] = "FOG_EXP2";
    })(ShaderDefine = egret3d.ShaderDefine || (egret3d.ShaderDefine = {}));
    /**
     * Shader 通用 Uniform 名称。
     */
    var ShaderUniformName;
    (function (ShaderUniformName) {
        ShaderUniformName["Diffuse"] = "diffuse";
        ShaderUniformName["Opacity"] = "opacity";
        ShaderUniformName["Size"] = "size";
        ShaderUniformName["Map"] = "map";
        ShaderUniformName["Specular"] = "specular";
        ShaderUniformName["Shininess"] = "shininess";
        ShaderUniformName["UVTransform"] = "uvTransform";
    })(ShaderUniformName = egret3d.ShaderUniformName || (egret3d.ShaderUniformName = {}));
    /**
     * Shader 资源。
     */
    var Shader = (function (_super) {
        __extends(Shader, _super);
        /**
         * @internal
         */
        function Shader(config, name) {
            var _this = _super.call(this, name) || this;
            _this.config = config;
            return _this;
        }
        return Shader;
    }(egret3d.GLTFAsset));
    egret3d.Shader = Shader;
    __reflect(Shader.prototype, "egret3d.Shader");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    //TODO 运行时DrawCall排序优化使用
    var _hashCode = 0;
    /**
     * 材质资源。
     */
    var Material = (function (_super) {
        __extends(Material, _super);
        function Material(shaderOrConfig, name) {
            var _this = _super.call(this, name) || this;
            /**
             *
             */
            _this.renderQueue = 2000 /* Geometry */;
            /**
              * @internal
              */
            _this._id = _hashCode++;
            /**
              * @internal
              */
            _this._version = 0;
            _this._cacheDefines = "";
            /**
              * @internal
              */
            _this._defines = [];
            _this._textures = []; // TODO
            /**
             * @internal
             */
            _this._shader = null;
            /**
            * @internal
            */
            _this._glTFTechnique = null;
            if (!shaderOrConfig) {
                _this._reset(egret3d.DefaultShaders.MESH_BASIC);
            }
            else if (typeof shaderOrConfig === "string") {
                var shader = paper.Asset.find(shaderOrConfig);
                if (!shader) {
                    console.error("Cannot find shader.", shaderOrConfig);
                }
                _this._reset(shader || egret3d.DefaultShaders.MESH_BASIC);
            }
            else {
                _this._reset(shaderOrConfig);
            }
            return _this;
        }
        Material.create = function (shaderOrConfig, name) {
            return new Material(shaderOrConfig, name);
        };
        Material.prototype._reset = function (shaderOrConfig) {
            var glTFMaterial;
            if (shaderOrConfig instanceof egret3d.Shader) {
                this.config = egret3d.GLTFAsset.createGLTFExtensionsConfig(); // TODO
                //
                glTFMaterial = this.config.materials[0] = {
                    extensions: {
                        KHR_techniques_webgl: { technique: shaderOrConfig.name, values: {} },
                        paper: { renderQueue: shaderOrConfig._renderQueue || this.renderQueue }
                    }
                };
                //
                this._shader = shaderOrConfig;
            }
            else {
                this.config = shaderOrConfig;
                //
                glTFMaterial = this.config.materials[0];
                //
                var shaderName = glTFMaterial.extensions.KHR_techniques_webgl.technique;
                var shader = paper.Asset.find(shaderName);
                if (!shader) {
                    console.error("Cannot find shader.", shaderName);
                }
                this._shader = shader || egret3d.DefaultShaders.MESH_BASIC;
            }
            this.renderQueue = glTFMaterial.extensions.paper.renderQueue;
            //
            this._glTFTechnique = egret3d.GLTFAsset.createTechnique(this._shader.config.extensions.KHR_techniques_webgl.techniques[0]);
            //
            var uniformValues = glTFMaterial.extensions.KHR_techniques_webgl.values;
            var uniforms = this._glTFTechnique.uniforms;
            //使用Shader替换Material中没有默认值的Uniform
            for (var k in uniformValues) {
                if (k in uniforms) {
                    var value = uniformValues[k];
                    if (Array.isArray(value)) {
                        uniforms[k].value = value.concat();
                    }
                    else {
                        uniforms[k].value = value;
                    }
                }
            }
            if (glTFMaterial.extensions.paper.states) {
                this._glTFTechnique.states = glTFMaterial.extensions.paper.states; // TODO
            }
            else if (this._shader._states) {
                this._glTFTechnique.states = egret3d.GLTFAsset.copyTechniqueStates(this._shader._states);
            }
            var materialDefines = glTFMaterial.extensions.paper.defines;
            if (materialDefines && materialDefines.length > 0) {
                for (var _i = 0, materialDefines_1 = materialDefines; _i < materialDefines_1.length; _i++) {
                    var define = materialDefines_1[_i];
                    this.addDefine(define);
                }
            }
            else if (this._shader._defines) {
                for (var _a = 0, _b = this._shader._defines; _a < _b.length; _a++) {
                    var define = _b[_a];
                    this.addDefine(define);
                }
            }
        };
        Material.prototype.dispose = function (disposeChildren) {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            if (disposeChildren) {
                for (var _i = 0, _a = this._textures; _i < _a.length; _i++) {
                    var texture = _a[_i];
                    texture.dispose();
                }
            }
            this._version++;
            this._cacheDefines = "";
            this._defines.length = 0;
            this._textures.length = 0;
            this._glTFTechnique = null;
            this._shader = null;
            return true;
        };
        Material.prototype.copy = function (value) {
            this.renderQueue = value.renderQueue;
            var sourceUniforms = value._glTFTechnique.uniforms;
            var targetUniforms = this._glTFTechnique.uniforms;
            for (var k in sourceUniforms) {
                var uniform = sourceUniforms[k];
                var value_3 = Array.isArray(uniform.value) ? uniform.value.concat() : uniform.value; // TODO TypeArray
                targetUniforms[k] = { type: uniform.type, semantic: uniform.semantic, value: value_3 };
            }
            var sourceStates = value._glTFTechnique.states;
            var targetStates = this._glTFTechnique.states;
            if (sourceStates.enable) {
                targetStates.enable = sourceStates.enable.concat();
            }
            if (sourceStates.functions) {
                if (!targetStates.functions) {
                    targetStates.functions = {};
                }
                for (var k in sourceStates.functions) {
                    if (Array.isArray(sourceStates.functions[k])) {
                        targetStates.functions[k] = sourceStates.functions[k].concat();
                    }
                    else {
                        targetStates.functions[k] = sourceStates.functions[k];
                    }
                }
            }
            //
            for (var _i = 0, _a = value._defines; _i < _a.length; _i++) {
                var define = _a[_i];
                this.addDefine(define);
            }
            return this;
        };
        /**
         * 克隆材质资源。
         */
        Material.prototype.clone = function () {
            return new Material(this._shader).copy(this);
        };
        /**
         *
         */
        Material.prototype.addDefine = function (value) {
            if (this._defines.indexOf(value) < 0) {
                this._defines.push(value);
                this._defines.sort();
                this._version++;
            }
            return this;
        };
        /**
         *
         */
        Material.prototype.removeDefine = function (value) {
            var delIndex = this._defines.indexOf(value);
            if (delIndex >= 0) {
                this._defines.splice(delIndex, 1);
                this._version++;
            }
            return this;
        };
        Material.prototype.setBoolean = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setInt = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setIntv = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setFloat = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setFloatv = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector2 = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector2v = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector3 = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y || uniform.value[2] !== value.z) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    uniform.value[2] = value.z;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector3v = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector4 = function (id, value) {
            //兼容老键值
            if (id === "_MainTex_ST" && this._glTFTechnique.uniforms["uvTransform" /* UVTransform */]) {
                id = "uvTransform" /* UVTransform */;
                console.warn("已废弃的键值_MainTex_ST，建议改为:uvTransform-Matrix3");
                this._glTFTechnique.uniforms[id].value = [value.x, 0, 0, 0, value.y, 0, value.z, value.w, 1];
                return;
            }
            else if ((id === "_MainColor" || id === "_Color") && this._glTFTechnique.uniforms["diffuse" /* Diffuse */]) {
                id = "diffuse" /* Diffuse */;
                console.warn("已废弃的键值_MainColor、_Color，建议改为:diffuse-Vector3");
                this._glTFTechnique.uniforms[id].value = [value.x, value.y, value.z];
                return;
            }
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y || uniform.value[2] !== value.z || uniform.value[3] !== value.w) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    uniform.value[2] = value.z;
                    uniform.value[3] = value.w;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector4v = function (id, value) {
            //兼容老键值
            if (id === "_MainTex_ST" && this._glTFTechnique.uniforms["uvTransform" /* UVTransform */]) {
                id = "uvTransform" /* UVTransform */;
                console.warn("已废弃的键值_MainTex_ST，建议改为:uvTransform-Matrix3");
                this._glTFTechnique.uniforms[id].value = [value[0], 0, 0, 0, value[1], 0, value[2], value[3], 1];
                return;
            }
            else if ((id === "_MainColor" || id === "_Color") && this._glTFTechnique.uniforms["diffuse" /* Diffuse */]) {
                id = "diffuse" /* Diffuse */;
                console.warn("已废弃的键值_MainColor、_Color，建议改为:diffuse-Vector3");
                this._glTFTechnique.uniforms[id].value = [value[0], value[1], value[2]];
                return;
            }
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setMatrix = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value.rawData;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setMatrixv = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        /**
         * 获取指定贴图。
         */
        Material.prototype.getTexture = function (id) {
            if (!id) {
                id = "map" /* Map */;
            }
            var uniform = this._glTFTechnique.uniforms[id];
            return uniform ? uniform.value || null : null;
        };
        Material.prototype.setTexture = function (idOrValue, value) {
            var id;
            if (idOrValue === null || idOrValue instanceof egret3d.Texture) {
                id = "map" /* Map */;
                value = idOrValue;
            }
            else {
                id = idOrValue;
            }
            if (!value) {
                value = egret3d.DefaultTextures.WHITE;
            }
            //兼容老键值
            if (id === "_MainTex" && this._glTFTechnique.uniforms["map" /* Map */]) {
                id = "map" /* Map */;
                console.warn("已废弃的键值_MainTex，建议改为:map");
            }
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value) {
                    var index = this._textures.indexOf(uniform.value);
                    if (index > -1) {
                        this._textures.splice(index, 1);
                    }
                }
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            if (value instanceof egret3d.BaseRenderTarget) {
                this.addDefine("FLIP_V" /* FLIP_V */);
            }
            if (value) {
                this._textures.push(value);
            }
            return this;
        };
        Material.prototype.setColor = function (idOrValue, value) {
            var id;
            if (idOrValue.hasOwnProperty("r")) {
                id = "diffuse" /* Diffuse */;
                value = idOrValue;
            }
            else {
                id = idOrValue;
            }
            this.setVector3(id, egret3d.Vector3.create(value.r, value.g, value.b).release());
            return this;
        };
        /**
         *
         * @param blend
         */
        Material.prototype.setBlend = function (blend) {
            if (!this._glTFTechnique.states) {
                this._glTFTechnique.states = { enable: [], functions: {} };
            }
            var enables = this._glTFTechnique.states.enable;
            var functions = this._glTFTechnique.states.functions;
            switch (blend) {
                case 3 /* Add */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [770 /* SRC_ALPHA */, 1 /* ONE */, 770 /* SRC_ALPHA */, 1 /* ONE */];
                    break;
                case 4 /* Add_PreMultiply */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [1 /* ONE */, 1 /* ONE */, 1 /* ONE */, 1 /* ONE */];
                    break;
                case 1 /* Blend */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [770 /* SRC_ALPHA */, 771 /* ONE_MINUS_SRC_ALPHA */, 1 /* ONE */, 771 /* ONE_MINUS_SRC_ALPHA */];
                    break;
                case 2 /* Blend_PreMultiply */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [1 /* ONE */, 32772 /* ONE_MINUS_CONSTANT_ALPHA */, 1 /* ONE */, 32772 /* ONE_MINUS_CONSTANT_ALPHA */];
                    break;
                default:
                    delete functions.blendEquationSeparate;
                    delete functions.blendFuncSeparate;
                    break;
            }
            var index = enables.indexOf(3042 /* BLEND */);
            if (blend === 0 /* None */) {
                if (index >= 0) {
                    enables.splice(index, 1);
                }
            }
            else {
                if (index < 0) {
                    enables.push(3042 /* BLEND */);
                }
            }
            return this;
        };
        /**
         *
         */
        Material.prototype.setCullFace = function (cull, frontFace, cullFace) {
            if (!this._glTFTechnique.states) {
                this._glTFTechnique.states = { enable: [], functions: {} };
            }
            var enables = this._glTFTechnique.states.enable;
            var functions = this._glTFTechnique.states.functions;
            var index = enables.indexOf(2884 /* CULL_FACE */);
            if (cull && frontFace && cullFace) {
                functions.frontFace = [frontFace];
                functions.cullFace = [cullFace];
                if (index < 0) {
                    enables.push(2884 /* CULL_FACE */);
                }
            }
            else {
                delete functions.frontFace;
                delete functions.cullFace;
                if (index >= 0) {
                    enables.splice(index, 1);
                }
            }
            return this;
        };
        /**
         *
         */
        Material.prototype.setDepth = function (zTest, zWrite) {
            if (!this._glTFTechnique.states) {
                this._glTFTechnique.states = { enable: [], functions: {} };
            }
            var enables = this._glTFTechnique.states.enable;
            var functions = this._glTFTechnique.states.functions;
            var index = enables.indexOf(2929 /* DEPTH_TEST */);
            if (zTest) {
                if (index < 0) {
                    enables.push(2929 /* DEPTH_TEST */);
                }
                functions.depthFunc = [515 /* LEQUAL */];
            }
            else {
                if (index >= 0) {
                    enables.splice(index, 1);
                }
            }
            if (zWrite) {
                functions.depthMask = [true];
            }
            else {
                functions.depthMask = [false];
            }
            return this;
        };
        /**
         *
         */
        Material.prototype.setRenderQueue = function (value) {
            this.renderQueue = value;
            return this;
        };
        /**
         *
         */
        Material.prototype.setOpacity = function (value) {
            return this.setFloat("opacity" /* Opacity */, value);
        };
        /**
         *
         */
        Material.prototype.setShader = function (value) {
            if (!value) {
                console.warn("Set shader error.");
                value = egret3d.DefaultShaders.MESH_BASIC;
            }
            if (this._shader === value) {
                return;
            }
            this._reset(value);
            return this;
        };
        /**
         *
         */
        Material.prototype.clearStates = function () {
            if (this._glTFTechnique.states) {
                delete this._glTFTechnique.states;
            }
            return this;
        };
        Object.defineProperty(Material.prototype, "shaderDefine", {
            /**
             * TODO
             * @internal
             */
            get: function () {
                this._cacheDefines = "";
                for (var _i = 0, _a = this._defines; _i < _a.length; _i++) {
                    var key = _a[_i];
                    this._cacheDefines += "#define " + key + " \n";
                }
                return this._cacheDefines;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "opacity", {
            /**
             *
             */
            get: function () {
                var uniform = this._glTFTechnique.uniforms["opacity" /* Opacity */];
                return (!uniform || uniform.value !== uniform.value) ? 1.0 : uniform.value;
            },
            set: function (value) {
                this.setFloat("opacity" /* Opacity */, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "shader", {
            /**
             *
             */
            get: function () {
                return this._shader;
            },
            set: function (value) {
                if (!value) {
                    console.warn("Set shader error.");
                    value = egret3d.DefaultShaders.MESH_BASIC;
                }
                if (this._shader === value) {
                    return;
                }
                this._reset(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "glTFTechnique", {
            /**
             *
             */
            get: function () {
                return this._glTFTechnique;
            },
            enumerable: true,
            configurable: true
        });
        return Material;
    }(egret3d.GLTFAsset));
    egret3d.Material = Material;
    __reflect(Material.prototype, "egret3d.Material");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderLib;
    (function (ShaderLib) {
        ShaderLib.cube = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "cube_vert", "type": 35633, "uri": "varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n\tgl_Position.z = gl_Position.w; // set z to camera.far\r\n\r\n}\r\n" }, { "name": "cube_frag", "type": 35632, "uri": "uniform samplerCube tCube;\r\nuniform float tFlip;\r\nuniform float opacity;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\r\n\tgl_FragColor.a *= opacity;\r\n\r\n}\r\n" }], "techniques": [{ "name": "cube", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "tCube": { "type": 35680 }, "tFlip": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.depth = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "depth_vert", "type": 35633, "uri": "#include <common>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_DISPLACEMENTMAP\r\n\r\n\t\t#include <beginnormal_vertex>\r\n\t\t#include <morphnormal_vertex>\r\n\t\t#include <skinnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n}\r\n" }, { "name": "depth_frag", "type": 35632, "uri": "#if DEPTH_PACKING == 3200\r\n\r\n\tuniform float opacity;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( 1.0 );\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tdiffuseColor.a = opacity;\r\n\r\n\t#endif\r\n\r\n\t#include <map_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\r\n\r\n\t#elif DEPTH_PACKING == 3201\r\n\r\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\r\n\r\n\t#endif\r\n\r\n}\r\n" }], "techniques": [{ "name": "depth", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "logDepthBufFC": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.distanceRGBA = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "distanceRGBA_vert", "type": 35633, "uri": "#define DISTANCE\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_DISPLACEMENTMAP\r\n\r\n\t\t#include <beginnormal_vertex>\r\n\t\t#include <morphnormal_vertex>\r\n\t\t#include <skinnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvWorldPosition = worldPosition.xyz;\r\n\r\n}\r\n" }, { "name": "distanceRGBA_frag", "type": 35632, "uri": "#define DISTANCE\r\n\r\nuniform vec3 referencePosition;\r\nuniform float nearDistance;\r\nuniform float farDistance;\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main () {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( 1.0 );\r\n\r\n\t#include <map_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\tfloat dist = length( vWorldPosition - referencePosition );\r\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\r\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\r\n\r\n\tgl_FragColor = packDepthToRGBA( dist );\r\n\r\n}\r\n" }], "techniques": [{ "name": "distanceRGBA", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "referencePosition": { "type": 35665, "semantic": "_REFERENCEPOSITION" }, "nearDistance": { "type": 5126, "semantic": "_NEARDICTANCE" }, "farDistance": { "type": 5126, "semantic": "_FARDISTANCE" }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.equirect = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "equirect_vert", "type": 35633, "uri": "varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n}\r\n" }, { "name": "equirect_frag", "type": 35632, "uri": "uniform sampler2D tEquirect;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvec3 direction = normalize( vWorldPosition );\r\n\r\n\tvec2 sampleUV;\r\n\r\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n\r\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\r\n\r\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\r\n\r\n}\r\n" }], "techniques": [{ "name": "equirect", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "tEquirect": { "type": 35678 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.linebasic = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "linebasic_vert", "type": 35633, "uri": "#include <common>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\nuniform float linewidth;\r\nuniform vec2 resolution;\r\nattribute vec3 instanceStart;\r\nattribute vec3 instanceEnd;\r\nattribute vec3 instanceColorStart;\r\nattribute vec3 instanceColorEnd;\r\nvarying vec2 vUv;\r\n#ifdef USE_DASH\r\n\tuniform float dashScale;\r\n\tattribute float instanceDistanceStart;\r\n\tattribute float instanceDistanceEnd;\r\n\tvarying float vLineDistance;\r\n#endif\r\nvoid trimSegment( const in vec4 start, inout vec4 end ) {\r\n\t// trim end segment so it terminates between the camera plane and the near plane\r\n\t// conservative estimate of the near plane\r\n\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\r\n\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\r\n\tfloat nearEstimate = - 0.5 * b / a;\r\n\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\r\n\tend.xyz = mix( start.xyz, end.xyz, alpha );\r\n}\r\nvoid main() {\r\n\t#ifdef USE_COLOR\r\n\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\r\n\t#endif\r\n\t#ifdef USE_DASH\r\n\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\r\n\t#endif\r\n\tfloat aspect = resolution.x / resolution.y;\r\n\tvUv = uv;\r\n\t// camera space\r\n\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\r\n\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\r\n\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\r\n\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\r\n\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\r\n\t// perhaps there is a more elegant solution -- WestLangley\r\n\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\r\n\tif ( perspective ) {\r\n\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\r\n\t\t\ttrimSegment( start, end );\r\n\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\r\n\t\t\ttrimSegment( end, start );\r\n\t\t}\r\n\t}\r\n\t// clip space\r\n\tvec4 clipStart = projectionMatrix * start;\r\n\tvec4 clipEnd = projectionMatrix * end;\r\n\t// ndc space\r\n\tvec2 ndcStart = clipStart.xy / clipStart.w;\r\n\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\r\n\t// direction\r\n\tvec2 dir = ndcEnd - ndcStart;\r\n\t// account for clip-space aspect ratio\r\n\tdir.x *= aspect;\r\n\tdir = normalize( dir );\r\n\t// perpendicular to dir\r\n\tvec2 offset = vec2( dir.y, - dir.x );\r\n\t// undo aspect ratio adjustment\r\n\tdir.x /= aspect;\r\n\toffset.x /= aspect;\r\n\t// sign flip\r\n\tif ( position.x < 0.0 ) offset *= - 1.0;\r\n\t// endcaps\r\n\tif ( position.y < 0.0 ) {\r\n\t\toffset += - dir;\r\n\t} else if ( position.y > 1.0 ) {\r\n\t\toffset += dir;\r\n\t}\r\n\t// adjust for linewidth\r\n\toffset *= linewidth;\r\n\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\r\n\toffset /= resolution.y;\r\n\t// select end\r\n\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\r\n\t// back to clip space\r\n\toffset *= clip.w;\r\n\tclip.xy += offset;\r\n\tgl_Position = clip;\r\n\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n}" }, { "name": "linebasic_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#ifdef USE_DASH\r\n\r\n\tuniform float dashSize;\r\n\tuniform float gapSize;\r\n\r\n#endif\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\t#ifdef USE_DASH\r\n\r\n\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\r\n\r\n\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\r\n\r\n\t#endif\r\n\r\n\tif ( abs( vUv.y ) > 1.0 ) {\r\n\r\n\t\tfloat a = vUv.x;\r\n\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\r\n\t\tfloat len2 = a * a + b * b;\r\n\r\n\t\tif ( len2 > 1.0 ) discard;\r\n\r\n\t}\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <color_fragment>\r\n\r\n\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}" }], "techniques": [{ "name": "linebasic", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "instanceStart": { "semantic": "_INSTANCE_START" }, "instanceEnd": { "semantic": "_INSTANCE_END" }, "instanceColorStart": { "semantic": "_INSTANCE_COLOR_START" }, "instanceColorEnd": { "semantic": "_INSTANCE_COLOR_END" }, "instanceDistanceStart": { "semantic": "_INSTANCE_DISTANCE_START" }, "instanceDistanceEnd": { "semantic": "_INSTANCE_DISTANCE_END" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "logDepthBufFC": { "type": 5126 }, "linewidth": { "type": 5126, "value": 1 }, "resolution": { "type": 35664, "semantic": "_RESOLUTION" }, "dashScale": { "type": 5126, "value": 1 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "dashSize": { "type": 5126, "value": 1 }, "gapSize": { "type": 5126, "value": 1 }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.linedashed = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "linedashed_vert", "type": 35633, "uri": "uniform float scale;\r\nattribute float lineDistance;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\r\n\tvLineDistance = scale * lineDistance;\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "linedashed_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\nuniform float dashSize;\r\nuniform float totalSize;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\r\n\r\n\t\tdiscard;\r\n\r\n\t}\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <color_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb; // simple shader\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "linedashed", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "lineDistance": { "semantic": "_INSTANCE_DISTANCE" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "scale": { "type": 5126, "value": 1 }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "dashSize": { "type": 5126, "value": 1 }, "totalSize": { "type": 5126, "value": 1 }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshbasic = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshbasic_vert", "type": 35633, "uri": "#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_ENVMAP\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "meshbasic_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\r\n\t// accumulation (baked indirect lighting only)\r\n\t#ifdef USE_LIGHTMAP\r\n\t\t   lowp vec4 lightmapTex = texture2D(lightMap, vUv2);\r\n\t\t   highp float power =pow( 2.0 ,lightmapTex.a * 255.0 - 128.0);\r\n\t\t   reflectedLight.indirectDiffuse +=lightmapTex.rgb * power * lightMapIntensity * 1.2;//EGRET\r\n\t\t// reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\r\n\r\n\t#endif\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\r\n\r\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t// #include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshbasic", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "uv2": { "semantic": "TEXCOORD_1" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "refractionRatio": { "type": 5126, "value": [] }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "lightMap": { "type": 35678, "semantic": "_LIGHTMAPTEX" }, "lightMapIntensity": { "type": 5126, "semantic": "_LIGHTMAPINTENSITY" }, "reflectivity": { "type": 5126, "value": [] }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124, "value": [] }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshlambert = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshlambert_vert", "type": 35633, "uri": "#define LAMBERT\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_pars_maps>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <lights_lambert_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "meshlambert_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float opacity;\r\n\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_pars_maps>\r\n#include <fog_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n\r\n\t#include <lightmap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\r\n\r\n\t#ifdef DOUBLE_SIDED\r\n\r\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.directDiffuse = vLightFront;\r\n\r\n\t#endif\r\n\r\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t// #include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshlambert", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "uv2": { "semantic": "TEXCOORD_1" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "refractionRatio": { "type": 5126, "value": [] }, "ambientLightColor": { "type": 35665, "semantic": "_AMBIENTLIGHTCOLOR" }, "directionalLights[0]": { "type": 5126, "semantic": "_DIRECTLIGHTS" }, "pointLights[0]": { "type": 5126, "semantic": "_POINTLIGHTS" }, "spotLights[0]": { "type": 5126, "semantic": "_SPOTLIGHTS" }, "ltc_1": { "type": 35678, "semantic": "Unknown" }, "ltc_2": { "type": 35678, "semantic": "Unknown" }, "rectAreaLights[0]": { "type": -1, "semantic": "Unknown" }, "hemisphereLights[0]": { "type": -1, "semantic": "Unknown" }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "directionalShadowMatrix[0]": { "type": 35676, "semantic": "_DIRECTIONSHADOWMAT" }, "spotShadowMatrix[0]": { "type": 35676, "semantic": "_SPOTSHADOWMAT" }, "pointShadowMatrix[0]": { "type": 35676, "semantic": "_POINTSHADOWMAT" }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "lightMap": { "type": 35678, "semantic": "_LIGHTMAPTEX" }, "lightMapIntensity": { "type": 5126, "semantic": "_LIGHTMAPINTENSITY" }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126, "value": [] }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124, "value": [] }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "directionalShadowMap[0]": { "type": 35678, "semantic": "_DIRECTIONSHADOWMAP" }, "spotShadowMap[0]": { "type": 35678, "semantic": "_SPOTSHADOWMAP" }, "pointShadowMap[0]": { "type": 35678, "semantic": "_POINTSHADOWMAT" }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshphong = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshphong_vert", "type": 35633, "uri": "#define PHONG\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "meshphong_frag", "type": 35632, "uri": "#define PHONG\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <gradientmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_phong_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_phong_fragment>\r\n\t#include <lights_fragment_begin>\r\n\t#include <lights_fragment_maps>\r\n\t#include <lights_fragment_end>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshphong", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "uv2": { "semantic": "TEXCOORD_1" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "refractionRatio": { "type": 5126, "value": [] }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "directionalShadowMatrix[0]": { "type": 35676, "semantic": "_DIRECTIONSHADOWMAT" }, "spotShadowMatrix[0]": { "type": 35676, "semantic": "_SPOTSHADOWMAT" }, "pointShadowMatrix[0]": { "type": 35676, "semantic": "_POINTSHADOWMAT" }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "specular": { "type": 35665, "value": [1, 1, 1] }, "shininess": { "type": 5126, "value": 1 }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "lightMap": { "type": 35678, "semantic": "_LIGHTMAPTEX" }, "lightMapIntensity": { "type": 5126, "semantic": "_LIGHTMAPINTENSITY" }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126, "value": [] }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124, "value": [] }, "gradientMap": { "type": 35678 }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "ambientLightColor": { "type": 35665, "semantic": "_AMBIENTLIGHTCOLOR" }, "directionalLights[0]": { "type": 5126, "semantic": "_DIRECTLIGHTS" }, "pointLights[0]": { "type": 5126, "semantic": "_POINTLIGHTS" }, "spotLights[0]": { "type": 5126, "semantic": "_SPOTLIGHTS" }, "ltc_1": { "type": 35678, "semantic": "Unknown" }, "ltc_2": { "type": 35678, "semantic": "Unknown" }, "rectAreaLights[0]": { "type": -1, "semantic": "Unknown" }, "hemisphereLights[0]": { "type": -1, "semantic": "Unknown" }, "directionalShadowMap[0]": { "type": 35678, "semantic": "_DIRECTIONSHADOWMAP" }, "spotShadowMap[0]": { "type": 35678, "semantic": "_SPOTSHADOWMAP" }, "pointShadowMap[0]": { "type": 35678, "semantic": "_POINTSHADOWMAT" }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664 }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshphysical = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshphysical_vert", "type": 35633, "uri": "#define PHYSICAL\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "meshphysical_frag", "type": 35632, "uri": "#define PHYSICAL\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform float opacity;\r\n\r\n#ifndef STANDARD\r\n\tuniform float clearCoat;\r\n\tuniform float clearCoatRoughness;\r\n#endif\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <bsdfs>\r\n#include <cube_uv_reflection_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <envmap_physical_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <lights_pars_begin>\r\n#include <lights_physical_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <roughnessmap_pars_fragment>\r\n#include <metalnessmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <roughnessmap_fragment>\r\n\t#include <metalnessmap_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_physical_fragment>\r\n\t#include <lights_fragment_begin>\r\n\t#include <lights_fragment_maps>\r\n\t#include <lights_fragment_end>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshphysical", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "uv2": { "semantic": "TEXCOORD_1" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "directionalShadowMatrix[0]": { "type": 35676, "semantic": "_DIRECTIONSHADOWMAT" }, "spotShadowMatrix[0]": { "type": 35676, "semantic": "_SPOTSHADOWMAT" }, "pointShadowMatrix[0]": { "type": 35676, "semantic": "_POINTSHADOWMAT" }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "roughness": { "type": 5126 }, "metalness": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "clearCoat": { "type": 5126 }, "clearCoatRoughness": { "type": 5126 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "lightMap": { "type": 35678, "semantic": "_LIGHTMAPTEX" }, "lightMapIntensity": { "type": 5126, "semantic": "_LIGHTMAPINTENSITY" }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126, "value": [] }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124, "value": [] }, "refractionRatio": { "type": 5126, "value": [] }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "ambientLightColor": { "type": 35665, "semantic": "_AMBIENTLIGHTCOLOR" }, "directionalLights[0]": { "type": 5126, "semantic": "_DIRECTLIGHTS" }, "pointLights[0]": { "type": 5126, "semantic": "_POINTLIGHTS" }, "spotLights[0]": { "type": 5126, "semantic": "_SPOTLIGHTS" }, "ltc_1": { "type": 35678, "semantic": "Unknown" }, "ltc_2": { "type": 35678, "semantic": "Unknown" }, "rectAreaLights[0]": { "type": -1, "semantic": "Unknown" }, "hemisphereLights[0]": { "type": -1, "semantic": "Unknown" }, "directionalShadowMap[0]": { "type": 35678, "semantic": "_DIRECTIONSHADOWMAP" }, "spotShadowMap[0]": { "type": 35678, "semantic": "_SPOTSHADOWMAP" }, "pointShadowMap[0]": { "type": 35678, "semantic": "_POINTSHADOWMAT" }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664 }, "roughnessMap": { "type": 35678 }, "metalnessMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.normal = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "normal_vert", "type": 35633, "uri": "#define NORMAL\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvarying vec3 vViewPosition;\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n#endif\r\n\r\n}\r\n" }, { "name": "normal_frag", "type": 35632, "uri": "#define NORMAL\r\n\r\nuniform float opacity;\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvarying vec3 vViewPosition;\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\r\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\r\n\r\n}\r\n" }], "techniques": [{ "name": "normal", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676, "semantic": "JOINTMATRIX" }, "logDepthBufFC": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.particle = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "particle_vert", "type": 35633, "uri": "//inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.vs\r\n#include <common>\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec2 corner;\r\n#endif\r\nattribute vec3 startPosition;\r\nattribute vec3 startVelocity;\r\nattribute vec4 startColor;\r\nattribute vec3 startSize;\r\nattribute vec3 startRotation;\r\nattribute vec2 time;\r\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)||defined(ROTATIONTWOCONSTANTS)||defined(ROTATIONTWOCURVES)\r\n  attribute vec4 random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONTWOCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\r\n  attribute vec4 random1;\r\n#endif\r\nattribute vec3 startWorldPosition;\r\nattribute vec4 startWorldRotation;\r\n\r\n#include <particle_common>\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_currentTime - time.y;\r\n\tfloat t = age/time.x;\r\n\tif(t>1.0){ \t\t\t\r\n\t\t\tv_discard=1.0;\r\n\t\t\treturn;\r\n  }\r\n\t  \r\n\t#include <particle_affector>\r\n\tgl_Position=viewProjectionMatrix*vec4(center,1.0);\r\n\tv_color = computeColor(startColor, t);\r\n\tv_texcoord =computeUV(uv, t);\r\n\tv_discard=0.0;\r\n}\r\n\r\n" }, { "name": "particle_frag", "type": 35632, "uri": "//inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.ps\r\n#include <common>\r\nuniform sampler2D map;\r\nuniform vec3 diffuse;\r\nuniform float opacity;\r\nvarying float v_discard;\r\nvarying vec4 v_color;\r\nvarying vec2 v_texcoord;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_mesh_color;\r\n#endif\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_mesh_color;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\r\n\tif(v_discard!=0.0)\r\n\t\tdiscard;\r\n\tgl_FragColor*=texture2D(map,v_texcoord)*vec4(diffuse, opacity)*v_color*2.0;\r\n}" }], "techniques": [{ "name": "particle", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "corner": { "semantic": "_CORNER" }, "startPosition": { "semantic": "_START_POSITION" }, "startVelocity": { "semantic": "_START_VELOCITY" }, "startColor": { "semantic": "_START_COLOR" }, "startSize": { "semantic": "_START_SIZE" }, "startRotation": { "semantic": "_START_ROTATION" }, "time": { "semantic": "_TIME" }, "random0": { "semantic": "_RANDOM0" }, "random1": { "semantic": "_RANDOM1" }, "startWorldPosition": { "semantic": "_WORLD_POSITION" }, "startWorldRotation": { "semantic": "_WORLD_ROTATION" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "u_currentTime": { "type": 5126 }, "u_gravity": { "type": 35665 }, "u_worldPosition": { "type": 35665, "value": [0, 0, 0] }, "u_worldRotation": { "type": 35666, "value": [0, 0, 0, 1] }, "u_startRotation3D": { "type": 35670 }, "u_scalingMode": { "type": 5124 }, "u_positionScale": { "type": 35665 }, "u_sizeScale": { "type": 35665 }, "viewProjectionMatrix": { "type": 35676, "semantic": "_VIEWPROJECTION" }, "cameraForward": { "type": 35665, "semantic": "_CAMERA_FORWARD" }, "cameraUp": { "type": 35665, "semantic": "CAMERA_UP" }, "u_lengthScale": { "type": 5126 }, "u_speeaScale": { "type": 5126 }, "u_simulationSpace": { "type": 5124 }, "u_spaceType": { "type": 5124 }, "u_velocityConst": { "type": 35665 }, "u_velocityCurveX[0]": { "type": 35664 }, "u_velocityCurveY[0]": { "type": 35664 }, "u_velocityCurveZ[0]": { "type": 35664 }, "u_velocityConstMax": { "type": 35665 }, "u_velocityCurveMaxX[0]": { "type": 35664 }, "u_velocityCurveMaxY[0]": { "type": 35664 }, "u_velocityCurveMaxZ[0]": { "type": 35664 }, "u_colorGradient[0]": { "type": 35666 }, "u_alphaGradient[0]": { "type": 35664 }, "u_colorGradientMax[0]": { "type": 35666 }, "u_alphaGradientMax[0]": { "type": 35664 }, "u_sizeCurve[0]": { "type": 35664 }, "u_sizeCurveMax[0]": { "type": 35664 }, "u_sizeCurveX[0]": { "type": 35664 }, "u_sizeCurveY[0]": { "type": 35664 }, "u_sizeCurveZ[0]": { "type": 35664 }, "u_sizeCurveMaxX[0]": { "type": 35664 }, "u_sizeCurveMaxY[0]": { "type": 35664 }, "u_sizeCurveMaxZ[0]": { "type": 35664 }, "u_rotationConst": { "type": 5126 }, "u_rotationConstMax": { "type": 5126 }, "u_rotationCurve[0]": { "type": 35664 }, "u_rotationCurveMax[0]": { "type": 35664 }, "u_rotationConstSeprarate": { "type": 35665 }, "u_rotationConstMaxSeprarate": { "type": 35665 }, "u_rotationCurveX[0]": { "type": 35664 }, "u_rotationCurveY[0]": { "type": 35664 }, "u_rotationCurveZ[0]": { "type": 35664 }, "u_rotationCurveW[0]": { "type": 35664 }, "u_rotationCurveMaxX[0]": { "type": 35664 }, "u_rotationCurveMaxY[0]": { "type": 35664 }, "u_rotationCurveMaxZ[0]": { "type": 35664 }, "u_rotationCurveMaxW[0]": { "type": 35664 }, "u_cycles": { "type": 5126 }, "u_subUV": { "type": 35666 }, "u_uvCurve[0]": { "type": 35664 }, "u_uvCurveMax[0]": { "type": 35664 }, "map": { "type": 35678 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.points = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "points_vert", "type": 35633, "uri": "uniform float size;\r\nuniform float scale;\r\n\r\n#include <common>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <project_vertex>\r\n\r\n\tgl_PointSize = size;\r\n\r\n\t#ifdef USE_SIZEATTENUATION\r\n\r\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\r\n\r\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\r\n\r\n\t#endif\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "points_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <map_particle_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_particle_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "points", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "size": { "type": 5126 }, "scale": { "type": 5126, "value": 1 }, "morphTargetInfluences[0]": { "type": 5126 }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "map": { "type": 35678 }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.shadow = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "shadow_vert", "type": 35633, "uri": "\r\n#include <fog_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "shadow_frag", "type": 35632, "uri": "uniform vec3 color;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\r\n\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "shadow", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "directionalShadowMatrix[0]": { "type": 35676, "semantic": "_DIRECTIONSHADOWMAT" }, "spotShadowMatrix[0]": { "type": 35676, "semantic": "_SPOTSHADOWMAT" }, "pointShadowMatrix[0]": { "type": 35676, "semantic": "_POINTSHADOWMAT" }, "color": { "type": 35665 }, "opacity": { "type": 5126, "value": 1 }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "ambientLightColor": { "type": 35665, "semantic": "_AMBIENTLIGHTCOLOR" }, "directionalLights[0]": { "type": 5126, "semantic": "_DIRECTLIGHTS" }, "pointLights[0]": { "type": 5126, "semantic": "_POINTLIGHTS" }, "spotLights[0]": { "type": 5126, "semantic": "_SPOTLIGHTS" }, "ltc_1": { "type": 35678, "semantic": "Unknown" }, "ltc_2": { "type": 35678, "semantic": "Unknown" }, "rectAreaLights[0]": { "type": -1, "semantic": "Unknown" }, "hemisphereLights[0]": { "type": -1, "semantic": "Unknown" }, "directionalShadowMap[0]": { "type": 35678, "semantic": "_DIRECTIONSHADOWMAP" }, "spotShadowMap[0]": { "type": 35678, "semantic": "_SPOTSHADOWMAP" }, "pointShadowMap[0]": { "type": 35678, "semantic": "_POINTSHADOWMAT" } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.sprite = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "sprite_vert", "type": 35633, "uri": "uniform float rotation;\r\nuniform vec2 center;\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\n\tvec2 scale;\r\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\r\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\r\n\r\n\t#ifndef USE_SIZEATTENUATION\r\n\r\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\r\n\r\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\r\n\r\n\t#endif\r\n\r\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\r\n\r\n\tvec2 rotatedPosition;\r\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\r\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\r\n\r\n\tmvPosition.xy += rotatedPosition;\r\n\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "sprite_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "sprite", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "rotation": { "type": 5126 }, "center": { "type": 35664 }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "fogColor": { "type": 35665, "semantic": "_FOG_COLOR" }, "fogDensity": { "type": 5126, "semantic": "_FOG_DENSITY" }, "fogNear": { "type": 5126, "semantic": "_FOG_NEAR" }, "fogFar": { "type": 5126, "semantic": "_FOG_FAR" }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
    })(ShaderLib = egret3d.ShaderLib || (egret3d.ShaderLib = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderChunk;
    (function (ShaderChunk) {
        ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
        ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n uniform sampler2D alphaMap;\n\n#endif\n";
        ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";
        ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n\n // reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n reflectedLight.indirectDiffuse *= ambientOcclusion;\n\n #if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n  float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n  reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n #endif\n\n#endif\n";
        ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n\n uniform sampler2D aoMap;\n uniform float aoMapIntensity;\n\n#endif";
        ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
        ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n";
        ShaderChunk.bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n if( decayExponent > 0.0 ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n  // based upon Frostbite 3 Moving to Physically-based Rendering\n  // page 32, equation 26: E[window1]\n  // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n  // this is intended to be used on spot and point lights who are represented as luminous intensity\n  // but who must be converted to luminous irradiance for surface lighting calculation\n  float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n  float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n  return distanceFalloff * maxDistanceCutoffFactor;\n\n#else\n\n  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n#endif\n\n }\n\n return 1.0;\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n return RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n // Original approximation by Christophe Schlick '94\n // float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n // Optimized variant (presented by Epic at SIGGRAPH '13)\n // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n // geometry term (normalized) = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\n // also see #12151\n\n float a2 = pow2( alpha );\n\n float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n return 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n float a2 = pow2( alpha );\n\n // dotNL and dotNV are explicitly swapped. This is not a mistake.\n float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n return 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n float a2 = pow2( alpha );\n\n float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n return RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n float alpha = pow2( roughness ); // UE4's roughness\n\n vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n float dotNH = saturate( dot( geometry.normal, halfDir ) );\n float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n vec3 F = F_Schlick( specularColor, dotLH );\n\n float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n float D = D_GGX( alpha, dotNH );\n\n return F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n const float LUT_SIZE  = 64.0;\n const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n const float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n float dotNV = saturate( dot( N, V ) );\n\n // texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n uv = uv * LUT_SCALE + LUT_BIAS;\n\n return uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n // Real-Time Area Lighting: a Journey from Research to Production (p.102)\n // An approximation of the form factor of a horizon-clipped rectangle.\n\n float l = length( f );\n\n return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n float x = dot( v1, v2 );\n\n float y = abs( x );\n\n // rational polynomial approximation to theta / sin( theta ) / 2PI\n float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n float b = 3.4175940 + ( 4.1616724 + y ) * y;\n float v = a / b;\n\n float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n return cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n // bail if point is on back side of plane of light\n // assumes ccw winding order of light vertices\n vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n vec3 lightNormal = cross( v1, v2 );\n\n if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n // construct orthonormal basis around N\n vec3 T1, T2;\n T1 = normalize( V - N * dot( V, N ) );\n T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n // compute transform\n mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n // transform rect\n vec3 coords[ 4 ];\n coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n // project rect onto sphere\n coords[ 0 ] = normalize( coords[ 0 ] );\n coords[ 1 ] = normalize( coords[ 1 ] );\n coords[ 2 ] = normalize( coords[ 2 ] );\n coords[ 3 ] = normalize( coords[ 3 ] );\n\n // calculate vector form factor\n vec3 vectorFormFactor = vec3( 0.0 );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n // adjust for horizon clipping\n float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n // alternate method of adjusting for horizon clipping (see referece)\n // refactoring required\n float len = length( vectorFormFactor );\n float z = vectorFormFactor.z / len;\n\n const float LUT_SIZE  = 64.0;\n const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n const float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n // tabulated horizon-clipped sphere, apparently...\n vec2 uv = vec2( z * 0.5 + 0.5, len );\n uv = uv * LUT_SCALE + LUT_BIAS;\n\n float scale = texture2D( ltc_2, uv ).w;\n\n float result = len * scale;\n*/\n\n return vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n vec4 r = roughness * c0 + c1;\n\n float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n return specularColor * AB.x + AB.y;\n\n} // validated\n\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n return 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n //float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n //float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n float dotNH = saturate( dot( geometry.normal, halfDir ) );\n float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n vec3 F = F_Schlick( specularColor, dotLH );\n\n float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n float D = D_BlinnPhong( shininess, dotNH );\n\n return F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
        ShaderChunk.bumpMap_pars_frag = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n uniform float bumpScale;\n\n // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd(vec2 uv) {\n\n  vec2 dSTdx = dFdx( uv );\n  vec2 dSTdy = dFdy( uv );\n\n  float Hll = bumpScale * texture2D( bumpMap, uv ).x;\n  float dBx = bumpScale * texture2D( bumpMap, uv + dSTdx ).x - Hll;\n  float dBy = bumpScale * texture2D( bumpMap, uv + dSTdy ).x - Hll;\n\n  return vec2( dBx, dBy );\n\n }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n\n  vec3 vSigmaX = dFdx( surf_pos );\n  vec3 vSigmaY = dFdy( surf_pos );\n  vec3 vN = surf_norm;  // normalized\n\n  vec3 R1 = cross( vSigmaY, vN );\n  vec3 R2 = cross( vN, vSigmaX );\n\n  float fDet = dot( vSigmaX, R1 );\n\n  vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n  return normalize( abs( fDet ) * surf_norm - vGrad );\n\n }\n\n#endif\n";
        ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n uniform float bumpScale;\n\n // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n // http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd() {\n\n  vec2 dSTdx = dFdx( vUv );\n  vec2 dSTdy = dFdy( vUv );\n\n  float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n  float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n  float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n  return vec2( dBx, dBy );\n\n }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n  // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n  vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n  vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n  vec3 vN = surf_norm;  // normalized\n\n  vec3 R1 = cross( vSigmaY, vN );\n  vec3 R2 = cross( vN, vSigmaX );\n\n  float fDet = dot( vSigmaX, R1 );\n\n  fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n  vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n  return normalize( abs( fDet ) * surf_norm - vGrad );\n\n }\n\n#endif\n";
        ShaderChunk.clipping_planes_fragment = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0\n\n vec4 plane;\n\n // #pragma unroll_loop\n for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n  plane = clippingPlanes[ i ];\n  if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\n }\n\n #if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n  bool clipped = true;\n\n  // #pragma unroll_loop\n  for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n   plane = clippingPlanes[ i ];\n   clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\n  }\n\n  if ( clipped ) discard;\n\n #endif\n\n#endif\n";
        ShaderChunk.clipping_planes_pars_fragment = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0\n\n #if ! defined( PHYSICAL ) && ! defined( PHONG )\n  varying vec3 vViewPosition;\n #endif\n\n uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n";
        ShaderChunk.clipping_planes_pars_vertex = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n varying vec3 vViewPosition;\n#endif\n";
        ShaderChunk.clipping_planes_vertex = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n vViewPosition = - mvPosition.xyz;\n#endif\n\n";
        ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n diffuseColor.rgb *= vColor;\n\n#endif";
        ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif\n";
        ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif";
        ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n vColor.xyz = color.xyz;\n\n#endif";
        ShaderChunk.common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n return fract(sin(sn) * c);\n}\n\nstruct IncidentLight {\n vec3 color;\n vec3 direction;\n bool visible;\n};\n\nstruct ReflectedLight {\n vec3 directDiffuse;\n vec3 directSpecular;\n vec3 indirectDiffuse;\n vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n vec3 position;\n vec3 normal;\n vec3 viewDir;\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n float distance = dot( planeNormal, point - pointOnPlane );\n\n return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n mat3 tmp;\n\n tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n return tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n return dot( weights, color.rgb );\n\n}\n";
        ShaderChunk.common_frag_def = "//------------------------------------------------\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n//------------------------------------------------\n";
        ShaderChunk.common_vert_def = "\n//------------------------------------------------\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\n#ifdef USE_COLOR\n\n attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n attribute vec3 morphTarget0;\n attribute vec3 morphTarget1;\n attribute vec3 morphTarget2;\n attribute vec3 morphTarget3;\n #ifdef USE_MORPHNORMALS\n  attribute vec3 morphNormal0;\n  attribute vec3 morphNormal1;\n  attribute vec3 morphNormal2;\n  attribute vec3 morphNormal3;\n #else\n  attribute vec3 morphTarget4;\n  attribute vec3 morphTarget5;\n  attribute vec3 morphTarget6;\n  attribute vec3 morphTarget7;\n #endif\n#endif\n#ifdef USE_SKINNING\n attribute vec4 skinIndex;\n attribute vec4 skinWeight;\n#endif\n//------------------------------------------------\n";
        ShaderChunk.cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_textureSize (1024.0)\n\nint getFaceFromDirection(vec3 direction) {\n vec3 absDirection = abs(direction);\n int face = -1;\n if( absDirection.x > absDirection.z ) {\n  if(absDirection.x > absDirection.y )\n   face = direction.x > 0.0 ? 0 : 3;\n  else\n   face = direction.y > 0.0 ? 1 : 4;\n }\n else {\n  if(absDirection.z > absDirection.y )\n   face = direction.z > 0.0 ? 2 : 5;\n  else\n   face = direction.y > 0.0 ? 1 : 4;\n }\n return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\n\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n float dxRoughness = dFdx(roughness);\n float dyRoughness = dFdy(roughness);\n vec3 dx = dFdx( vec * scale * dxRoughness );\n vec3 dy = dFdy( vec * scale * dyRoughness );\n float d = max( dot( dx, dx ), dot( dy, dy ) );\n // Clamp the value to the max mip level counts. hard coded to 6 mips\n d = clamp(d, 1.0, cubeUV_rangeClamp);\n float mipLevel = 0.5 * log2(d);\n return vec2(floor(mipLevel), fract(mipLevel));\n}\n\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\n\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n float a = 16.0 * cubeUV_rcpTextureSize;\n\n vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n // float powScale = exp2(roughnessLevel + mipLevel);\n float powScale = exp2_packed.x * exp2_packed.y;\n // float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);\n float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n // float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);\n float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\n bool bRes = mipLevel == 0.0;\n scale =  bRes && (scale < a) ? a : scale;\n\n vec3 r;\n vec2 offset;\n int face = getFaceFromDirection(direction);\n\n float rcpPowScale = 1.0 / powScale;\n\n if( face == 0) {\n  r = vec3(direction.x, -direction.z, direction.y);\n  offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n }\n else if( face == 1) {\n  r = vec3(direction.y, direction.x, direction.z);\n  offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n }\n else if( face == 2) {\n  r = vec3(direction.z, direction.x, direction.y);\n  offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n }\n else if( face == 3) {\n  r = vec3(direction.x, direction.z, direction.y);\n  offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n }\n else if( face == 4) {\n  r = vec3(direction.y, direction.x, -direction.z);\n  offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n }\n else {\n  r = vec3(direction.z, -direction.x, direction.y);\n  offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n }\n r = normalize(r);\n float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n vec2 base = offset + vec2( texelOffset );\n return base + s * ( scale - 2.0 * texelOffset );\n}\n\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\n\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n float roughnessVal = roughness* cubeUV_maxLods3;\n float r1 = floor(roughnessVal);\n float r2 = r1 + 1.0;\n float t = fract(roughnessVal);\n vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n float s = mipInfo.y;\n float level0 = mipInfo.x;\n float level1 = level0 + 1.0;\n level1 = level1 > 5.0 ? 5.0 : level1;\n\n // round to nearest mipmap if we are not interpolating.\n level0 += min( floor( s + 0.5 ), 5.0 );\n\n // Tri linear interpolation.\n vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\n vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\n vec4 result = mix(color10, color20, t);\n\n return vec4(result.rgb, 1.0);\n}\n\n#endif\n";
        ShaderChunk.defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n\n#ifdef FLIP_SIDED\n\n transformedNormal = - transformedNormal;\n\n#endif\n";
        ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\n uniform sampler2D displacementMap;\n uniform float displacementScale;\n uniform float displacementBias;\n\n#endif\n";
        ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\n transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";
        ShaderChunk.dithering_fragment = "#if defined( DITHERING )\n\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n";
        ShaderChunk.dithering_pars_fragment = "#if defined( DITHERING )\n\n // based on https://www.shadertoy.com/view/MslGR8\n vec3 dithering( vec3 color ) {\n  //Calculate grid position\n  float grid_position = rand( gl_FragCoord.xy );\n\n  //Shift the individual colors differently, thus making it even harder to see the dithering pattern\n  vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n  //modify shift acording to grid position.\n  dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n  //shift the color by dither_shift\n  return color + dither_shift_RGB;\n }\n\n#endif\n";
        ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\n vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n totalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n";
        ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\n uniform sampler2D emissiveMap;\n\n#endif\n";
        ShaderChunk.encodings_fragment = "  // gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
        ShaderChunk.encodings_pars_fragment = "// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n return value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n float maxComponent = max( max( value.r, value.g ), value.b );\n float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n float maxRGB = max( value.x, max( value.g, value.b ) );\n float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n M            = ceil( M * 255.0 ) / 255.0;\n return vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n float maxRGB = max( value.x, max( value.g, value.b ) );\n float D      = max( maxRange / maxRGB, 1.0 );\n D            = min( floor( D ) / 255.0, 1.0 );\n return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n vec4 vResult;\n vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n vResult.w = fract(Le);\n vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n return vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n float Le = value.z * 255.0 + value.w;\n vec3 Xp_Y_XYZp;\n Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n return vec4( max(vRGB, 0.0), 1.0 );\n}\n";
        ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n  vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n  // Transforming Normal Vectors with the Inverse Transformation\n  vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n  #else\n\n   vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n  #endif\n\n #else\n\n  vec3 reflectVec = vReflect;\n\n #endif\n\n #ifdef ENVMAP_TYPE_CUBE\n\n  vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n #elif defined( ENVMAP_TYPE_EQUIREC )\n\n  vec2 sampleUV;\n\n  reflectVec = normalize( reflectVec );\n\n  sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n  sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n  vec4 envColor = texture2D( envMap, sampleUV );\n\n #elif defined( ENVMAP_TYPE_SPHERE )\n\n  reflectVec = normalize( reflectVec );\n\n  vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\n  vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\n #else\n\n  vec4 envColor = vec4( 0.0 );\n\n #endif\n\n envColor = envMapTexelToLinear( envColor );\n\n #ifdef ENVMAP_BLENDING_MULTIPLY\n\n  outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n #elif defined( ENVMAP_BLENDING_MIX )\n\n  outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n #elif defined( ENVMAP_BLENDING_ADD )\n\n  outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n #endif\n\n#endif\n";
        ShaderChunk.envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n uniform float reflectivity;\n uniform float envMapIntensity;\n#endif\n\n#ifdef USE_ENVMAP\n\n #if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n  varying vec3 vWorldPosition;\n #endif\n\n #ifdef ENVMAP_TYPE_CUBE\n  uniform samplerCube envMap;\n #else\n  uniform sampler2D envMap;\n #endif\n uniform float flipEnvMap;\n uniform int maxMipLevel;\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n  uniform float refractionRatio;\n #else\n  varying vec3 vReflect;\n #endif\n\n#endif\n";
        ShaderChunk.envmap_pars_vertex = "#ifdef USE_ENVMAP\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n  varying vec3 vWorldPosition;\n\n #else\n\n  varying vec3 vReflect;\n  uniform float refractionRatio;\n\n #endif\n\n#endif\n";
        ShaderChunk.envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n  vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n   // TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n   // of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n   #else\n\n    // force the bias high to get the last LOD level as it is the most blurred.\n    vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n   vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\n  #else\n\n   vec4 envMapColor = vec4( 0.0 );\n\n  #endif\n\n  return PI * envMapColor.rgb * envMapIntensity;\n\n }\n\n // taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n  //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  float maxMIPLevelScalar = float( maxMIPLevel );\n  float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  // clamp to allowable LOD ranges.\n  return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n }\n\n vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n  #else\n\n   vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n  #endif\n\n  reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n  float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n   vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\n  #elif defined( ENVMAP_TYPE_EQUIREC )\n\n   vec2 sampleUV;\n   sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n   sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_SPHERE )\n\n   vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #endif\n\n  return envMapColor.rgb * envMapIntensity;\n\n }\n\n#endif\n";
        ShaderChunk.envmap_vertex = "#ifdef USE_ENVMAP\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n  vWorldPosition = worldPosition.xyz;\n\n #else\n\n  vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n  vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vReflect = reflect( cameraToVertex, worldNormal );\n\n  #else\n\n   vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n  #endif\n\n #endif\n\n#endif\n";
        ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n float fogDepth = length( vFogPosition );\n\n #ifdef FOG_EXP2\n\n  float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\n #else\n\n  float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n #endif\n\n gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n";
        ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n uniform vec3 fogColor;\n varying vec3 vFogPosition;\n\n #ifdef FOG_EXP2\n\n  uniform float fogDensity;\n\n #else\n\n  uniform float fogNear;\n  uniform float fogFar;\n\n #endif\n\n#endif\n";
        ShaderChunk.fog_pars_vertex = "#ifdef USE_FOG\n\n varying vec3 vFogPosition;\n\n#endif\n";
        ShaderChunk.fog_vertex = "#ifdef USE_FOG\n\n vFogPosition = mvPosition.xyz;\n\n#endif\n";
        ShaderChunk.gradientmap_pars_fragment = "#ifdef TOON\n\n uniform sampler2D gradientMap;\n\n vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n  // dotNL will be from -1.0 to 1.0\n  float dotNL = dot( normal, lightDirection );\n  vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n  #ifdef USE_GRADIENTMAP\n\n   return texture2D( gradientMap, coord ).rgb;\n\n  #else\n\n   return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n  #endif\n\n\n }\n\n#endif\n";
        ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n";
        ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n uniform sampler2D lightMap;\n uniform float lightMapIntensity;\n\n#endif";
        ShaderChunk.lights_fragment_begin = "/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n\nIncidentLight directLight;\n\n#if (defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n PointLight pointLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  // pointLight = pointLights[ i ];\n  pointLight.position = vec3(pointLights[i* 15 + 0], pointLights[i * 15 + 1], pointLights[i * 15 + 2]);\n  pointLight.color = vec3(pointLights[i* 15 + 3], pointLights[i * 15 + 4], pointLights[i * 15 + 5]);\n  pointLight.distance = pointLights[i * 15 + 6];\n  pointLight.decay = pointLights[i * 15 + 7];\n\n  getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n  #ifdef USE_SHADOWMAP\n  directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n  #endif\n\n  RE_Direct( directLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if (defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n SpotLight spotLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n  // spotLight = spotLights[ i ];\n  spotLight.position = vec3(spotLights[i * 18 + 0], spotLights[i * 18 + 1], spotLights[i * 18 + 2]);\n  spotLight.direction = vec3(spotLights[i * 18 + 3], spotLights[i * 18 + 4], spotLights[i * 18 + 5]);\n  spotLight.color = vec3(spotLights[i * 18 + 6], spotLights[i * 18 + 7], spotLights[i * 18 + 8]);\n  spotLight.distance = spotLights[i * 18 + 9];\n  spotLight.decay = spotLights[i * 18 + 10];\n  spotLight.coneCos = spotLights[i * 18 + 11];\n  spotLight.penumbraCos = spotLights[i * 18 + 12];\n  getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n  #ifdef USE_SHADOWMAP\n  directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n  #endif\n\n  RE_Direct( directLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if (defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n DirectionalLight directionalLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  // directionalLight = directionalLights[ i ];\n  directionalLight.direction = vec3(directionalLights[i * 12 + 0], directionalLights[i * 12 + 1], directionalLights[i * 12 + 2]);\n  directionalLight.color = vec3(directionalLights[i * 12 + 3], directionalLights[i * 12 + 4], directionalLights[i * 12 + 5]);\n  getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n  #ifdef USE_SHADOWMAP\n  directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n  #endif\n\n  RE_Direct( directLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if (defined(NUM_RECT_AREA_LIGHTS) &&  NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n RectAreaLight rectAreaLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n  rectAreaLight = rectAreaLights[ i ];\n  RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n #if (defined(NUM_HEMI_LIGHTS) &&  NUM_HEMI_LIGHTS > 0 )\n\n  // #pragma unroll_loop\n  for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n   irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n  }\n\n #endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n vec3 radiance = vec3( 0.0 );\n vec3 clearCoatRadiance = vec3( 0.0 );\n\n#endif\n";
        ShaderChunk.lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\n RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n\n#endif\n";
        ShaderChunk.lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\n #ifdef USE_LIGHTMAP\n\n  vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n   lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n  #endif\n\n  irradiance += lightMapIrradiance;\n\n #endif\n\n #if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n  irradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\n\n #endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\n #ifndef STANDARD\n  clearCoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n #endif\n\n#endif\n";
        ShaderChunk.lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n vLightBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\n#if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0\n PointLight pointLight;\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  pointLight.position = vec3(pointLights[i* 15 + 0], pointLights[i * 15 + 1], pointLights[i * 15 + 2]);\n  pointLight.color = vec3(pointLights[i* 15 + 3], pointLights[i * 15 + 4], pointLights[i * 15 + 5]);\n  pointLight.distance = pointLights[i * 15 + 6];\n  pointLight.decay = pointLights[i * 15 + 7];\n  getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n  dotNL = dot( geometry.normal, directLight.direction );\n  directLightColor_Diffuse = PI * directLight.color;\n\n  vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n  #endif\n\n }\n\n#endif\n\n#if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0\n SpotLight spotLight;\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n  spotLight.position = vec3(spotLights[i * 18 + 0], spotLights[i * 18 + 1], spotLights[i * 18 + 2]);\n  spotLight.direction = vec3(spotLights[i * 18 + 3], spotLights[i * 18 + 4], spotLights[i * 18 + 5]);\n  spotLight.color = vec3(spotLights[i * 18 + 6], spotLights[i * 18 + 7], spotLights[i * 18 + 8]);\n  spotLight.distance = spotLights[i * 18 + 9];\n  spotLight.decay = spotLights[i * 18 + 10];\n  spotLight.coneCos = spotLights[i * 18 + 11];\n  spotLight.penumbraCos = spotLights[i * 18 + 12];\n\n  getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n  dotNL = dot( geometry.normal, directLight.direction );\n  directLightColor_Diffuse = PI * directLight.color;\n\n  vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n  #endif\n }\n\n#endif\n\n/*\n#if NUM_RECT_AREA_LIGHTS > 0\n\n for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n  // TODO (abelnation): implement\n\n }\n\n#endif\n*/\n\n#if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0\n DirectionalLight directionalLight;\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  directionalLight.direction = vec3(directionalLights[i * 12 + 0], directionalLights[i * 12 + 1], directionalLights[i * 12 + 2]);\n  directionalLight.color = vec3(directionalLights[i * 12 + 3], directionalLights[i * 12 + 4], directionalLights[i * 12 + 5]);\n  getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n  dotNL = dot( geometry.normal, directLight.direction );\n  directLightColor_Diffuse = PI * directLight.color;\n  // directLightColor_Diffuse = directLight.color;\n\n  vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n  // vLightFront += directLightColor_Diffuse;\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n  #endif\n\n }\n\n#endif\n\n#if defined(NUM_HEMI_LIGHTS) && NUM_HEMI_LIGHTS > 0\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n  vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n  #endif\n\n }\n\n#endif\n";
        ShaderChunk.lights_pars_begin = "uniform vec3 ambientLightColor;\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n vec3 irradiance = ambientLightColor;\n\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n  irradiance *= PI;\n\n #endif\n\n return irradiance;\n\n}\n\n#if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0\n\n struct DirectionalLight {\n  vec3 direction;\n  vec3 color;\n\n  int shadow;\n  float shadowBias;\n  float shadowRadius;\n  vec2 shadowMapSize;\n };\n\n uniform float directionalLights[NUM_DIR_LIGHTS * 12];\n\n void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n  directLight.direction = directionalLight.direction;\n  directLight.color = directionalLight.color;\n  directLight.visible = true;\n }\n\n#endif\n\n\n#if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0\n\n struct PointLight {\n  vec3 position;\n  vec3 color;\n  float distance;\n  float decay;\n\n  int shadow;\n  float shadowBias;\n  float shadowRadius;\n  vec2 shadowMapSize;\n  float shadowCameraNear;\n  float shadowCameraFar;\n };\n\n uniform float pointLights[NUM_POINT_LIGHTS * 15 ];\n\n // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n  vec3 lVector = pointLight.position - geometry.position;\n  directLight.direction = normalize( lVector );\n\n  float lightDistance = length( lVector );\n\n  directLight.color = pointLight.color;\n  directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n  directLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n }\n\n#endif\n\n\n#if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0\n\n struct SpotLight {\n  vec3 position;\n  vec3 direction;\n  vec3 color;\n  float distance;\n  float decay;\n  float coneCos;\n  float penumbraCos;\n\n  int shadow;\n  float shadowBias;\n  float shadowRadius;\n  vec2 shadowMapSize;\n };\n\n uniform float spotLights[NUM_SPOT_LIGHTS * 18];\n\n // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n  vec3 lVector = spotLight.position - geometry.position;\n  directLight.direction = normalize( lVector );\n\n  float lightDistance = length( lVector );\n  float angleCos = dot( directLight.direction, spotLight.direction );\n\n  if ( angleCos > spotLight.coneCos ) {\n\n   float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n   directLight.color = spotLight.color;\n   directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n   directLight.visible = true;\n\n  } else {\n\n   directLight.color = vec3( 0.0 );\n   directLight.visible = false;\n\n  }\n }\n\n#endif\n\n\n#if defined(NUM_RECT_AREA_LIGHTS) && NUM_RECT_AREA_LIGHTS > 0\n\n struct RectAreaLight {\n  vec3 color;\n  vec3 position;\n  vec3 halfWidth;\n  vec3 halfHeight;\n };\n\n // Pre-computed values of LinearTransformedCosine approximation of BRDF\n // BRDF approximation Texture is 64x64\n uniform sampler2D ltc_1; // RGBA Float\n uniform sampler2D ltc_2; // RGBA Float\n\n uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if defined(NUM_HEMI_LIGHTS) && NUM_HEMI_LIGHTS > 0\n\n struct HemisphereLight {\n  vec3 direction;\n  vec3 skyColor;\n  vec3 groundColor;\n };\n\n uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n  float dotNL = dot( geometry.normal, hemiLight.direction );\n  float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n  vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n   irradiance *= PI;\n\n  #endif\n\n  return irradiance;\n\n }\n\n#endif\n";
        ShaderChunk.lights_pars_maps = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n  vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n   // TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n   // of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n   #else\n\n    // force the bias high to get the last LOD level as it is the most blurred.\n    vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n   vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\n  #else\n\n   vec4 envMapColor = vec4( 0.0 );\n\n  #endif\n\n  return PI * envMapColor.rgb * envMapIntensity;\n\n }\n\n // taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n  //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  float maxMIPLevelScalar = float( maxMIPLevel );\n  float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  // clamp to allowable LOD ranges.\n  return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n }\n\n vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n  #else\n\n   vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n  #endif\n\n  reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n  float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n   vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\n  #elif defined( ENVMAP_TYPE_EQUIREC )\n\n   vec2 sampleUV;\n   sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n   sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_SPHERE )\n\n   vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #endif\n\n  return envMapColor.rgb * envMapIntensity;\n\n }\n\n#endif\n";
        ShaderChunk.lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
        ShaderChunk.lights_phong_pars_fragment = "varying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n varying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n vec3 diffuseColor;\n vec3 specularColor;\n float specularShininess;\n float specularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n #ifdef TOON\n\n  vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n #else\n\n  float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n  vec3 irradiance = dotNL * directLight.color;\n\n #endif\n\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n  irradiance *= PI; // punctual light\n\n #endif\n\n reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct    RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse  RE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material ) (0)\n";
        ShaderChunk.lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n material.clearCoat = saturate( clearCoat ); // Burley clearcoat model\n material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
        ShaderChunk.lights_physical_pars_fragment = "struct PhysicalMaterial {\n\n vec3 diffuseColor;\n float specularRoughness;\n vec3 specularColor;\n\n #ifndef STANDARD\n  float clearCoat;\n  float clearCoatRoughness;\n #endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n  vec3 normal = geometry.normal;\n  vec3 viewDir = geometry.viewDir;\n  vec3 position = geometry.position;\n  vec3 lightPos = rectAreaLight.position;\n  vec3 halfWidth = rectAreaLight.halfWidth;\n  vec3 halfHeight = rectAreaLight.halfHeight;\n  vec3 lightColor = rectAreaLight.color;\n  float roughness = material.specularRoughness;\n\n  vec3 rectCoords[ 4 ];\n  rectCoords[ 0 ] = lightPos - halfWidth - halfHeight; // counterclockwise\n  rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n  rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n  rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\n  vec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n  vec4 t1 = texture2D( ltc_1, uv );\n  vec4 t2 = texture2D( ltc_2, uv );\n\n  mat3 mInv = mat3(\n   vec3( t1.x, 0, t1.y ),\n   vec3(    0, 1,    0 ),\n   vec3( t1.z, 0, t1.w )\n  );\n\n  // LTC Fresnel Approximation by Stephen Hill\n  // http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n  vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n  reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n  reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n }\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n vec3 irradiance = dotNL * directLight.color;\n\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n  irradiance *= PI; // punctual light\n\n #endif\n\n #ifndef STANDARD\n  float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n #else\n  float clearCoatDHR = 0.0;\n #endif\n\n reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\n reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n #ifndef STANDARD\n\n  reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n #endif\n\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n #ifndef STANDARD\n  float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n  float dotNL = dotNV;\n  float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n #else\n  float clearCoatDHR = 0.0;\n #endif\n\n reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n #ifndef STANDARD\n\n  reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n #endif\n\n}\n\n#define RE_Direct    RE_Direct_Physical\n#define RE_Direct_RectArea  RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse  RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular  RE_IndirectSpecular_Physical\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n";
        ShaderChunk.logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif";
        ShaderChunk.logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n uniform float logDepthBufFC;\n varying float vFragDepth;\n\n#endif\n";
        ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n  varying float vFragDepth;\n\n #else\n\n  uniform float logDepthBufFC;\n\n #endif\n\n#endif\n";
        ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n  vFragDepth = 1.0 + gl_Position.w;\n\n #else\n\n  gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n  gl_Position.z *= gl_Position.w;\n\n #endif\n\n#endif\n";
        ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n vec4 texelColor = texture2D( map, vUv );\n\n // texelColor = mapTexelToLinear( texelColor );TODO\n diffuseColor *= texelColor;\n\n#endif\n";
        ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n\n uniform sampler2D map;\n\n#endif\n";
        ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n vec4 mapTexel = texture2D( map, uv );\n diffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n";
        ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n uniform mat3 uvTransform;\n uniform sampler2D map;\n\n#endif\n";
        ShaderChunk.metalnessmap_fragment = "float metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n vec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n // reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n metalnessFactor *= texelMetalness.b;\n\n#endif\n";
        ShaderChunk.metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\n uniform sampler2D metalnessMap;\n\n#endif";
        ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";
        ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n #ifndef USE_MORPHNORMALS\n\n uniform float morphTargetInfluences[ 8 ];\n\n #else\n\n uniform float morphTargetInfluences[ 4 ];\n\n #endif\n\n#endif";
        ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n #ifndef USE_MORPHNORMALS\n\n transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n #endif\n\n#endif\n";
        ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n uniform sampler2D normalMap;\n uniform vec2 normalScale;\n\n #ifdef OBJECTSPACE_NORMALMAP\n\n  uniform mat3 normalMatrix;\n\n #else\n\n  // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n  vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n   // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n   vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n   vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n   vec2 st0 = dFdx( vUv.st );\n   vec2 st1 = dFdy( vUv.st );\n\n   float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n   vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n   vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n   vec3 N = normalize( surf_norm );\n   mat3 tsn = mat3( S, T, N );\n\n   vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\n   mapN.xy *= normalScale;\n   mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n   return normalize( tsn * mapN );\n\n  }\n\n #endif\n\n#endif\n";
        ShaderChunk.normal_fragment_begin = "#ifdef FLAT_SHADED\n\n // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n vec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n vec3 normal = normalize( vNormal );\n\n #ifdef DOUBLE_SIDED\n\n  normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n #endif\n\n#endif\n";
        ShaderChunk.normal_fragment_maps = "#ifdef USE_NORMALMAP\n\n #ifdef OBJECTSPACE_NORMALMAP\n\n  normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n  #ifdef FLIP_SIDED\n\n   normal = - normal;\n\n  #endif\n\n  #ifdef DOUBLE_SIDED\n\n   normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n  #endif\n\n  normal = normalize( normalMatrix * normal );\n\n #else // tangent-space normal map\n\n  normal = perturbNormal2Arb( -vViewPosition, normal );\n\n #endif\n\n#elif defined( USE_BUMPMAP )\n\n normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n";
        ShaderChunk.packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n return normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n return 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n vec4 r = vec4( fract( v * PackFactors ), v );\n r.yzw -= r.xyz * ShiftRight8; // tidy overflow\n return r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n return dot( v, UnpackFactors );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n return linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
        ShaderChunk.particle_affector = "vec3 lifeVelocity = computeVelocity(t);\nvec4 worldRotation;\nif(u_simulationSpace==1)\n worldRotation=startWorldRotation;\nelse\n worldRotation=u_worldRotation;\nvec3 gravity=u_gravity*age;\n\nvec3 center=computePosition(startVelocity, lifeVelocity, age, t,gravity,worldRotation); \n#ifdef SPHERHBILLBOARD\n   vec2 corner=corner.xy;\n      vec3 cameraUpVector =normalize(cameraUp);\n      vec3 sideVector = normalize(cross(cameraForward,cameraUpVector));\n      vec3 upVector = normalize(cross(sideVector,cameraForward));\n     corner*=computeBillbardSize(startSize.xy,t);\n  #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n   if(u_startRotation3D){\n    vec3 rotation=vec3(startRotation.xy,computeRotation(startRotation.z,age,t));\n    center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,rotation);\n   }\n   else{\n    float rot = computeRotation(startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n    center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n   }\n  #else\n   if(u_startRotation3D){\n    center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,startRotation);\n   }\n   else{\n    float c = cos(startRotation.x);\n    float s = sin(startRotation.x);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n    center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n   }\n  #endif\n #endif\n #ifdef STRETCHEDBILLBOARD\n  vec2 corner=corner.xy;\n  vec3 velocity;\n  #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n      if(u_spaceType==0)\n       velocity=rotation_quaternions(u_sizeScale*(startVelocity+lifeVelocity),worldRotation)+gravity;\n      else\n       velocity=rotation_quaternions(u_sizeScale*startVelocity,worldRotation)+lifeVelocity+gravity;\n   #else\n      velocity= rotation_quaternions(u_sizeScale*startVelocity,worldRotation)+gravity;\n   #endif \n  vec3 cameraUpVector = normalize(velocity);\n  vec3 direction = normalize(center-cameraPosition);\n    vec3 sideVector = normalize(cross(direction,normalize(velocity)));\n  sideVector=u_sizeScale.xzy*sideVector;\n  cameraUpVector=length(vec3(u_sizeScale.x,0.0,0.0))*cameraUpVector;\n    vec2 size=computeBillbardSize(startSize.xy,t);\n    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n    corner=rotaionZHalfPI*corner;\n    corner.y=corner.y-abs(corner.y);\n    float speed=length(velocity);\n    center +=sign(u_sizeScale.x)*(sign(u_lengthScale)*size.x*corner.x*sideVector+(speed*u_speeaScale+size.y*u_lengthScale)*corner.y*cameraUpVector);\n #endif\n #ifdef HORIZONTALBILLBOARD\n  vec2 corner=corner.xy;\n    const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\n    const vec3 sideVector = vec3(-1.0,0.0,0.0);\n  float rot = computeRotation(startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n  corner*=computeBillbardSize(startSize.xy,t);\n    center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n #endif\n #ifdef VERTICALBILLBOARD\n  vec2 corner=corner.xy;\n    const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n    vec3 sideVector = normalize(cross(cameraForward,cameraUpVector));\n  float rot = computeRotation(startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n  corner*=computeBillbardSize(startSize.xy,t);\n    center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n #endif\n #ifdef RENDERMESH\n    vec3 size=computeMeshSize(startSize,t);\n  #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n    if(u_startRotation3D){\n     vec3 rotation=vec3(startRotation.xy,-computeRotation(startRotation.z, age,t));\n     center+= rotation_quaternions(u_sizeScale*rotation_euler(position*size,rotation),worldRotation);\n    }\n    else{\n     #ifdef ROTATIONOVERLIFETIME\n      float angle=computeRotation(startRotation.x, age,t);\n      if(startPosition.x>0.1 || startPosition.x < -0.1||startPosition.y>0.1 || startPosition.y < -0.1){\n       center+= (rotation_quaternions(rotation_axis(u_sizeScale*position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),angle),worldRotation));//已验证\n      }\n      else{\n       #ifdef SHAPE\n        center+= u_sizeScale.xzy*(rotation_quaternions(rotation_axis(position*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\n       #else\n        if(u_simulationSpace==1)\n         center+=rotation_axis(u_sizeScale*position*size,vec3(0.0,0.0,-1.0),angle);\n        else if(u_simulationSpace==0)\n         center+=rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,0.0,-1.0),angle),worldRotation);\n       #endif\n      }\n     #endif\n     #ifdef ROTATIONSEPERATE\n      vec3 angle=compute3DRotation(vec3(0.0,0.0,startRotation.z), age,t);\n      center+= (rotation_quaternions(rotation_euler(u_sizeScale*position*size,vec3(angle.x,angle.y,angle.z)),worldRotation));\n     #endif \n    }\n  #else\n  if(u_startRotation3D){\n   center+= rotation_quaternions(u_sizeScale*rotation_euler(position*size,startRotation),worldRotation);\n  }\n  else{\n   if(startPosition.x>0.1 || startPosition.x < -0.1||startPosition.y>0.1 || startPosition.y < -0.1){\n    if(u_simulationSpace==1)\n     center+= rotation_axis(u_sizeScale*position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),startRotation.x);\n    else if(u_simulationSpace==0)\n     center+= (rotation_quaternions(u_sizeScale*rotation_axis(position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),startRotation.x),worldRotation));\n   }\n   else{\n    #ifdef SHAPE\n     if(u_simulationSpace==1)\n      center+= u_sizeScale*rotation_axis(position*size,vec3(0.0,-1.0,0.0),startRotation.x);\n     else if(u_simulationSpace==0)\n      center+= rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,-1.0,0.0),startRotation.x),worldRotation); \n    #else\n     if(u_simulationSpace==1)\n      center+= rotation_axis(u_sizeScale*position*size,vec3(0.0,0.0,-1.0),startRotation.x);\n     else if(u_simulationSpace==0)\n      center+= rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,0.0,-1.0),startRotation.x),worldRotation);\n    #endif\n   }\n  }\n  #endif\n  v_mesh_color=vec4(color, 1.0);\n  #endif";
        ShaderChunk.particle_common = "\n\nuniform float u_currentTime;\nuniform vec3 u_gravity;\n\nuniform vec3 u_worldPosition;\nuniform vec4 u_worldRotation;\nuniform bool u_startRotation3D;\nuniform int u_scalingMode;\nuniform vec3 u_positionScale;\nuniform vec3 u_sizeScale;\nuniform mat4 viewProjectionMatrix;\n\nuniform vec3 cameraForward;\nuniform vec3 cameraUp;\n\nuniform float u_lengthScale;\nuniform float u_speeaScale;\nuniform int u_simulationSpace;\n\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n  uniform int u_spaceType;\n#endif\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYTWOCONSTANT)\n  uniform vec3 u_velocityConst;\n#endif\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)\n  uniform vec2 u_velocityCurveX[4];\n  uniform vec2 u_velocityCurveY[4];\n  uniform vec2 u_velocityCurveZ[4];\n#endif\n#ifdef VELOCITYTWOCONSTANT\n  uniform vec3 u_velocityConstMax;\n#endif\n#ifdef VELOCITYTWOCURVE\n  uniform vec2 u_velocityCurveMaxX[4];\n  uniform vec2 u_velocityCurveMaxY[4];\n  uniform vec2 u_velocityCurveMaxZ[4];\n#endif\n\n#ifdef COLOROGRADIENT\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n#endif\n#ifdef COLORTWOGRADIENTS\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n  uniform vec4 u_colorGradientMax[4];\n  uniform vec2 u_alphaGradientMax[4];\n#endif\n\n#if defined(SIZECURVE)||defined(SIZETWOCURVES)\n  uniform vec2 u_sizeCurve[4];\n#endif\n#ifdef SIZETWOCURVES\n  uniform vec2 u_sizeCurveMax[4];\n#endif\n#if defined(SIZECURVESEPERATE)||defined(SIZETWOCURVESSEPERATE)\n  uniform vec2 u_sizeCurveX[4];\n  uniform vec2 u_sizeCurveY[4];\n  uniform vec2 u_sizeCurveZ[4];\n#endif\n#ifdef SIZETWOCURVESSEPERATE\n  uniform vec2 u_sizeCurveMaxX[4];\n  uniform vec2 u_sizeCurveMaxY[4];\n  uniform vec2 u_sizeCurveMaxZ[4];\n#endif\n\n#ifdef ROTATIONOVERLIFETIME\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform float u_rotationConst;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform float u_rotationConstMax;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurve[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMax[4];\n  #endif\n#endif\n#ifdef ROTATIONSEPERATE\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform vec3 u_rotationConstSeprarate;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform vec3 u_rotationConstMaxSeprarate;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurveX[4];\n    uniform vec2 u_rotationCurveY[4];\n    uniform vec2 u_rotationCurveZ[4];\n  uniform vec2 u_rotationCurveW[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMaxX[4];\n    uniform vec2 u_rotationCurveMaxY[4];\n    uniform vec2 u_rotationCurveMaxZ[4];\n  uniform vec2 u_rotationCurveMaxW[4];\n  #endif\n#endif\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\n  uniform float u_cycles;\n  uniform vec4 u_subUV;\n  uniform vec2 u_uvCurve[4];\n#endif\n#ifdef TEXTURESHEETANIMATIONTWOCURVE\n  uniform vec2 u_uvCurveMax[4];\n#endif\n\nvarying float v_discard;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\n#ifdef RENDERMESH\n varying vec4 v_mesh_color;\n#endif\n\nvec3 rotation_euler(in vec3 vector,in vec3 euler)\n{\n  float halfPitch = euler.x * 0.5;\n float halfYaw = euler.y * 0.5;\n float halfRoll = euler.z * 0.5;\n\n float sinPitch = sin(halfPitch);\n float cosPitch = cos(halfPitch);\n float sinYaw = sin(halfYaw);\n float cosYaw = cos(halfYaw);\n float sinRoll = sin(halfRoll);\n float cosRoll = cos(halfRoll);\n\n float quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n float quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n float quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n float quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n \n float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n float xx = quaX * x;\n  float xy = quaX * y;\n float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n \n}\n\nvec3 rotation_axis(in vec3 vector,in vec3 axis, in float angle)\n{\n float halfAngle = angle * 0.5;\n float sin = sin(halfAngle);\n \n float quaX = axis.x * sin;\n float quaY = axis.y * sin;\n float quaZ = axis.z * sin;\n float quaW = cos(halfAngle);\n \n float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n float xx = quaX * x;\n  float xy = quaX * y;\n float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n}\n\nvec3 rotation_quaternions(in vec3 v,in vec4 q) \n{\n return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(SIZECURVE)||defined(SIZECURVESEPERATE)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)\nfloat evaluate_curve_float(in vec2 curves[4],in float t)\n{\n float res;\n for(int i=1;i<4;i++)\n {\n  vec2 curve=curves[i];\n  float curTime=curve.x;\n  if(curTime>=t)\n  {\n   vec2 lastCurve=curves[i-1];\n   float lastTime=lastCurve.x;\n   float tt=(t-lastTime)/(curTime-lastTime);\n   res=mix(lastCurve.y,curve.y,tt);\n   break;\n  }\n }\n return res;\n}\n#endif\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\nfloat evaluate_curve_total(in vec2 curves[4],in float t)\n{\n float res=0.0;\n for(int i=1;i<4;i++)\n {\n  vec2 curve=curves[i];\n  float curTime=curve.x;\n  vec2 lastCurve=curves[i-1];\n  float lastValue=lastCurve.y;\n  \n  if(curTime>=t){\n   float lastTime=lastCurve.x;\n   float tt=(t-lastTime)/(curTime-lastTime);\n   res+=(lastValue+mix(lastValue,curve.y,tt))/2.0*time.x*(t-lastTime);\n   break;\n  }\n  else{\n   res+=(lastValue+curve.y)/2.0*time.x*(curTime-lastCurve.x);\n  }\n }\n return res;\n}\n#endif\n\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)\nvec4 evaluate_curve_color(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float t)\n{\n vec4 overTimeColor;\n for(int i=1;i<4;i++)\n {\n  vec2 gradientAlpha=gradientAlphas[i];\n  float alphaKey=gradientAlpha.x;\n  if(alphaKey>=t)\n  {\n   vec2 lastGradientAlpha=gradientAlphas[i-1];\n   float lastAlphaKey=lastGradientAlpha.x;\n   float age=(t-lastAlphaKey)/(alphaKey-lastAlphaKey);\n   overTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n   break;\n  }\n }\n \n for(int i=1;i<4;i++)\n {\n  vec4 gradientColor=gradientColors[i];\n  float colorKey=gradientColor.x;\n  if(colorKey>=t)\n  {\n   vec4 lastGradientColor=gradientColors[i-1];\n   float lastColorKey=lastGradientColor.x;\n   float age=(t-lastColorKey)/(colorKey-lastColorKey);\n   overTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n   break;\n  }\n }\n return overTimeColor;\n}\n#endif\n\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\nfloat evaluate_curve_frame(in vec2 gradientFrames[4],in float t)\n{\n float overTimeFrame;\n for(int i=1;i<4;i++)\n {\n  vec2 gradientFrame=gradientFrames[i];\n  float key=gradientFrame.x;\n  if(key>=t)\n  {\n   vec2 lastGradientFrame=gradientFrames[i-1];\n   float lastKey=lastGradientFrame.x;\n   float age=(t-lastKey)/(key-lastKey);\n   overTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n   break;\n  }\n }\n return floor(overTimeFrame);\n}\n#endif\n\nvec3 computeVelocity(in float t)\n{\n  vec3 res;\n  #ifdef VELOCITYCONSTANT\n  res=u_velocityConst; \n  #endif\n  #ifdef VELOCITYCURVE\n     res= vec3(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveZ,t));\n  #endif\n  #ifdef VELOCITYTWOCONSTANT\n  res=mix(u_velocityConst,u_velocityConstMax,vec3(random1.y,random1.z,random1.w)); \n  #endif\n  #ifdef VELOCITYTWOCURVE\n     res=vec3(mix(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveMaxX,t),random1.y),\n             mix(evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveMaxY,t),random1.z),\n        mix(evaluate_curve_float(u_velocityCurveZ,t),evaluate_curve_float(u_velocityCurveMaxZ,t),random1.w));\n  #endif\n     \n  return res;\n} \n\nvec3 computePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float t,vec3 gravityVelocity,vec4 worldRotation)\n{\n    vec3 startPosition;\n    vec3 lifePosition;\n  #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n   #ifdef VELOCITYCONSTANT\n      startPosition=startVelocity*age;\n      lifePosition=lifeVelocity*age;\n   #endif\n   #ifdef VELOCITYCURVE\n      startPosition=startVelocity*age;\n      lifePosition=vec3(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveZ,t));\n   #endif\n   #ifdef VELOCITYTWOCONSTANT\n      startPosition=startVelocity*age;\n      lifePosition=lifeVelocity*age;\n   #endif\n   #ifdef VELOCITYTWOCURVE\n      startPosition=startVelocity*age;\n      lifePosition=vec3(mix(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveMaxX,t),random1.y)\n                 ,mix(evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveMaxY,t),random1.z)\n                 ,mix(evaluate_curve_total(u_velocityCurveZ,t),evaluate_curve_total(u_velocityCurveMaxZ,t),random1.w));\n   #endif\n\n   vec3 finalPosition;\n   if(u_spaceType==0){\n     if(u_scalingMode!=2)\n      finalPosition =rotation_quaternions(u_positionScale*(startPosition.xyz+startPosition+lifePosition),worldRotation);\n     else\n      finalPosition =rotation_quaternions(u_positionScale*startPosition.xyz+startPosition+lifePosition,worldRotation);\n   }\n   else{\n     if(u_scalingMode!=2)\n       finalPosition = rotation_quaternions(u_positionScale*(startPosition.xyz+startPosition),worldRotation)+lifePosition;\n     else\n       finalPosition = rotation_quaternions(u_positionScale*startPosition.xyz+startPosition,worldRotation)+lifePosition;\n   }\n    #else\n    startPosition=startVelocity*age;\n    vec3 finalPosition;\n    if(u_scalingMode!=2)\n      finalPosition = rotation_quaternions(u_positionScale*(startPosition.xyz+startPosition),worldRotation);\n    else\n      finalPosition = rotation_quaternions(u_positionScale*startPosition.xyz+startPosition,worldRotation);\n  #endif\n  \n  if(u_simulationSpace==1)\n    finalPosition=finalPosition+startWorldPosition;\n  else if(u_simulationSpace==0) \n    finalPosition=finalPosition+u_worldPosition;\n  \n  finalPosition+=0.5*gravityVelocity*age;\n \n  return finalPosition;\n}\n\n\nvec4 computeColor(in vec4 color,in float t)\n{\n #ifdef COLOROGRADIENT\n   color*=evaluate_curve_color(u_alphaGradient,u_colorGradient,t);\n #endif \n #ifdef COLORTWOGRADIENTS\n   color*=mix(evaluate_curve_color(u_alphaGradient,u_colorGradient,t),evaluate_curve_color(u_alphaGradientMax,u_colorGradientMax,t),random0.y);\n #endif\n\n  return color;\n}\n\nvec2 computeBillbardSize(in vec2 size,in float t)\n{\n #ifdef SIZECURVE\n  size*=evaluate_curve_float(u_sizeCurve,t);\n #endif\n #ifdef SIZETWOCURVES\n   size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),random0.z); \n #endif\n #ifdef SIZECURVESEPERATE\n  size*=vec2(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t));\n #endif\n #ifdef SIZETWOCURVESSEPERATE\n   size*=vec2(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),random0.z)\n         ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),random0.z));\n #endif\n return size;\n}\n\n#ifdef RENDERMESH\nvec3 computeMeshSize(in vec3 size,in float t)\n{\n #ifdef SIZECURVE\n  size*=evaluate_curve_float(u_sizeCurve,t);\n #endif\n #ifdef SIZETWOCURVES\n   size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),random0.z); \n #endif\n #ifdef SIZECURVESEPERATE\n  size*=vec3(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveZ,t));\n #endif\n #ifdef SIZETWOCURVESSEPERATE\n   size*=vec3(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),random0.z)\n         ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),random0.z)\n       ,mix(evaluate_curve_float(u_sizeCurveZ,t),evaluate_curve_float(u_sizeCurveMaxZ,t),random0.z));\n #endif\n return size;\n}\n#endif\n\nfloat computeRotation(in float rotation,in float age,in float t)\n{ \n #ifdef ROTATIONOVERLIFETIME\n  #ifdef ROTATIONCONSTANT\n   float ageRot=u_rotationConst*age;\n         rotation+=ageRot;\n  #endif\n  #ifdef ROTATIONCURVE\n   rotation+=evaluate_curve_total(u_rotationCurve,t);\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n   float ageRot=mix(u_rotationConst,u_rotationConstMax,random0.w)*age;\n     rotation+=ageRot;\n   #endif\n  #ifdef ROTATIONTWOCURVES\n   rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),random0.w);\n  #endif\n #endif\n #ifdef ROTATIONSEPERATE\n  #ifdef ROTATIONCONSTANT\n   float ageRot=u_rotationConstSeprarate.z*age;\n         rotation+=ageRot;\n  #endif\n  #ifdef ROTATIONCURVE\n   rotation+=evaluate_curve_total(u_rotationCurveZ,t);\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n   float ageRot=mix(u_rotationConstSeprarate.z,u_rotationConstMaxSeprarate.z,random0.w)*age;\n         rotation+=ageRot;\n     #endif\n  #ifdef ROTATIONTWOCURVES\n   rotation+=mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),random0.w));\n  #endif\n #endif\n return rotation;\n}\n\n#if defined(RENDERMESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE))\nvec3 compute3DRotation(in vec3 rotation,in float age,in float t)\n{ \n #ifdef ROTATIONOVERLIFETIME\n   #ifdef ROTATIONCONSTANT\n     float ageRot=u_rotationConst*age;\n       rotation+=ageRot;\n   #endif\n   #ifdef ROTATIONCURVE\n     rotation+=evaluate_curve_total(u_rotationCurve,t);\n   #endif\n   #ifdef ROTATIONTWOCONSTANTS\n     float ageRot=mix(u_rotationConst,u_rotationConstMax,random0.w)*age;\n       rotation+=ageRot;\n   #endif\n   #ifdef ROTATIONTWOCURVES\n     rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),random0.w);\n   #endif\n #endif\n #ifdef ROTATIONSEPERATE\n    #ifdef ROTATIONCONSTANT\n     vec3 ageRot=u_rotationConstSeprarate*age;\n           rotation+=ageRot;\n    #endif\n    #ifdef ROTATIONCURVE\n     rotation+=vec3(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveZ,t));\n    #endif\n    #ifdef ROTATIONTWOCONSTANTS\n     vec3 ageRot=mix(u_rotationConstSeprarate,u_rotationConstMaxSeprarate,random0.w)*age;\n           rotation+=ageRot;\n     #endif\n    #ifdef ROTATIONTWOCURVES\n     rotation+=vec3(mix(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveMaxX,t),random0.w)\n           ,mix(evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveMaxY,t),random0.w)\n           ,mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),random0.w));\n    #endif\n #endif\n return rotation;\n}\n#endif\n\nvec2 computeUV(in vec2 uv,in float t)\n{ \n #ifdef TEXTURESHEETANIMATIONCURVE\n  float cycleNormalizedAge=t*u_cycles;\n  float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n  float frame=evaluate_curve_frame(u_uvCurve,uvNormalizedAge);\n  uv.x *= u_subUV.x + u_subUV.z;\n  uv.y *= u_subUV.y + u_subUV.w;\n  float totalULength=frame*u_subUV.x;\n  float floorTotalULength=floor(totalULength);\n   uv.x+=totalULength-floorTotalULength;\n  uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n #ifdef TEXTURESHEETANIMATIONTWOCURVE\n  float cycleNormalizedAge=t*u_cycles;\n  float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n   float frame=floor(mix(evaluate_curve_frame(u_uvCurve,uvNormalizedAge),evaluate_curve_frame(u_uvCurveMax,uvNormalizedAge),random1.x));\n  uv.x *= u_subUV.x + u_subUV.z;\n  uv.y *= u_subUV.y + u_subUV.w;\n  float totalULength=frame*u_subUV.x;\n  float floorTotalULength=floor(totalULength);\n   uv.x+=totalULength-floorTotalULength;\n  uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n return uv;\n}";
        ShaderChunk.premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\n // Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n gl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n";
        ShaderChunk.project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\ngl_Position = projectionMatrix * mvPosition;\n";
        ShaderChunk.roughnessmap_fragment = "float roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n vec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n roughnessFactor *= texelRoughness.g;\n\n#endif\n";
        ShaderChunk.roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\n uniform sampler2D roughnessMap;\n\n#endif";
        ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n  uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n  varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n  uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n  varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n  uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n  varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): create uniforms for area light shadows\n\n #endif\n */\n\n float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n  return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n }\n\n float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\n  const vec2 offset = vec2( 0.0, 1.0 );\n\n  vec2 texelSize = vec2( 1.0 ) / size;\n  vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\n  float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n  float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n  float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n  float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\n  vec2 f = fract( uv * size + 0.5 );\n\n  float a = mix( lb, lt, f.y );\n  float b = mix( rb, rt, f.y );\n  float c = mix( a, b, f.x );\n\n  return c;\n\n }\n\n float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n  float shadow = 1.0;\n\n  shadowCoord.xyz /= shadowCoord.w;\n  shadowCoord.z += shadowBias;//Egret Right-hand\n\n  // if ( something && something ) breaks ATI OpenGL shader compiler\n  // if ( all( something, something ) ) using this instead\n\n  bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n  bool inFrustum = all( inFrustumVec );\n\n  bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n  bool frustumTest = all( frustumTestVec );\n\n  if ( frustumTest ) {\n\n  #if defined( SHADOWMAP_TYPE_PCF )\n\n   vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n   float dx0 = - texelSize.x * shadowRadius;\n   float dy0 = - texelSize.y * shadowRadius;\n   float dx1 = + texelSize.x * shadowRadius;\n   float dy1 = + texelSize.y * shadowRadius;\n\n   shadow = (\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n   ) * ( 1.0 / 9.0 );\n\n  #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n   vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n   float dx0 = - texelSize.x * shadowRadius;\n   float dy0 = - texelSize.y * shadowRadius;\n   float dx1 = + texelSize.x * shadowRadius;\n   float dy1 = + texelSize.y * shadowRadius;\n\n   shadow = (\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n   ) * ( 1.0 / 9.0 );\n\n  #else // no percentage-closer filtering:\n\n   shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n  #endif\n\n  }\n\n  return shadow;\n\n }\n\n // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n // vector suitable for 2D texture mapping. This code uses the following layout for the\n // 2D texture:\n //\n // xzXZ\n //  y Y\n //\n // Y - Positive y direction\n // y - Negative y direction\n // X - Positive x direction\n // x - Negative x direction\n // Z - Positive z direction\n // z - Negative z direction\n //\n // Source and test bed:\n // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n  // Number of texels to avoid at the edge of each square\n\n  vec3 absV = abs( v );\n\n  // Intersect unit cube\n\n  float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n  absV *= scaleToCube;\n\n  // Apply scale to avoid seams\n\n  // two texels less per square (one texel will do for NEAREST)\n  v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n  // Unwrap\n\n  // space: -1 ... 1 range for each square\n  //\n  // #X##  dim    := ( 4 , 2 )\n  //  # #  center := ( 1 , 1 )\n\n  vec2 planar = v.xy;\n\n  float almostATexel = 1.5 * texelSizeY;\n  float almostOne = 1.0 - almostATexel;\n\n  if ( absV.z >= almostOne ) {\n\n   if ( v.z > 0.0 )\n    planar.x = 4.0 - v.x;\n\n  } else if ( absV.x >= almostOne ) {\n\n   float signX = sign( v.x );\n   planar.x = v.z * signX + 2.0 * signX;\n\n  } else if ( absV.y >= almostOne ) {\n\n   float signY = sign( v.y );\n   planar.x = v.x + 2.0 * signY + 2.0;\n   planar.y = v.z * signY - 2.0;\n\n  }\n\n  // Transform to UV space\n\n  // scale := 0.5 / dim\n  // translate := ( center + 0.5 ) / dim\n  return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n }\n\n float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n  vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n  // for point lights, the uniform @vShadowCoord is re-purposed to hold\n  // the vector from the light to the world-space position of the fragment.\n  vec3 lightToPosition = shadowCoord.xyz;\n\n  // dp = normalized distance from light to fragment position\n  float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n  dp += shadowBias;\n\n  // bd3D = base direction 3D\n  vec3 bd3D = normalize( lightToPosition );\n\n  #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n   vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n   return (\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n   ) * ( 1.0 / 9.0 );\n\n  #else // no percentage-closer filtering\n\n   return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n  #endif\n\n }\n\n#endif\n";
        ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n  uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n  varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n  uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n  varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n  uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n  varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): uniforms for area light shadows\n\n #endif\n */\n\n#endif\n";
        ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n }\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n  vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n }\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n }\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): update vAreaShadowCoord with area light info\n\n #endif\n */\n\n#endif\n";
        ShaderChunk.shadowmask_pars_fragment = "float getShadowMask() {\n\n float shadow = 1.0;\n\n #ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n DirectionalLight directionalLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  // directionalLight = directionalLights[ i ];\n  directionalLight.shadow = int(directionalLights[i * 12 + 6]);\n  directionalLight.shadowBias = directionalLights[i * 12 + 7];\n  directionalLight.shadowRadius = directionalLights[i * 12 + 8];\n  directionalLight.shadowMapSize = vec2(directionalLights[i * 12 + 9], directionalLights[i * 12 + 10]);\n  shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n }\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n SpotLight spotLight;\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n  // spotLight = spotLights[ i ];\n  spotLight.shadow = int(spotLights[i * 18 + 13]);\n  spotLight.shadowBias = spotLights[i * 18 + 14];\n  spotLight.shadowRadius = spotLights[i * 18 + 15];\n  spotLight.shadowMapSize = vec2(spotLights[i * 18 + 16], spotLights[i * 18 + 17]);\n  shadow *= bool(spotLight.shadow) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n }\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n PointLight pointLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  // pointLight = pointLights[ i ];\n  pointLight.shadow = int(pointLights[i * 15 + 8]);\n  pointLight.shadowBias = pointLights[i * 15 * 9];\n  pointLight.shadowRadius = pointLights[i * 15 * 10];\n  pointLight.shadowMapSize = vec2(pointLights[i * 15 * 11],pointLights[i * 15 * 12]);\n  pointLight.shadowCameraNear = pointLights[i * 15 * 13];\n  pointLight.shadowCameraFar = pointLights[i * 15 * 14];\n  shadow *= bool(pointLight.shadow) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n }\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): update shadow for Area light\n\n #endif\n */\n\n #endif\n\n return shadow;\n\n}\n";
        ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n mat4 boneMatX = getBoneMatrix( skinIndex.x );\n mat4 boneMatY = getBoneMatrix( skinIndex.y );\n mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
        ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n // Modify egret.\n // uniform_mat4 bindMatrix;\n // uniform_mat4 bindMatrixInverse;\n\n #ifdef BONE_TEXTURE\n\n  uniform sampler2D boneTexture;\n  uniform int boneTextureSize;\n\n  mat4 getBoneMatrix( const in float i ) {\n\n   float j = i * 4.0;\n   float x = mod( j, float( boneTextureSize ) );\n   float y = floor( j / float( boneTextureSize ) );\n\n   float dx = 1.0 / float( boneTextureSize );\n   float dy = 1.0 / float( boneTextureSize );\n\n   y = dy * ( y + 0.5 );\n\n   vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n   vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n   vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n   vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n   mat4 bone = mat4( v1, v2, v3, v4 );\n\n   return bone;\n\n  }\n\n #else\n\n  uniform mat4 boneMatrices[ MAX_BONES ];\n\n  mat4 getBoneMatrix( const in float i ) {\n\n   mat4 bone = boneMatrices[ int(i) ];\n   return bone;\n\n  }\n\n #endif\n\n#endif\n";
        ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n // Modify Egret.\n // vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n vec4 skinVertex = vec4( transformed, 1.0 );\n\n vec4 skinned = vec4( 0.0 );\n skinned += boneMatX * skinVertex * skinWeight.x;\n skinned += boneMatY * skinVertex * skinWeight.y;\n skinned += boneMatZ * skinVertex * skinWeight.z;\n skinned += boneMatW * skinVertex * skinWeight.w;\n\n // Modify Egret.\n // transformed = ( bindMatrixInverse * skinned ).xyz;\n transformed = skinned.xyz;\n\n#endif\n";
        ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n mat4 skinMatrix = mat4( 0.0 );\n skinMatrix += skinWeight.x * boneMatX;\n skinMatrix += skinWeight.y * boneMatY;\n skinMatrix += skinWeight.z * boneMatZ;\n skinMatrix += skinWeight.w * boneMatW;\n \n // Modify egret.\n // skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\n objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";
        ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n vec4 texelSpecular = texture2D( specularMap, vUv );\n specularStrength = texelSpecular.r;\n\n#else\n\n specularStrength = 1.0;\n\n#endif";
        ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n uniform sampler2D specularMap;\n\n#endif";
        ShaderChunk.tonemapping_fragment = "#if defined( TONE_MAPPING )\n\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n";
        ShaderChunk.tonemapping_pars_fragment = "#ifndef saturate\n #define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n return toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n color *= toneMappingExposure;\n return saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n // John Hable's filmic operator from Uncharted 2 video game\n color *= toneMappingExposure;\n return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n color *= toneMappingExposure;\n color = max( vec3( 0.0 ), color - 0.004 );\n return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n";
        ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n varying vec2 vUv2;\n\n#endif";
        ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n attribute vec2 uv2;\n varying vec2 vUv2;\n\n#endif";
        ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n vUv2 = uv2;\n\n#endif";
        ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n varying vec2 vUv;\n\n#endif";
        ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n varying vec2 vUv;\n uniform mat3 uvTransform;\n\n#endif\n";
        ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n #if defined FLIP_V \n  vUv = ( uvTransform * vec3( uv.x, 1.0 - uv.y, 1 ) ).xy;//modify egret\n #else\n  vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n #endif\n#endif";
        ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n#endif\n";
    })(ShaderChunk = egret3d.ShaderChunk || (egret3d.ShaderChunk = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    function promisify(loader, resource) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var onSuccess = function () {
                var texture = loader['data'] ? loader['data'] : loader['response'];
                resolve(texture);
            };
            var onError = function () {
                var e = new RES.ResourceManagerError(1001, resource.url);
                reject(e);
            };
            loader.addEventListener(egret.Event.COMPLETE, onSuccess, _this);
            loader.addEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
        });
    }
    egret3d.BitmapDataProcessor = {
        onLoadStart: function (host, resource) {
            var _this = this;
            var loader = new egret.ImageLoader();
            loader.load(resource.root + resource.url);
            return new Promise(function (resolve, reject) {
                var onSuccess = function () {
                    var bitmapData = loader.data;
                    loader.removeEventListener(egret.Event.COMPLETE, onSuccess, _this);
                    loader.removeEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
                    resolve(bitmapData);
                };
                var onError = function () {
                    loader.removeEventListener(egret.Event.COMPLETE, onSuccess, _this);
                    loader.removeEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
                    var e = new RES.ResourceManagerError(1001, resource.url);
                    reject(e);
                };
                loader.addEventListener(egret.Event.COMPLETE, onSuccess, _this);
                loader.addEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
            });
        },
        onRemoveStart: function (host, resource) {
            return Promise.resolve();
        }
    };
    egret3d.ShaderProcessor = {
        onLoadStart: function (host, resource) {
            return __awaiter(this, void 0, void 0, function () {
                var result, shaders, _i, shaders_1, shader, source, shaderSource, glTF;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, host.load(resource, 'json')];
                        case 1:
                            result = _a.sent();
                            if (!(result.extensions.KHR_techniques_webgl.shaders && result.extensions.KHR_techniques_webgl.shaders.length === 2)) return [3 /*break*/, 6];
                            shaders = result.extensions.KHR_techniques_webgl.shaders;
                            _i = 0, shaders_1 = shaders;
                            _a.label = 2;
                        case 2:
                            if (!(_i < shaders_1.length)) return [3 /*break*/, 5];
                            shader = shaders_1[_i];
                            source = RES.host.resourceConfig["getResource"](shader.uri);
                            if (!source) return [3 /*break*/, 4];
                            return [4 /*yield*/, host.load(source)];
                        case 3:
                            shaderSource = _a.sent();
                            if (shaderSource) {
                                shader.uri = shaderSource;
                            }
                            else {
                                console.error("Load shader error.", shader.uri);
                            }
                            _a.label = 4;
                        case 4:
                            _i++;
                            return [3 /*break*/, 2];
                        case 5: return [3 /*break*/, 7];
                        case 6:
                            console.error("错误的Shader格式数据");
                            _a.label = 7;
                        case 7:
                            glTF = new egret3d.Shader(result, resource.name);
                            paper.Asset.register(glTF);
                            return [2 /*return*/, glTF];
                    }
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.TextureDescProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "json").then(function (data) {
                var name = data.name;
                var filterMode = data.filterMode;
                var format = data.format;
                var mipmap = data.mipmap;
                var wrap = data.wrap;
                var _textureFormat = 1 /* RGBA */;
                if (format == "RGB") {
                    _textureFormat = 2 /* RGB */;
                }
                else if (format == "Gray") {
                    _textureFormat = 3 /* Gray */;
                }
                var _linear = true;
                if (filterMode.indexOf("linear") < 0) {
                    _linear = false;
                }
                var _repeat = false;
                if (wrap.indexOf("Repeat") >= 0) {
                    _repeat = true;
                }
                var _premultiply = true;
                if (data["premultiply"] !== undefined) {
                    _premultiply = data["premultiply"] > 0;
                }
                var imgResource = RES.host.resourceConfig["getResource"](name);
                return host.load(imgResource, "bitmapdata").then(function (bitmapData) {
                    var texture = new egret3d.GLTexture2D(resource.name, bitmapData.source.width, bitmapData.source.height, _textureFormat);
                    texture.uploadImage(bitmapData.source, mipmap, _linear, _premultiply, _repeat);
                    paper.Asset.register(texture);
                    return texture;
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.TextureProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "bitmapdata").then(function (bitmapData) {
                var texture = new egret3d.GLTexture2D(resource.name, bitmapData.source.width, bitmapData.source.height, 1 /* RGBA */);
                texture.uploadImage(bitmapData.source, true, true, true, true);
                paper.Asset.register(texture);
                return texture;
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.MaterialProcessor = {
        onLoadStart: function (host, resource) {
            return __awaiter(this, void 0, void 0, function () {
                var result, _i, _a, mat, values, _b, _c, _d, key, value, r, texture, material;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0: return [4 /*yield*/, host.load(resource, 'json')];
                        case 1:
                            result = _e.sent();
                            if (!(result.materials && result.materials.length > 0)) return [3 /*break*/, 8];
                            _i = 0, _a = result.materials;
                            _e.label = 2;
                        case 2:
                            if (!(_i < _a.length)) return [3 /*break*/, 8];
                            mat = _a[_i];
                            values = mat.extensions.KHR_techniques_webgl.values;
                            _b = [];
                            for (_c in values)
                                _b.push(_c);
                            _d = 0;
                            _e.label = 3;
                        case 3:
                            if (!(_d < _b.length)) return [3 /*break*/, 7];
                            key = _b[_d];
                            value = values[key];
                            if (!(value && typeof value === "string")) return [3 /*break*/, 6];
                            r = RES.host.resourceConfig["getResource"](value);
                            if (!r) return [3 /*break*/, 5];
                            return [4 /*yield*/, host.load(r, "TextureDesc")];
                        case 4:
                            texture = _e.sent();
                            values[key] = texture;
                            return [3 /*break*/, 6];
                        case 5:
                            console.log("Load image error.", value);
                            values[key] = egret3d.DefaultTextures.MISSING;
                            _e.label = 6;
                        case 6:
                            _d++;
                            return [3 /*break*/, 3];
                        case 7:
                            _i++;
                            return [3 /*break*/, 2];
                        case 8:
                            material = new egret3d.Material(result, resource.name);
                            paper.Asset.register(material);
                            return [2 /*return*/, material];
                    }
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.MeshProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "bin").then(function (result) {
                var parseResult = egret3d.GLTFAsset.parseFromBinary(new Uint32Array(result));
                var glb;
                if (parseResult.config.meshes) {
                    glb = new egret3d.Mesh(parseResult.config, parseResult.buffers, resource.name);
                }
                else {
                    glb = new egret3d.GLTFAsset();
                    glb.name = resource.name;
                    glb.config = parseResult.config;
                    for (var _i = 0, _a = parseResult.buffers; _i < _a.length; _i++) {
                        var b = _a[_i];
                        glb.buffers.push(b);
                    }
                }
                paper.Asset.register(glb);
                return glb;
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.AnimationProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "bin").then(function (result) {
                var parseResult = egret3d.GLTFAsset.parseFromBinary(new Uint32Array(result));
                var animation = new egret3d.GLTFAsset();
                animation.name = resource.name;
                animation.config = parseResult.config;
                for (var _i = 0, _a = parseResult.buffers; _i < _a.length; _i++) {
                    var b = _a[_i];
                    animation.buffers.push(b);
                }
                paper.Asset.register(animation);
                return animation;
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.PrefabProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "json").then(function (data) {
                var prefab = new paper.Prefab(resource.name);
                return loadSubAssets(data, resource).then(function () {
                    prefab.$parse(data);
                    paper.Asset.register(prefab);
                    return prefab;
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    egret3d.SceneProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "json").then(function (data) {
                var rawScene = new paper.RawScene(resource.name);
                return loadSubAssets(data, resource).then(function () {
                    rawScene.$parse(data);
                    paper.Asset.register(rawScene);
                    return rawScene;
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            data.dispose();
            return Promise.resolve();
        }
    };
    function loadSubAssets(data, resource) {
        return Promise.all(data.assets.map((function (item) {
            var host = RES.host;
            var r = host.resourceConfig["getResource"](item);
            if (r) {
                return host.load(r);
            }
            else {
                if (item.indexOf("builtin/") !== 0) {
                    console.error("加载不存在的资源", item);
                }
                return Promise.resolve();
            }
        })));
    }
    RES.processor.map("Shader", egret3d.ShaderProcessor);
    RES.processor.map("Texture", egret3d.TextureProcessor);
    RES.processor.map("TextureDesc", egret3d.TextureDescProcessor);
    RES.processor.map("Material", egret3d.MaterialProcessor);
    RES.processor.map("Mesh", egret3d.MeshProcessor);
    RES.processor.map("Animation", egret3d.AnimationProcessor);
    RES.processor.map("Prefab", egret3d.PrefabProcessor);
    RES.processor.map("Scene", egret3d.SceneProcessor);
    RES.processor.map("bitmapdata", egret3d.BitmapDataProcessor);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 正则表达式的工具类，提供一些引擎用到的正则表达式
     */
    var RegexpUtil = (function () {
        function RegexpUtil() {
        }
        // shader properties
        RegexpUtil.textureRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*'(.+)'[ ]*\{[ ]*([a-zA-Z]*)[ ]*([a-zA-Z]*)[ ]*\}/;
        RegexpUtil.vectorRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        RegexpUtil.floatRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        RegexpUtil.rangeRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        // material
        RegexpUtil.vector4Regexp = /\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        // 特效解析，[1,2],2,1
        RegexpUtil.vector3FloatOrRangeRegexp = /([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\])/;
        return RegexpUtil;
    }());
    egret3d.RegexpUtil = RegexpUtil;
    __reflect(RegexpUtil.prototype, "egret3d.RegexpUtil");
})(egret3d || (egret3d = {}));
// 0.04 处理utf8 string 不能用encode decode
var egret3d;
(function (egret3d) {
    var io;
    (function (io) {
        var BinReader = (function () {
            function BinReader(buf, seek) {
                if (seek === void 0) { seek = 0; }
                this._seek = seek;
                this._data = new DataView(buf, seek);
            }
            BinReader.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinReader.prototype.peek = function () {
                return this._seek;
            };
            BinReader.prototype.length = function () {
                return this._data.byteLength;
            };
            BinReader.prototype.canread = function () {
                return this._data.byteLength - this._seek;
            };
            BinReader.prototype.readStringAnsi = function () {
                var slen = this._data.getUint8(this._seek);
                this._seek++;
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this._data.getUint8(this._seek));
                    this._seek++;
                }
                return bs;
            };
            BinReader.utf8ArrayToString = function (array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    var cc = array[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = array[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(array[i]));
                    }
                }
                return ret.join('');
            };
            BinReader.prototype.readStringUtf8 = function () {
                var length = this._data.getInt8(this._seek);
                this._seek++;
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readStringUtf8FixLength = function (length) {
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readSingle = function () {
                var num = this._data.getFloat32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readDouble = function () {
                var num = this._data.getFloat64(this._seek, true);
                this._seek += 8;
                return num;
            };
            BinReader.prototype.readInt8 = function () {
                var num = this._data.getInt8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readUInt8 = function () {
                var num = this._data.getUint8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readInt16 = function () {
                var num = this._data.getInt16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readUInt16 = function () {
                var num = this._data.getUint16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readInt32 = function () {
                var num = this._data.getInt32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUInt32 = function () {
                var num = this._data.getUint32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUint8Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(this._seek);
                    this._seek++;
                }
                return target;
            };
            BinReader.prototype.readUint8ArrayByOffset = function (target, offset, length) {
                if (length === void 0) { length = 0; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(offset);
                    offset++;
                }
                return target;
            };
            BinReader.prototype.readUint16Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this.readUInt16();
                }
                return target;
            };
            BinReader.prototype.readSingleArray = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                // console.log(this._data.byteLength, this._data.byteOffset);
                for (var i = 0; i < length; i++) {
                    // target[i] = this._data.getFloat32(this._seek, true);
                    // this._seek += 4;
                    target[i] = this.readSingle();
                }
                return target;
            };
            Object.defineProperty(BinReader.prototype, "position", {
                get: function () {
                    return this.peek();
                },
                set: function (value) {
                    this.seek(value);
                },
                enumerable: true,
                configurable: true
            });
            BinReader.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            BinReader.prototype.readByte = function () {
                return this.readUInt8();
            };
            BinReader.prototype.readBytes = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                return this.readUint8Array(target, offset, length);
            };
            BinReader.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            BinReader.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            BinReader.prototype.readFloat = function () {
                return this.readSingle();
            };
            BinReader.prototype.readUTFBytes = function (length) {
                var arry = new Uint8Array(length);
                return BinReader.utf8ArrayToString(this.readUint8Array(arry));
            };
            BinReader.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            BinReader.prototype.readShort = function () {
                return this.readInt16();
            };
            BinReader.prototype.readInt = function () {
                return this.readInt32();
            };
            return BinReader;
        }());
        io.BinReader = BinReader;
        __reflect(BinReader.prototype, "egret3d.io.BinReader");
        var BinWriter = (function () {
            function BinWriter() {
                var buf = new ArrayBuffer(1024);
                this._length = 0;
                this._buf = new Uint8Array(buf);
                this._data = new DataView(this._buf.buffer);
                this._seek = 0;
            }
            BinWriter.prototype.sureData = function (addlen) {
                var nextlen = this._buf.byteLength;
                while (nextlen < (this._length + addlen)) {
                    nextlen += 1024;
                }
                if (nextlen != this._buf.byteLength) {
                    var newbuf = new Uint8Array(nextlen);
                    for (var i = 0; i < this._length; i++) {
                        newbuf[i] = this._buf[i];
                    }
                    this._buf = newbuf;
                    this._data = new DataView(this._buf.buffer);
                }
                this._length += addlen;
            };
            BinWriter.prototype.getLength = function () {
                return length;
            };
            BinWriter.prototype.getBuffer = function () {
                return this._buf.buffer.slice(0, this._length);
            };
            BinWriter.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinWriter.prototype.peek = function () {
                return this._seek;
            };
            BinWriter.prototype.writeInt8 = function (num) {
                this.sureData(1);
                this._data.setInt8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeUInt8 = function (num) {
                this.sureData(1);
                this._data.setUint8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeInt16 = function (num) {
                this.sureData(2);
                this._data.setInt16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeUInt16 = function (num) {
                this.sureData(2);
                this._data.setUint16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeInt32 = function (num) {
                this.sureData(4);
                this._data.setInt32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeUInt32 = function (num) {
                this.sureData(4);
                this._data.setUint32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeSingle = function (num) {
                this.sureData(4);
                this._data.setFloat32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeDouble = function (num) {
                this.sureData(8);
                this._data.setFloat64(this._seek, num, true);
                this._seek += 8;
            };
            BinWriter.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.sureData(slen + 1);
                this._data.setUint8(this._seek, slen);
                this._seek++;
                for (var i = 0; i < slen; i++) {
                    this._data.setUint8(this._seek, str.charCodeAt(i));
                    this._seek++;
                }
            };
            BinWriter.prototype.writeStringUtf8 = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.writeUint8Array(bstr);
            };
            BinWriter.stringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return bstr;
            };
            BinWriter.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(bstr);
            };
            BinWriter.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                this.sureData(length);
                for (var i = offset; i < offset + length; i++) {
                    this._data.setUint8(this._seek, array[i]);
                    this._seek++;
                }
            };
            Object.defineProperty(BinWriter.prototype, "length", {
                get: function () {
                    return this._seek;
                },
                enumerable: true,
                configurable: true
            });
            BinWriter.prototype.writeByte = function (num) {
                this.writeUInt8(num);
            };
            BinWriter.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = 0; }
                this.writeUint8Array(array, offset, length);
            };
            BinWriter.prototype.writeUnsignedShort = function (num) {
                this.writeUInt16(num);
            };
            BinWriter.prototype.writeUnsignedInt = function (num) {
                this.writeUInt32(num);
            };
            BinWriter.prototype.writeFloat = function (num) {
                this.writeSingle(num);
            };
            BinWriter.prototype.writeUTFBytes = function (str) {
                var strArray = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(strArray);
            };
            BinWriter.prototype.writeSymbolByte = function (num) {
                this.writeInt8(num);
            };
            BinWriter.prototype.writeShort = function (num) {
                this.writeInt16(num);
            };
            BinWriter.prototype.writeInt = function (num) {
                this.writeInt32(num);
            };
            return BinWriter;
        }());
        io.BinWriter = BinWriter;
        __reflect(BinWriter.prototype, "egret3d.io.BinWriter");
    })(io = egret3d.io || (egret3d.io = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var utils;
    (function (utils) {
        function getRelativePath(targetPath, sourcePath) {
            var relPath = "";
            targetPath = targetPath.replace("\\", "/");
            sourcePath = sourcePath.replace("\\", "/");
            var targetPathArr = targetPath.split('/');
            var sourcePathArr = sourcePath.split('/');
            var targetPathLen = targetPathArr.length;
            var sourcePathLen = sourcePathArr.length;
            var i = 0;
            while (targetPathArr[i] == sourcePathArr[i] && i < targetPathLen && i < sourcePathLen) {
                i++;
            }
            for (var j = 0; j < sourcePathLen - i - 1; j++) {
                relPath += "../";
            }
            targetPathArr = targetPathArr.slice(i, targetPathArr.length);
            relPath = relPath + targetPathArr.join("/");
            relPath = relPath.replace(" ", "_");
            return relPath;
        }
        utils.getRelativePath = getRelativePath;
    })(utils = egret3d.utils || (egret3d.utils = {}));
})(egret3d || (egret3d = {}));
var Stats;
(function (Stats_1) {
    var stats;
    var loop;
    /**
     * 显示调试面板
     */
    function show(container, refreshTime) {
        if (refreshTime === void 0) { refreshTime = 500; }
        if (stats == null) {
            stats = new Stats();
            stats.container.style.position = 'absolute';
            stats.container.style.left = '0px';
            stats.container.style.top = '0px';
            container.appendChild(stats.container);
        }
        else {
            container.appendChild(stats.container);
        }
        if (loop) {
            hide();
        }
        loop = setInterval(function () {
            stats.update();
        }, refreshTime);
        egret3d.Performance.enable = true;
    }
    Stats_1.show = show;
    /**
     * 关闭调试面板
     */
    function hide() {
        if (loop) {
            clearInterval(loop);
        }
        if (stats != null && stats.container.parentNode) {
            stats.container.parentNode.removeChild(stats.container);
        }
        egret3d.Performance.enable = false;
    }
    Stats_1.hide = hide;
    /**
     *
     * @author mrdoob / http://mrdoob.com/
     * @modify egret
     */
    var Stats = (function () {
        function Stats() {
            var _this = this;
            this.mode = 0;
            this.container = document.createElement('div');
            this.container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.7;z-index:1';
            this.container.addEventListener('click', function (event) {
                event.preventDefault();
                _this.showPanel(++_this.mode % _this.container.children.length);
            }, false);
            this.fpsPanel = this.addPanel(new Panel('FPS', '#0ff', '#002'));
            this.msPanel = this.addPanel(new Panel('MS', '#0f0', '#020'));
            this.renderPanel = this.addPanel(new Panel('R%', '#0f0', '#020'));
            if (self.performance && self.performance["memory"]) {
                this.memPanel = this.addPanel(new Panel('MB', '#f08', '#201'));
            }
            this.showPanel(0);
        }
        Stats.prototype.update = function () {
            var fps = egret3d.Performance.getFPS();
            var fpsEntity = egret3d.Performance.getEntity("fps");
            var allEntity = egret3d.Performance.getEntity("all");
            var renderEntity = egret3d.Performance.getEntity("render");
            this.fpsPanel.update(fps, 100);
            this.msPanel.update(allEntity.delta, 200);
            this.renderPanel.update(Math.floor(renderEntity.delta / fpsEntity.delta * 100), 100);
            if (this.memPanel) {
                var memory = performance["memory"];
                this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
            }
        };
        Stats.prototype.showPanel = function (id) {
            for (var i = 0; i < this.container.children.length; i++) {
                this.container.children[i]["style"].display = i === id ? 'block' : 'none';
            }
            this.mode = id;
        };
        Stats.prototype.addPanel = function (panel) {
            this.container.appendChild(panel.canvas);
            return panel;
        };
        return Stats;
    }());
    __reflect(Stats.prototype, "Stats");
    /**
     *
     */
    var Panel = (function () {
        function Panel(name, fg, bg) {
            this.name = name;
            this.fg = fg;
            this.bg = bg;
            this.min = Infinity;
            this.max = 0;
            this.PR = Math.round(window.devicePixelRatio || 1);
            this.WIDTH = 80 * this.PR;
            this.HEIGHT = 48 * this.PR;
            this.TEXT_X = 3 * this.PR;
            this.TEXT_Y = 2 * this.PR;
            this.GRAPH_X = 3 * this.PR;
            this.GRAPH_Y = 15 * this.PR;
            this.GRAPH_WIDTH = 74 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR;
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.WIDTH;
            this.canvas.height = this.HEIGHT;
            this.canvas.style.cssText = 'width:80px;height:48px';
            this.context = this.canvas.getContext('2d');
            this.context.font = 'bold ' + (9 * this.PR) + 'px Helvetica,Arial,sans-serif';
            this.context.textBaseline = 'top';
            this.context.fillStyle = bg;
            this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);
            this.context.fillStyle = fg;
            this.context.fillText(name, this.TEXT_X, this.TEXT_Y);
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
            this.context.fillStyle = bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
        }
        Panel.prototype.update = function (value, maxValue) {
            this.min = Math.min(this.min, value);
            this.max = Math.max(this.max, value);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 1;
            this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);
            this.context.fillStyle = this.fg;
            this.context.fillText(Math.round(value) + ' ' + this.name + ' (' + Math.round(this.min) + '-' + Math.round(this.max) + ')', this.TEXT_X, this.TEXT_Y);
            this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT);
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, Math.round((1 - (value / maxValue)) * this.GRAPH_HEIGHT));
        };
        return Panel;
    }());
    __reflect(Panel.prototype, "Panel");
})(Stats || (Stats = {}));
var egret3d;
(function (egret3d) {
    /**
     * device input manager
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 用户输入设备管理器
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var InputManager = (function () {
        function InputManager() {
        }
        /**
         *
         */
        InputManager.init = function (canvas) {
            if (this._isInit) {
                return;
            }
            this._isInit = true;
            this.keyboard = new egret3d.KeyboardDevice(window);
            this.mouse = new egret3d.MouseDevice(canvas);
            this.touch = new egret3d.TouchDevice(canvas);
        };
        /**
         *
         */
        InputManager.update = function (deltaTime) {
            this.keyboard.update();
            this.mouse.update();
            this.touch.update();
        };
        /**
         * is pressed
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 是否正在被点击或者触摸
         * 只有单点触摸才被触发，多点触摸请使用 MouseDivice
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.isPressed = function () {
            if (this.mouse.isPressed(0)) {
                return true;
            }
            else {
                var t = this.touch.getTouch(0);
                if (t && this.touch.touchCount == 1) {
                    if (t.phase == egret3d.TouchPhase.MOVED || t.phase == egret3d.TouchPhase.STATIONARY) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * was pressed
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 是否完成一次点击或触摸
         * 只有单点触摸才被触发，多点触摸请使用 MouseDivice
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.wasPressed = function () {
            if (this.mouse.wasPressed(0)) {
                return true;
            }
            else {
                var t = this.touch.getTouch(0);
                if (t && this.touch.touchCount == 1) {
                    if (t.phase == egret3d.TouchPhase.BEGAN) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * was released
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 是否完成一次鼠标或触摸释放。
         * 只有单点触摸才被触发，多点触摸请使用 MouseDivice
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.wasReleased = function () {
            if (this.mouse.wasReleased(0)) {
                return true;
            }
            else {
                var t = this.touch.getTouch(0);
                if (t && this.touch.touchCount == 1) {
                    if (t.phase == egret3d.TouchPhase.ENDED || t.phase == egret3d.TouchPhase.CANCELED) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * get touch point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取点击或触摸位置
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.getTouchPoint = function () {
            var t = this.touch.getTouch(0);
            if (t) {
                this._touchPoint.x = t.position.x;
                this._touchPoint.y = t.position.y;
            }
            else {
                this._touchPoint.x = this.mouse.position.x;
                this._touchPoint.y = this.mouse.position.y;
            }
            return this._touchPoint;
        };
        InputManager._isInit = false;
        InputManager._touchPoint = new egret3d.Vector2();
        return InputManager;
    }());
    egret3d.InputManager = InputManager;
    __reflect(InputManager.prototype, "egret3d.InputManager");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _keyCodeToKeyIdentifier = {
        'TAB': 9,
        'ENTER': 13,
        'SHIFT': 16,
        'CONTROL': 17,
        'ALT': 18,
        'ESCAPE': 27,
        'LEFT': 37,
        'UP': 38,
        'RIGHT': 39,
        'DOWN': 40,
        'DELETE': 46,
        'WIN': 91
    };
    /**
     * keyboard input
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 键盘输入
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var KeyboardDevice = (function () {
        /**
         *
         */
        function KeyboardDevice(element, options) {
            if (options === void 0) { options = { preventDefault: false, stopPropagation: false }; }
            this._element = null;
            this._keymap = {};
            this._lastmap = {};
            this._keyDownHandler = this._handleKeyDown.bind(this);
            this._keyUpHandler = this._handleKeyUp.bind(this);
            this._keyPressHandler = this._handleKeyPress.bind(this);
            this._cacheKeyCodeMap = {};
            this.attach(element);
            this.preventDefault = options.preventDefault;
            this.stopPropagation = options.stopPropagation;
        }
        KeyboardDevice.prototype.attach = function (element) {
            if (this._element) {
                this.detach();
            }
            this._element = element;
            this._element.addEventListener("keydown", this._keyDownHandler, false);
            this._element.addEventListener("keypress", this._keyPressHandler, false);
            this._element.addEventListener("keyup", this._keyUpHandler, false);
        };
        KeyboardDevice.prototype.detach = function () {
            if (!this._element)
                return;
            this._element.removeEventListener("keydown", this._keyDownHandler, false);
            this._element.removeEventListener("keypress", this._keyPressHandler, false);
            this._element.removeEventListener("keyup", this._keyUpHandler, false);
            this._element = null;
        };
        KeyboardDevice.prototype._handleKeyDown = function (event) {
            var code = event.keyCode || event.charCode;
            var id = this._toKeyIdentifier(code);
            this._keymap[id] = true;
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        KeyboardDevice.prototype._handleKeyPress = function (event) {
            var code = event.keyCode || event.charCode;
            var id = this._toKeyIdentifier(code);
            // do nothing
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        KeyboardDevice.prototype._handleKeyUp = function (event) {
            var code = event.keyCode || event.charCode;
            var id = this._toKeyIdentifier(code);
            delete this._keymap[id];
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        KeyboardDevice.prototype._toKeyIdentifier = function (keyCode) {
            var code;
            if (typeof (keyCode) == "string") {
                var upperCode = keyCode.toUpperCase();
                if (!this._cacheKeyCodeMap[keyCode]) {
                    var _code = _keyCodeToKeyIdentifier[upperCode] || upperCode.charCodeAt(0);
                    this._cacheKeyCodeMap[upperCode] = _code;
                }
                code = this._cacheKeyCodeMap[upperCode];
            }
            else {
                code = keyCode;
            }
            // Convert to hex and add leading 0's
            var hex = code.toString(16).toUpperCase();
            var length = hex.length;
            for (var count = 0; count < (4 - length); count++) {
                hex = '0' + hex;
            }
            return 'U+' + hex;
        };
        /**
         *
         */
        KeyboardDevice.prototype.update = function () {
            var prop;
            for (prop in this._lastmap) {
                delete this._lastmap[prop];
            }
            for (prop in this._keymap) {
                if (this._keymap.hasOwnProperty(prop)) {
                    this._lastmap[prop] = this._keymap[prop];
                }
            }
        };
        /**
         * is pressed
         * @param key key code or char string
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键是否在按下状态
         * @param key 按键，可以为健值或者字符。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        KeyboardDevice.prototype.isPressed = function (key) {
            var id = this._toKeyIdentifier(key);
            return this._keymap[id];
        };
        /**
         * was pressed
         * @param key key code or char string
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被按下一次
         * @param key 按键，可以为健值或者字符。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        KeyboardDevice.prototype.wasPressed = function (key) {
            var id = this._toKeyIdentifier(key);
            return (this._keymap[id] && !this._lastmap[id]);
        };
        /**
         * was released
         * @param key key code or char string
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被抬起一次
         * @param key 按键，可以为健值或者字符。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        KeyboardDevice.prototype.wasReleased = function (key) {
            var id = this._toKeyIdentifier(key);
            return (!this._keymap[id] && this._lastmap[id]);
        };
        return KeyboardDevice;
    }());
    egret3d.KeyboardDevice = KeyboardDevice;
    __reflect(KeyboardDevice.prototype, "egret3d.KeyboardDevice");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * mouse input
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 鼠标输入
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var MouseDevice = (function (_super) {
        __extends(MouseDevice, _super);
        /**
         *
         */
        function MouseDevice(element) {
            var _this = _super.call(this) || this;
            _this._offsetX = 0;
            _this._offsetY = 0;
            _this._scalerX = 1;
            _this._scalerY = 1;
            _this._rotated = false;
            /**
             * mouse position
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前鼠标位置
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.position = new egret3d.Vector2();
            /**
             * mouse wheel value
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前鼠标滚轮值
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.wheel = 0;
            _this._buttons = [false, false, false];
            _this._lastbuttons = [false, false, false];
            _this._element = null;
            _this._upHandler = _this._handleUp.bind(_this);
            _this._moveHandler = _this._handleMove.bind(_this);
            _this._downHandler = _this._handleDown.bind(_this);
            _this._wheelHandler = _this._handleWheel.bind(_this);
            _this._contextMenuHandler = function (event) { event.preventDefault(); };
            _this.attach(element);
            return _this;
        }
        /**
         *
         */
        MouseDevice.prototype.updateOffsetAndScale = function (offsetX, offsetY, scalerX, scalerY, rotated) {
            this._offsetX = offsetX;
            this._offsetY = offsetY;
            this._scalerX = scalerX;
            this._scalerY = scalerY;
            this._rotated = rotated;
        };
        /**
         *
         */
        MouseDevice.prototype.convertPosition = function (value, out) {
            var x = value.x, y = value.y;
            if (this._rotated) {
                out.y = (window.innerWidth - x + this._offsetX) * this._scalerX;
                out.x = (y - this._offsetY) * this._scalerY;
            }
            else {
                out.x = (x - this._offsetX) * this._scalerX;
                out.y = (y - this._offsetY) * this._scalerY;
            }
        };
        /**
         * disable right key menu
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 禁用右键菜单
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.disableContextMenu = function () {
            if (!this._element)
                return;
            this._element.addEventListener("contextmenu", this._contextMenuHandler);
        };
        /**
         * enable right key menu
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 启用右键菜单
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.enableContextMenu = function () {
            if (!this._element)
                return;
            this._element.removeEventListener("contextmenu", this._contextMenuHandler);
        };
        MouseDevice.prototype.attach = function (element) {
            if (this._element) {
                this.detach();
            }
            this._element = element;
            this._element.addEventListener("mouseup", this._upHandler, false);
            this._element.addEventListener("mousemove", this._moveHandler, false);
            this._element.addEventListener("mousedown", this._downHandler, false);
            this._element.addEventListener("mousewheel", this._wheelHandler, false); // WebKit
            this._element.addEventListener("DOMMouseScroll", this._wheelHandler, false); // Gecko
        };
        MouseDevice.prototype.detach = function () {
            if (!this._element)
                return;
            this._element.removeEventListener("mouseup", this._upHandler, false);
            this._element.removeEventListener("mousemove", this._moveHandler, false);
            this._element.removeEventListener("mousedown", this._downHandler, false);
            this._element.removeEventListener("mousewheel", this._wheelHandler, false); // WebKit
            this._element.removeEventListener("DOMMouseScroll", this._wheelHandler, false); // Gecko
            this._element = null;
        };
        /**
         *
         */
        MouseDevice.prototype.update = function () {
            // Copy current button state
            this._lastbuttons[0] = this._buttons[0];
            this._lastbuttons[1] = this._buttons[1];
            this._lastbuttons[2] = this._buttons[2];
            // set wheel to 0
            this.wheel = 0;
        };
        /**
         * is pressed
         * @param key key value. 0: left key; 1: middle key; 2: right key.
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键是否在按下状态
         * @param key 按键。0: 左键；1: 中键；2: 右键。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.isPressed = function (button) {
            return this._buttons[button];
        };
        /**
         * was pressed
         * @param key key value. 0: left key; 1: middle key; 2: right key.
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被按下一次
         * @param key 按键。0: 左键；1: 中键；2: 右键。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.wasPressed = function (button) {
            return (this._buttons[button] && !this._lastbuttons[button]);
        };
        /**
         * was released
         * @param key key value. 0: left key; 1: middle key; 2: right key.
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被抬起一次
         * @param key 按键。0: 左键；1: 中键；2: 右键。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.wasReleased = function (button) {
            return (!this._buttons[button] && this._lastbuttons[button]);
        };
        MouseDevice.prototype._handleUp = function (event) {
            // disable released button
            this._buttons[event.button] = false;
            this.position.set(event.clientX, event.clientY);
            this.convertPosition(this.position, this.position);
            this.dispatchEvent({ type: "mouseup", x: this.position.x, y: this.position.y, identifier: event.button });
        };
        MouseDevice.prototype._handleMove = function (event) {
            this.position.set(event.clientX, event.clientY);
            this.convertPosition(this.position, this.position);
            if (this._buttons[event.button]) {
                this.dispatchEvent({ type: "mousemove", x: this.position.x, y: this.position.y, identifier: event.button });
            }
        };
        MouseDevice.prototype._handleDown = function (event) {
            // Store which button has affected
            this._buttons[event.button] = true;
            this.position.set(event.clientX, event.clientY);
            this.convertPosition(this.position, this.position);
            this.dispatchEvent({ type: "mousedown", x: this.position.x, y: this.position.y, identifier: event.button });
        };
        MouseDevice.prototype._handleWheel = function (event) {
            // FF uses 'detail' and returns a value in 'no. of lines' to scroll
            // WebKit and Opera use 'wheelDelta', WebKit goes in multiples of 120 per wheel notch
            if (event.detail) {
                this.wheel = -1 * event.detail;
            }
            else if (event.wheelDelta) {
                this.wheel = event.wheelDelta / 120;
            }
            else {
                this.wheel = 0;
            }
        };
        return MouseDevice;
    }(egret3d.EventDispatcher));
    egret3d.MouseDevice = MouseDevice;
    __reflect(MouseDevice.prototype, "egret3d.MouseDevice");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * touch phase type
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 触摸状态
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var TouchPhase;
    (function (TouchPhase) {
        /**
         * touch began
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸开始
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["BEGAN"] = 0] = "BEGAN";
        /**
         * touch moved
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸移动
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["MOVED"] = 1] = "MOVED";
        /**
         * touch stationary
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸静止
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["STATIONARY"] = 2] = "STATIONARY";
        /**
         * touch ended
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸结束
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["ENDED"] = 3] = "ENDED";
        /**
         * touch canceled
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸取消
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["CANCELED"] = 4] = "CANCELED";
    })(TouchPhase = egret3d.TouchPhase || (egret3d.TouchPhase = {}));
    /**
     * touch point
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 触摸点信息
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var TouchPoint = (function () {
        function TouchPoint() {
            this.altitudeAngle = Math.PI / 2; // Value of 0 radians indicates that the stylus is parallel to the surface, pi/2 indicates that it is perpendicular.
            this.azimuthAngle = 0; // Value of 0 radians indicates that the stylus is pointed along the x-axis of the device.
            this.deltaPosition = new egret3d.Vector2(); // The position delta since last change.
            // public deltaTime:number = 0; // TODO Amount of time that has passed since the last recorded change in Touch values.
            this.fingerId = 0; // The unique index for the touch.
            this.maximumPossiblePressure = 1.0; // The maximum possible pressure value for a platform. If Input.touchPressureSupported returns false, the value of this property will always be 1.0f.
            this.position = new egret3d.Vector2(); // The position of the touch in pixel coordinates.
            this.pressure = 1.0; //	The current amount of pressure being applied to a touch. 1.0f is considered to be the pressure of an average touch. If Input.touchPressureSupported returns false, the value of this property will always be 1.0f.
            this.radius = new egret3d.Vector2(); // ADD: different from Unity
            // public radius:number = 0; // DELETE: An estimated value of the radius of a touch. Add radiusletiance to get the maximum touch size, subtract it to get the minimum touch size.
            // public radiusletiance:number = 0; // DELETE: The amount that the radius leties by for a touch.
            // public rawPosition:Vector2 = new Vector2(); // DELETE: The raw position used for the touch.
            // public tapCount:number = 0; // TODO Number of taps.
            this.type = "Direct"; // A value that indicates whether a touch was of Direct, Indirect (or remote), or Stylus type.
        }
        /**
         *
         */
        TouchPoint.prototype.set = function (touch, phase, device) {
            this.altitudeAngle = touch.rotationAngle;
            this.azimuthAngle = touch.rotationAngle;
            if (phase == TouchPhase.BEGAN || phase == TouchPhase.STATIONARY) {
                this.deltaPosition.x = 0;
                this.deltaPosition.y = 0;
            }
            else {
                device.convertPosition(touch, this.deltaPosition);
                egret3d.Vector2.subtract(this.deltaPosition, this.position, this.deltaPosition);
            }
            // this.deltaTime;
            this.fingerId = touch.identifier;
            this.phase = phase;
            device.convertPosition(touch, this.position);
            this.pressure = touch.force;
            this.radius.x = touch.radiusX;
            this.radius.y = touch.radiusY;
            // this.tapCount;
        };
        /**
         *
         */
        TouchPoint.create = function () {
            return this._pointPool.pop() || new TouchPoint();
        };
        /**
         *
         */
        TouchPoint.release = function (touchPoint) {
            this._pointPool.push(touchPoint);
        };
        TouchPoint._pointPool = [];
        return TouchPoint;
    }());
    egret3d.TouchPoint = TouchPoint;
    __reflect(TouchPoint.prototype, "egret3d.TouchPoint");
    /**
     * touch input
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 触摸输入
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var TouchDevice = (function (_super) {
        __extends(TouchDevice, _super);
        /**
         *
         */
        function TouchDevice(element, options) {
            if (options === void 0) { options = { preventDefault: true, stopPropagation: true }; }
            var _this = _super.call(this) || this;
            _this._offsetX = 0;
            _this._offsetY = 0;
            _this._scalerX = 1;
            _this._scalerY = 1;
            _this._rotated = false;
            _this._touchesMap = {};
            _this._touches = [];
            /**
             * touch count
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前触摸点的数量
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.touchCount = 0;
            _this._startHandler = _this._handleTouchStart.bind(_this);
            _this._endHandler = _this._handleTouchEnd.bind(_this);
            _this._moveHandler = _this._handleTouchMove.bind(_this);
            _this._cancelHandler = _this._handleTouchCancel.bind(_this);
            _this._element = null;
            _this.attach(element);
            _this.preventDefault = options.preventDefault;
            _this.stopPropagation = options.stopPropagation;
            return _this;
        }
        /**
         *
         */
        TouchDevice.prototype.updateOffsetAndScale = function (offsetX, offsetY, scalerX, scalerY, rotated) {
            this._offsetX = offsetX;
            this._offsetY = offsetY;
            this._scalerX = scalerX;
            this._scalerY = scalerY;
            this._rotated = rotated;
        };
        /**
         *
         */
        TouchDevice.prototype.convertPosition = function (e, out) {
            if (this._rotated) {
                out.y = (window.innerWidth - e.clientX + this._offsetX) * this._scalerX;
                out.x = (e.clientY - this._offsetY) * this._scalerY;
            }
            else {
                out.x = (e.clientX - this._offsetX) * this._scalerX;
                out.y = (e.clientY - this._offsetY) * this._scalerY;
            }
        };
        TouchDevice.prototype.attach = function (element) {
            if (this._element) {
                this.detach();
            }
            this._element = element;
            this._element.addEventListener('touchstart', this._startHandler, false);
            this._element.addEventListener('touchend', this._endHandler, false);
            this._element.addEventListener('touchmove', this._moveHandler, false);
            this._element.addEventListener('touchcancel', this._cancelHandler, false);
        };
        TouchDevice.prototype.detach = function () {
            if (!this._element)
                return;
            this._element.removeEventListener('touchstart', this._startHandler, false);
            this._element.removeEventListener('touchend', this._endHandler, false);
            this._element.removeEventListener('touchmove', this._moveHandler, false);
            this._element.removeEventListener('touchcancel', this._cancelHandler, false);
            this._element = null;
        };
        /**
         *
         */
        TouchDevice.prototype.update = function () {
            for (var i in this._touchesMap) {
                var touch = this._touchesMap[i];
                if (touch.phase === TouchPhase.BEGAN) {
                    touch.phase = TouchPhase.STATIONARY;
                }
                if (touch.phase === TouchPhase.MOVED) {
                    touch.phase = TouchPhase.STATIONARY;
                }
                if (touch.phase === TouchPhase.ENDED || touch.phase === TouchPhase.CANCELED) {
                    delete this._touchesMap[i];
                    var index = this._touches.indexOf(touch);
                    if (index > -1) {
                        this._touches.splice(index, 1);
                    }
                    this.touchCount--;
                }
            }
        };
        /**
         * get touch point
         * @param index touch index
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取触摸点
         * @param index 触摸点的索引
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchDevice.prototype.getTouch = function (index) {
            return this._touches[index];
        };
        TouchDevice.prototype._getTouch = function (identifier) {
            var touchPoint = this._touchesMap[identifier];
            if (!touchPoint) {
                touchPoint = TouchPoint.create();
                this._touchesMap[identifier] = touchPoint;
                this._touches.push(touchPoint);
                this.touchCount++;
            }
            return touchPoint;
        };
        TouchDevice.prototype._handleTouchStart = function (event) {
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.BEGAN, this);
                this.dispatchEvent({ type: "touchstart", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            // call preventDefault to avoid issues in Chrome Android:
            // http://wilsonpage.co.uk/touch-events-in-chrome-android/
            if (this.preventDefault && event["isScroll"] != true && !this._element['userTyping']) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        TouchDevice.prototype._handleTouchEnd = function (event) {
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.ENDED, this);
                this.dispatchEvent({ type: "touchend", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault && event["isScroll"] != true && !this._element['userTyping']) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        TouchDevice.prototype._handleTouchMove = function (event) {
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.MOVED, this);
                this.dispatchEvent({ type: "touchmove", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault && event["isScroll"] != true && !this._element['userTyping']) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        TouchDevice.prototype._handleTouchCancel = function (event) {
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.CANCELED, this);
                this.dispatchEvent({ type: "touchend", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault && event["isScroll"] != true && !this._element['userTyping']) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        return TouchDevice;
    }(egret3d.EventDispatcher));
    egret3d.TouchDevice = TouchDevice;
    __reflect(TouchDevice.prototype, "egret3d.TouchDevice");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 网格。
     */
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        function Mesh() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._ibos = [];
            /**
             * @internal
             */
            _this._vbo = null;
            return _this;
        }
        Mesh.create = function (vertexCountOrConfig, indexCountOrBuffers, attributeNamesOrName, attributeTypes, drawMode) {
            return new Mesh(vertexCountOrConfig, indexCountOrBuffers, attributeNamesOrName, attributeTypes, drawMode);
        };
        Mesh.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (webgl) {
                for (var _i = 0, _a = this._ibos; _i < _a.length; _i++) {
                    var ibo = _a[_i];
                    webgl.deleteBuffer(ibo);
                }
                if (this._vbo) {
                    webgl.deleteBuffer(this._vbo);
                }
            }
            this._ibos.length = 0;
            this._vbo = null;
            return true;
        };
        Mesh.prototype._createBuffer = function () {
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (this._vbo || !webgl) {
                return;
            }
            var vertexBufferViewAccessor = this.getAccessor(this._glTFMesh.primitives[0].attributes.POSITION || 0);
            var vertexBuffer = this.createTypeArrayFromBufferView(this.getBufferView(vertexBufferViewAccessor), 5126 /* Float */);
            var vbo = webgl.createBuffer();
            if (vbo) {
                this._vbo = vbo;
                var attributeNames = [];
                for (var k in this._glTFMesh.primitives[0].attributes) {
                    attributeNames.push(k);
                }
                var subMeshIndex = 0;
                for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                    var primitive = _a[_i];
                    if (primitive.indices !== undefined) {
                        if (this._ibos.length === subMeshIndex) {
                            var ibo = webgl.createBuffer();
                            if (ibo) {
                                this._ibos.push(ibo);
                                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, this.getBufferLength(this.getAccessor(primitive.indices)), this.drawMode);
                                this.uploadSubIndexBuffer(subMeshIndex);
                            }
                            else {
                                console.error("Create webgl element buffer error.");
                            }
                        }
                        else {
                            console.error("Error arguments.");
                        }
                    }
                    else if (this._ibos.length > 0) {
                        console.error("Error arguments.");
                    }
                    subMeshIndex++;
                }
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this._vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, vertexBuffer.byteLength, this.drawMode);
                this.uploadVertexBuffer(attributeNames);
            }
            else {
                console.error("Create webgl buffer error.");
            }
        };
        Mesh.prototype.uploadVertexBuffer = function (uploadAttributes, offset, count) {
            if (uploadAttributes === void 0) { uploadAttributes = null; }
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (!this._vbo || !webgl) {
                return;
            }
            var attributes = this._glTFMesh.primitives[0].attributes;
            webgl.bindBuffer(webgl.ARRAY_BUFFER, this._vbo);
            if (!uploadAttributes) {
                uploadAttributes = [];
                for (var attributeName in this._glTFMesh.primitives[0].attributes) {
                    uploadAttributes.push(attributeName);
                }
            }
            if (Array.isArray(uploadAttributes)) {
                for (var _i = 0, uploadAttributes_1 = uploadAttributes; _i < uploadAttributes_1.length; _i++) {
                    var attributeName = uploadAttributes_1[_i];
                    var accessorIndex = attributes[attributeName];
                    if (accessorIndex !== undefined) {
                        var accessor = this.getAccessor(accessorIndex);
                        var bufferOffset = this.getBufferOffset(accessor);
                        var subVertexBuffer = this.createTypeArrayFromAccessor(accessor, offset, count);
                        webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, subVertexBuffer);
                    }
                    else {
                        console.warn("Error arguments.");
                    }
                }
            }
            else {
                var accessorIndex = attributes[uploadAttributes];
                if (accessorIndex !== undefined) {
                    var accessor = this.getAccessor(accessorIndex);
                    var bufferOffset = this.getBufferOffset(accessor);
                    var subVertexBuffer = this.createTypeArrayFromAccessor(accessor);
                    webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, subVertexBuffer);
                }
                else {
                    console.warn("Error arguments.");
                }
            }
        };
        Mesh.prototype.uploadSubIndexBuffer = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (!this._vbo || !webgl) {
                return;
            }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var primitive = this._glTFMesh.primitives[subMeshIndex];
                if (primitive.indices !== undefined) {
                    var accessor = this.getAccessor(primitive.indices);
                    var subIndexBuffer = this.createTypeArrayFromAccessor(accessor);
                    var ibo = this._ibos[subMeshIndex];
                    webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                    webgl.bufferSubData(webgl.ELEMENT_ARRAY_BUFFER, 0, subIndexBuffer);
                }
                else {
                    console.warn("Error arguments.");
                }
            }
            else {
                console.warn("Error arguments.");
            }
        };
        return Mesh;
    }(egret3d.BaseMesh));
    egret3d.Mesh = Mesh;
    __reflect(Mesh.prototype, "egret3d.Mesh");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var TextureFormatEnum;
    (function (TextureFormatEnum) {
        TextureFormatEnum[TextureFormatEnum["RGBA"] = 1] = "RGBA";
        TextureFormatEnum[TextureFormatEnum["RGB"] = 2] = "RGB";
        TextureFormatEnum[TextureFormatEnum["Gray"] = 3] = "Gray";
        TextureFormatEnum[TextureFormatEnum["PVRTC4_RGB"] = 4] = "PVRTC4_RGB";
        TextureFormatEnum[TextureFormatEnum["PVRTC4_RGBA"] = 4] = "PVRTC4_RGBA";
        TextureFormatEnum[TextureFormatEnum["PVRTC2_RGB"] = 4] = "PVRTC2_RGB";
        TextureFormatEnum[TextureFormatEnum["PVRTC2_RGBA"] = 4] = "PVRTC2_RGBA";
    })(TextureFormatEnum = egret3d.TextureFormatEnum || (egret3d.TextureFormatEnum = {}));
    var GLTexture = (function (_super) {
        __extends(GLTexture, _super);
        function GLTexture(name, width, height) {
            if (name === void 0) { name = ""; }
            if (width === void 0) { width = 0; }
            if (height === void 0) { height = 0; }
            var _this = _super.call(this, name) || this;
            _this._width = width;
            _this._height = height;
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (webgl) {
                _this._texture = webgl.createTexture();
            }
            return _this;
        }
        Object.defineProperty(GLTexture.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GLTexture.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GLTexture.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        return GLTexture;
    }(egret3d.Texture));
    egret3d.GLTexture = GLTexture;
    __reflect(GLTexture.prototype, "egret3d.GLTexture", ["egret3d.ITexture"]);
    /**
     *
     */
    var GLTexture2D = (function (_super) {
        __extends(GLTexture2D, _super);
        function GLTexture2D(name, width, height, format) {
            if (name === void 0) { name = ""; }
            if (width === void 0) { width = 0; }
            if (height === void 0) { height = 0; }
            if (format === void 0) { format = 1 /* RGBA */; }
            var _this = _super.call(this, name, width, height) || this;
            //
            _this._mipmap = false;
            //
            _this._format = format;
            return _this;
        }
        GLTexture2D.createColorTexture = function (name, r, g, b) {
            var mipmap = false;
            var linear = true;
            var width = 1;
            var height = 1;
            var data = new Uint8Array([r, g, b, 255]);
            var texture = new GLTexture2D(name, width, height, 1 /* RGBA */);
            texture.uploadImage(data, mipmap, linear, true, false);
            return texture;
        };
        GLTexture2D.createGridTexture = function (name) {
            var mipmap = false;
            var linear = true;
            var width = 256;
            var height = 256;
            var data = new Uint8Array(width * width * 4);
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var seek = (y * width + x) * 4;
                    var bool = ((x - width * 0.5) * (y - height * 0.5)) > 0;
                    data[seek] = data[seek + 1] = data[seek + 2] = bool ? 0 : 255;
                    data[seek + 3] = 255;
                }
            }
            var texture = new GLTexture2D(name, width, height, 1 /* RGBA */);
            texture.uploadImage(data, mipmap, linear, true, false);
            return texture;
        };
        GLTexture2D.prototype.uploadImage = function (img, mipmap, linear, premultiply, repeat, mirroredU, mirroredV) {
            if (premultiply === void 0) { premultiply = true; }
            if (repeat === void 0) { repeat = false; }
            if (mirroredU === void 0) { mirroredU = false; }
            if (mirroredV === void 0) { mirroredV = false; }
            this._mipmap = mipmap;
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (!webgl) {
                return;
            }
            webgl.bindTexture(webgl.TEXTURE_2D, this._texture);
            webgl.pixelStorei(webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
            webgl.pixelStorei(webgl.UNPACK_FLIP_Y_WEBGL, 0);
            var formatGL = webgl.RGBA;
            if (this._format === 2 /* RGB */) {
                formatGL = webgl.RGB;
            }
            else if (this._format === 3 /* Gray */) {
                formatGL = webgl.LUMINANCE;
            }
            //
            if (ArrayBuffer.isView(img)) {
                webgl.texImage2D(webgl.TEXTURE_2D, 0, formatGL, this._width, this._height, 0, formatGL, webgl.UNSIGNED_BYTE, img);
            }
            else {
                webgl.texImage2D(webgl.TEXTURE_2D, 0, formatGL, formatGL, webgl.UNSIGNED_BYTE, img);
            }
            if (mipmap) {
                webgl.generateMipmap(webgl.TEXTURE_2D);
                if (linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR_MIPMAP_LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST_MIPMAP_NEAREST);
                }
            }
            else {
                if (linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST);
                }
            }
            var wrap_s_param = webgl.CLAMP_TO_EDGE;
            var wrap_t_param = webgl.CLAMP_TO_EDGE;
            if (repeat) {
                wrap_s_param = mirroredU ? webgl.MIRRORED_REPEAT : webgl.REPEAT;
                wrap_t_param = mirroredV ? webgl.MIRRORED_REPEAT : webgl.REPEAT;
            }
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, wrap_s_param);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, wrap_t_param);
        };
        GLTexture2D.prototype.caclByteLength = function () {
            var pixellen = 1;
            if (this._format === 1 /* RGBA */) {
                pixellen = 4;
            }
            else if (this._format === 2 /* RGB */) {
                pixellen = 3;
            }
            var len = this.width * this.height * pixellen;
            if (this._mipmap) {
                len = len * (1 - Math.pow(0.25, 10)) / 0.75;
            }
            return len;
        };
        GLTexture2D.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            if (this._texture !== null) {
                egret3d.WebGLCapabilities.webgl.deleteTexture(this._texture);
                this._texture = null;
            }
            return true;
        };
        GLTexture2D.prototype.getReader = function (redOnly) {
            if (redOnly === void 0) { redOnly = false; }
            if (this._reader !== null) {
                if (this._reader.gray !== redOnly) {
                    throw new Error("get param diff with this.reader");
                }
                return this._reader;
            }
            if (this._format !== 1 /* RGBA */) {
                throw new Error("only rgba texture can read");
            }
            if (this._texture === null) {
                return null;
            }
            if (this._reader === null)
                this._reader = new TextureReader(this._texture, this._width, this._height, redOnly);
            return this._reader;
        };
        return GLTexture2D;
    }(GLTexture));
    egret3d.GLTexture2D = GLTexture2D;
    __reflect(GLTexture2D.prototype, "egret3d.GLTexture2D");
    var TextureReader = (function () {
        function TextureReader(texRGBA, width, height, gray) {
            if (gray === void 0) { gray = true; }
            this.gray = gray;
            this.width = width;
            this.height = height;
            var readData = new Uint8Array(this.width * this.height * 4);
            readData[0] = 2;
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (webgl) {
                var fbo = webgl.createFramebuffer();
                var fbold = webgl.getParameter(webgl.FRAMEBUFFER_BINDING);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbo);
                webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, texRGBA, 0);
                webgl.readPixels(0, 0, this.width, this.height, webgl.RGBA, webgl.UNSIGNED_BYTE, readData);
                webgl.deleteFramebuffer(fbo);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbold);
            }
            if (gray) {
                this.data = new Uint8Array(this.width * this.height);
                for (var i = 0; i < width * height; i++) {
                    this.data[i] = readData[i * 4];
                }
            }
            else {
                this.data = readData;
            }
        }
        TextureReader.prototype.getPixel = function (u, v) {
            var x = (u * this.width) | 0;
            var y = (v * this.height) | 0;
            if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
                return 0;
            }
            if (this.gray) {
                return this.data[y * this.width + x];
            }
            else {
                var i = (y * this.width + x) * 4;
                return egret3d.Color.create(this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]);
            }
        };
        return TextureReader;
    }());
    egret3d.TextureReader = TextureReader;
    __reflect(TextureReader.prototype, "egret3d.TextureReader");
    var WriteableTexture2D = (function () {
        function WriteableTexture2D(format, width, height, linear, premultiply, repeat, mirroredU, mirroredV) {
            if (format === void 0) { format = 1 /* RGBA */; }
            if (premultiply === void 0) { premultiply = true; }
            if (repeat === void 0) { repeat = false; }
            if (mirroredU === void 0) { mirroredU = false; }
            if (mirroredV === void 0) { mirroredV = false; }
            this.width = 0;
            this.height = 0;
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (!webgl) {
                return;
            }
            this.texture = webgl.createTexture();
            webgl.pixelStorei(webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
            webgl.pixelStorei(webgl.UNPACK_FLIP_Y_WEBGL, 0);
            webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            this.format = format;
            var formatGL = webgl.RGBA;
            if (format === 2 /* RGB */) {
                formatGL = webgl.RGB;
            }
            else if (format === 3 /* Gray */) {
                formatGL = webgl.LUMINANCE;
            }
            var data = null;
            webgl.texImage2D(webgl.TEXTURE_2D, 0, formatGL, width, height, 0, formatGL, webgl.UNSIGNED_BYTE, data);
            if (linear) {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
            }
            else {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST);
            }
            if (repeat) {
                if (mirroredU) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.MIRRORED_REPEAT);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.REPEAT);
                }
                if (mirroredV) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.MIRRORED_REPEAT);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.REPEAT);
                }
            }
            else {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.CLAMP_TO_EDGE);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.CLAMP_TO_EDGE);
            }
        }
        WriteableTexture2D.prototype.dispose = function () {
            if (this.texture) {
                egret3d.WebGLCapabilities.webgl.deleteTexture(this.texture);
                this.texture = null;
            }
        };
        WriteableTexture2D.prototype.caclByteLength = function () {
            var pixellen = 1;
            if (this.format === 1 /* RGBA */) {
                pixellen = 4;
            }
            else if (this.format === 2 /* RGB */) {
                pixellen = 3;
            }
            var len = this.width * this.height * pixellen;
            return len;
        };
        return WriteableTexture2D;
    }());
    egret3d.WriteableTexture2D = WriteableTexture2D;
    __reflect(WriteableTexture2D.prototype, "egret3d.WriteableTexture2D", ["egret3d.ITexture"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var BaseRenderTarget = (function (_super) {
        __extends(BaseRenderTarget, _super);
        function BaseRenderTarget(name, width, height, depth, stencil, mipmap, linear) {
            if (depth === void 0) { depth = false; }
            if (stencil === void 0) { stencil = false; }
            if (mipmap === void 0) { mipmap = false; }
            if (linear === void 0) { linear = false; }
            var _this = _super.call(this, name) || this;
            _this._width = width;
            _this._height = height;
            _this._depth = depth;
            _this._stencil = stencil;
            _this._mipmap = mipmap;
            _this._linear = linear;
            _this.uploadTexture();
            return _this;
        }
        BaseRenderTarget.prototype.uploadTexture = function () {
            var width = this._width;
            var height = this._height;
            var depth = this._depth;
            var stencil = this._stencil;
            var webgl = egret3d.WebGLCapabilities.webgl;
            this._texture = webgl.createTexture();
            this._fbo = webgl.createFramebuffer();
            this._fbo["width"] = width;
            this._fbo["height"] = height;
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this._fbo);
            if (depth || stencil) {
                this._renderbuffer = webgl.createRenderbuffer();
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, this._renderbuffer);
                if (depth && stencil) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this._renderbuffer);
                }
                else if (depth) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, this._renderbuffer);
                }
                else {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.STENCIL_INDEX8, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this._renderbuffer);
                }
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
            }
        };
        BaseRenderTarget.prototype.use = function () {
        };
        BaseRenderTarget.prototype.generateMipmap = function () {
            return false;
        };
        BaseRenderTarget.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            if (this._texture !== null) {
                var webgl = egret3d.WebGLCapabilities.webgl;
                webgl.deleteFramebuffer(this._renderbuffer);
                webgl.deleteTexture(this._texture);
                this._renderbuffer = null;
                this._texture = null;
            }
        };
        BaseRenderTarget.prototype.caclByteLength = function () {
            return this.width * this.height * 4;
        };
        Object.defineProperty(BaseRenderTarget.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderTarget.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderTarget.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        return BaseRenderTarget;
    }(egret3d.Texture));
    egret3d.BaseRenderTarget = BaseRenderTarget;
    __reflect(BaseRenderTarget.prototype, "egret3d.BaseRenderTarget");
    var GlRenderTarget = (function (_super) {
        __extends(GlRenderTarget, _super);
        function GlRenderTarget() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GlRenderTarget.prototype.uploadTexture = function () {
            _super.prototype.uploadTexture.call(this);
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            webgl.pixelStorei(webgl.UNPACK_ALIGNMENT, 4);
            webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, this._width, this._height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
            if (this._mipmap) {
                webgl.generateMipmap(webgl.TEXTURE_2D);
                if (this._linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR_MIPMAP_LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST_MIPMAP_NEAREST);
                }
            }
            else {
                if (this._linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST);
                }
            }
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, this.texture, 0);
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
        };
        GlRenderTarget.prototype.use = function () {
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this._fbo);
        };
        GlRenderTarget.prototype.generateMipmap = function () {
            if (this._mipmap) {
                var webgl = egret3d.WebGLCapabilities.webgl;
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
                webgl.generateMipmap(webgl.TEXTURE_2D);
                webgl.bindTexture(webgl.TEXTURE_2D, null);
                return true;
            }
            return false;
        };
        return GlRenderTarget;
    }(BaseRenderTarget));
    egret3d.GlRenderTarget = GlRenderTarget;
    __reflect(GlRenderTarget.prototype, "egret3d.GlRenderTarget");
    var GlRenderTargetCube = (function (_super) {
        __extends(GlRenderTargetCube, _super);
        function GlRenderTargetCube(name, width, height, depth, stencil) {
            if (depth === void 0) { depth = false; }
            if (stencil === void 0) { stencil = false; }
            var _this = _super.call(this, name, width, height, depth, stencil) || this;
            _this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindTexture(webgl.TEXTURE_CUBE_MAP, _this.texture);
            webgl.texParameteri(webgl.TEXTURE_CUBE_MAP, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
            webgl.texParameteri(webgl.TEXTURE_CUBE_MAP, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
            for (var i = 0; i < 6; i++) {
                webgl.texImage2D(webgl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
            }
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_CUBE_MAP_POSITIVE_X + _this.activeCubeFace, _this.texture, 0);
            return _this;
        }
        GlRenderTargetCube.prototype.use = function () {
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this._fbo);
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_CUBE_MAP_POSITIVE_X + this.activeCubeFace, this.texture, 0);
        };
        return GlRenderTargetCube;
    }(BaseRenderTarget));
    egret3d.GlRenderTargetCube = GlRenderTargetCube;
    __reflect(GlRenderTargetCube.prototype, "egret3d.GlRenderTargetCube");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    // 运行时 draw call 排序优化使用。
    var _hashCode = 0;
    /**
     * @private
     */
    var GlProgram = (function () {
        function GlProgram(webglProgram) {
            this.id = _hashCode++;
            this.attributes = [];
            this.contextUniforms = [];
            this.uniforms = [];
            this.program = webglProgram;
        }
        return GlProgram;
    }());
    egret3d.GlProgram = GlProgram;
    __reflect(GlProgram.prototype, "egret3d.GlProgram");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * WebGL 渲染系统
     */
    var WebGLRenderSystem = (function (_super) {
        __extends(WebGLRenderSystem, _super);
        function WebGLRenderSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                [
                    { componentClass: egret3d.Camera }
                ],
                [
                    { componentClass: egret3d.Egret2DRenderer }
                ],
                [
                    { componentClass: [egret3d.DirectionalLight, egret3d.SpotLight, egret3d.PointLight] }
                ]
            ];
            _this._drawCalls = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.DrawCalls);
            _this._camerasAndLights = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.CamerasAndLights);
            _this._renderState = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.WebGLRenderState);
            _this._lightCamera = paper.GameObject.globalGameObject.getOrAddComponent(egret3d.Camera);
            //
            _this._cacheLightCount = 0;
            //
            _this._cacheMaterialVerision = -1;
            _this._cacheMaterial = null;
            //
            _this._cacheSubMeshIndex = -1;
            _this._cacheMesh = null;
            return _this;
        }
        WebGLRenderSystem.prototype._renderLightShadow = function (light) {
            var camera = this._lightCamera;
            var renderState = this._renderState;
            var shadowMaterial = light.constructor === egret3d.PointLight ? egret3d.DefaultMaterials.SHADOW_DISTANCE : egret3d.DefaultMaterials.SHADOW_DEPTH;
            var drawCalls = this._drawCalls;
            var shadowCalls = drawCalls.shadowCalls;
            for (var i = 0, l = light.constructor === egret3d.PointLight ? 6 : 1; i < l; ++i) {
                var context = camera.context;
                light.update(camera, i);
                light.renderTarget.activeCubeFace = i; // TODO 创建接口。
                renderState.targetAndViewport(camera.viewport, light.renderTarget);
                renderState.clear(camera.clearOption_Color, camera.clearOption_Depth, camera.backgroundColor);
                drawCalls.shadowFrustumCulling(camera);
                for (var _i = 0, shadowCalls_1 = shadowCalls; _i < shadowCalls_1.length; _i++) {
                    var drawCall = shadowCalls_1[_i];
                    this._draw(context, drawCall, shadowMaterial);
                }
            }
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
        };
        WebGLRenderSystem.prototype._renderCamera = function (camera, renderEnabled) {
            if (renderEnabled) {
                //在这里先剔除，然后排序，最后绘制
                var drawCalls = this._drawCalls;
                drawCalls.frustumCulling(camera);
                //
                var opaqueCalls = drawCalls.opaqueCalls;
                var transparentCalls = drawCalls.transparentCalls;
                // Step 1 draw opaques.
                for (var _i = 0, opaqueCalls_1 = opaqueCalls; _i < opaqueCalls_1.length; _i++) {
                    var drawCall = opaqueCalls_1[_i];
                    this._draw(camera.context, drawCall, drawCall.material);
                }
                // Step 2 draw transparents.
                for (var _a = 0, transparentCalls_1 = transparentCalls; _a < transparentCalls_1.length; _a++) {
                    var drawCall = transparentCalls_1[_a];
                    this._draw(camera.context, drawCall, drawCall.material);
                }
            }
            // Egret2D渲染不加入DrawCallList的排序
            for (var _b = 0, _c = this._groups[1].gameObjects; _b < _c.length; _b++) {
                var gameObject = _c[_b];
                var egret2DRenderer = gameObject.getComponent(egret3d.Egret2DRenderer);
                if (camera.cullingMask & egret2DRenderer.gameObject.layer) {
                    egret2DRenderer.render(camera.context, camera);
                    //
                    this._renderState.clearState();
                }
            }
        };
        WebGLRenderSystem.prototype._draw = function (context, drawCall, material) {
            context.update(drawCall);
            //
            var webgl = egret3d.WebGLCapabilities.webgl;
            var technique = material._glTFTechnique;
            var renderState = this._renderState;
            // Get program.
            var program = renderState.getProgram(material, technique, context.shaderContextDefine + material.shaderDefine);
            // Use program.
            var force = renderState.useProgram(program);
            // Update states.
            renderState.updateState(technique.states || null);
            // Update static uniforms.
            this._updateContextUniforms(program, context, technique);
            // Update uniforms.
            this._updateUniforms(program, material, technique, force);
            // Update attributes.
            this._updateAttributes(program, drawCall.mesh, drawCall.subMeshIndex, technique, force);
            // Draw.
            var mesh = drawCall.mesh;
            var glTFMesh = mesh.glTFMesh;
            var primitive = glTFMesh.primitives[drawCall.subMeshIndex];
            var vertexAccessor = mesh.getAccessor(glTFMesh.primitives[0].attributes.POSITION || 0);
            var bufferOffset = mesh.getBufferOffset(vertexAccessor);
            var drawMode = primitive.mode === undefined ? 4 /* Triangles */ : primitive.mode;
            if (primitive.indices !== undefined) {
                var indexAccessor = mesh.getAccessor(primitive.indices);
                webgl.drawElements(drawMode, indexAccessor.count, webgl.UNSIGNED_SHORT, bufferOffset);
            }
            else {
                webgl.drawArrays(drawMode, bufferOffset, vertexAccessor.count);
            }
        };
        WebGLRenderSystem.prototype._updateContextUniforms = function (program, context, technique) {
            var webgl = egret3d.WebGLCapabilities.webgl;
            var uniforms = technique.uniforms;
            var glUniforms = program.contextUniforms;
            for (var _i = 0, glUniforms_1 = glUniforms; _i < glUniforms_1.length; _i++) {
                var glUniform = glUniforms_1[_i];
                var uniform = uniforms[glUniform.name];
                if (!uniform.semantic) {
                    continue;
                }
                var location_3 = glUniform.location;
                switch (uniform.semantic) {
                    case "MODEL" /* MODEL */:
                        webgl.uniformMatrix4fv(location_3, false, context.matrix_m.rawData);
                        break;
                    case "MODELVIEW" /* MODELVIEW */:
                        webgl.uniformMatrix4fv(location_3, false, context.matrix_mv.rawData);
                        break;
                    case "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */:
                        webgl.uniformMatrix4fv(location_3, false, context.matrix_mvp.rawData);
                        break;
                    case "MODELVIEWINVERSE" /* MODELVIEWINVERSE */:
                        webgl.uniformMatrix3fv(location_3, false, context.matrix_mv_inverse.rawData);
                        break;
                    case "VIEW" /* VIEW */:
                        webgl.uniformMatrix4fv(location_3, false, context.matrix_v.rawData);
                        break;
                    case "PROJECTION" /* PROJECTION */:
                        webgl.uniformMatrix4fv(location_3, false, context.matrix_p.rawData);
                        break;
                    case "_VIEWPROJECTION" /* _VIEWPROJECTION */:
                        webgl.uniformMatrix4fv(location_3, false, context.matrix_vp.rawData);
                        break;
                    case "_CAMERA_POS" /* _CAMERA_POS */:
                        webgl.uniform3fv(location_3, context.cameraPosition);
                        break;
                    case "_CAMERA_FORWARD" /* _CAMERA_FORWARD */:
                        webgl.uniform3fv(location_3, context.cameraForward);
                        break;
                    case "CAMERA_UP" /* _CAMERA_UP */:
                        webgl.uniform3fv(location_3, context.cameraUp);
                        break;
                    case "JOINTMATRIX" /* JOINTMATRIX */:
                        webgl.uniformMatrix4fv(location_3, false, context.drawCall.renderer.boneMatrices);
                        break;
                    case "_DIRECTLIGHTS" /* _DIRECTLIGHTS */:
                        if (context.directLightCount > 0) {
                            webgl.uniform1fv(location_3, context.directLightArray);
                        }
                        break;
                    case "_POINTLIGHTS" /* _POINTLIGHTS */:
                        if (context.pointLightCount > 0) {
                            webgl.uniform1fv(location_3, context.pointLightArray);
                        }
                        break;
                    case "_SPOTLIGHTS" /* _SPOTLIGHTS */:
                        if (context.spotLightCount > 0) {
                            webgl.uniform1fv(location_3, context.spotLightArray);
                        }
                        break;
                    case "_AMBIENTLIGHTCOLOR" /* _AMBIENTLIGHTCOLOR */:
                        webgl.uniform3fv(location_3, context.ambientLightColor);
                        break;
                    case "_DIRECTIONSHADOWMAT" /* _DIRECTIONSHADOWMAT */:
                        webgl.uniformMatrix4fv(location_3, false, context.directShadowMatrix);
                        break;
                    case "_SPOTSHADOWMAT" /* _SPOTSHADOWMAT */:
                        webgl.uniformMatrix4fv(location_3, false, context.spotShadowMatrix);
                        break;
                    case "_POINTSHADOWMAT" /* _POINTSHADOWMAT */:
                        webgl.uniformMatrix4fv(location_3, false, context.pointShadowMatrix);
                        break;
                    case "_DIRECTIONSHADOWMAP" /* _DIRECTIONSHADOWMAP */:
                        var directShadowLen = context.directShadowMaps.length;
                        if (directShadowLen > 0 && glUniform.textureUnits) {
                            var units = glUniform.textureUnits;
                            webgl.uniform1iv(location_3, units);
                            for (var i = 0, l = units.length; i < l; i++) {
                                if (context.directShadowMaps[i]) {
                                    webgl.activeTexture(webgl.TEXTURE0 + units[i]);
                                    webgl.bindTexture(webgl.TEXTURE_2D, context.directShadowMaps[i]);
                                }
                            }
                        }
                        break;
                    case "_POINTSHADOWMAP" /* _POINTSHADOWMAP */:
                        var pointShadowLen = context.pointShadowMaps.length;
                        if (pointShadowLen > 0 && glUniform.textureUnits) {
                            var units = glUniform.textureUnits;
                            webgl.uniform1iv(location_3, units);
                            for (var i = 0, l = units.length; i < l; i++) {
                                if (context.pointShadowMaps[i]) {
                                    webgl.activeTexture(webgl.TEXTURE0 + units[i]);
                                    webgl.bindTexture(webgl.TEXTURE_2D, context.pointShadowMaps[i]);
                                }
                            }
                        }
                        break;
                    case "_SPOTSHADOWMAP" /* _SPOTSHADOWMAP */:
                        var spotShadowLen = context.spotShadowMaps.length;
                        if (spotShadowLen > 0 && glUniform.textureUnits) {
                            var units = glUniform.textureUnits;
                            webgl.uniform1iv(location_3, units);
                            for (var i = 0, l = units.length; i < l; i++) {
                                if (context.spotShadowMaps[i]) {
                                    webgl.activeTexture(webgl.TEXTURE0 + units[i]);
                                    webgl.bindTexture(webgl.TEXTURE_2D, context.spotShadowMaps[i]);
                                }
                            }
                        }
                        break;
                    case "_LIGHTMAPTEX" /* _LIGHTMAPTEX */:
                        if (glUniform.textureUnits && glUniform.textureUnits.length === 1 && context.lightmap) {
                            var unit = glUniform.textureUnits[0];
                            webgl.uniform1i(location_3, unit);
                            webgl.activeTexture(webgl.TEXTURE0 + unit);
                            webgl.bindTexture(webgl.TEXTURE_2D, context.lightmap._texture);
                        }
                        else {
                            console.error("Error texture unit.");
                        }
                        break;
                    case "_LIGHTMAPINTENSITY" /* _LIGHTMAPINTENSITY */:
                        webgl.uniform1f(location_3, context.lightmapIntensity);
                        break;
                    case "_REFERENCEPOSITION" /* _REFERENCEPOSITION */:
                        webgl.uniform4fv(location_3, context.lightPosition);
                        break;
                    case "_NEARDICTANCE" /* _NEARDICTANCE */:
                        webgl.uniform1f(location_3, context.lightShadowCameraNear);
                        break;
                    case "_FARDISTANCE" /* _FARDISTANCE */:
                        webgl.uniform1f(location_3, context.lightShadowCameraFar);
                        break;
                    case "_FOG_COLOR" /* _FOG_COLOR */:
                        webgl.uniform3fv(location_3, context.fogColor);
                        break;
                    case "_FOG_DENSITY" /* _FOG_DENSITY */:
                        webgl.uniform1f(location_3, context.fogDensity);
                        break;
                    case "_FOG_NEAR" /* _FOG_NEAR */:
                        webgl.uniform1f(location_3, context.fogNear);
                        break;
                    case "_FOG_FAR" /* _FOG_FAR */:
                        webgl.uniform1f(location_3, context.fogFar);
                        break;
                    default:
                        console.warn("不识别的Uniform语义:" + uniform.semantic);
                        break;
                }
            }
        };
        WebGLRenderSystem.prototype._updateUniforms = function (program, material, technique, forceUpdate) {
            var needUpdate = this._cacheMaterial !== material || this._cacheMaterialVerision !== material._version || forceUpdate;
            if (!needUpdate) {
                return;
            }
            this._cacheMaterial = material;
            this._cacheMaterialVerision = material._version;
            var webgl = egret3d.WebGLCapabilities.webgl;
            var unifroms = technique.uniforms;
            var glUniforms = program.uniforms;
            for (var _i = 0, glUniforms_2 = glUniforms; _i < glUniforms_2.length; _i++) {
                var glUniform = glUniforms_2[_i];
                var uniform = unifroms[glUniform.name];
                if (uniform.semantic) {
                    continue;
                }
                var location_4 = glUniform.location;
                var value = uniform.value;
                switch (uniform.type) {
                    case 35670 /* BOOL */:
                    case 5124 /* INT */:
                        if (glUniform.size > 1) {
                            webgl.uniform1iv(location_4, value);
                        }
                        else {
                            webgl.uniform1i(location_4, value);
                        }
                        break;
                    case 35671 /* BOOL_VEC2 */:
                    case 35667 /* INT_VEC2 */:
                        webgl.uniform2iv(location_4, value);
                        break;
                    case 35672 /* BOOL_VEC3 */:
                    case 35668 /* INT_VEC3 */:
                        webgl.uniform3iv(location_4, value);
                        break;
                    case 35673 /* BOOL_VEC4 */:
                    case 35669 /* INT_VEC4 */:
                        webgl.uniform4iv(location_4, value);
                        break;
                    case 5126 /* FLOAT */:
                        if (glUniform.size > 1) {
                            webgl.uniform1fv(location_4, value);
                        }
                        else {
                            webgl.uniform1f(location_4, value);
                        }
                        break;
                    case 35664 /* FLOAT_VEC2 */:
                        webgl.uniform2fv(location_4, value);
                        break;
                    case 35665 /* FLOAT_VEC3 */:
                        webgl.uniform3fv(location_4, value);
                        break;
                    case 35666 /* FLOAT_VEC4 */:
                        webgl.uniform4fv(location_4, value);
                        break;
                    case 35674 /* FLOAT_MAT2 */:
                        webgl.uniformMatrix2fv(location_4, false, value);
                        break;
                    case 35675 /* FLOAT_MAT3 */:
                        webgl.uniformMatrix3fv(location_4, false, value);
                        break;
                    case 35676 /* FLOAT_MAT4 */:
                        webgl.uniformMatrix4fv(location_4, false, value);
                        break;
                    case 35678 /* SAMPLER_2D */:
                        if (glUniform.textureUnits && glUniform.textureUnits.length === 1) {
                            var unit = glUniform.textureUnits[0];
                            webgl.uniform1i(location_4, unit);
                            webgl.activeTexture(webgl.TEXTURE0 + unit);
                            webgl.bindTexture(webgl.TEXTURE_2D, value._texture);
                        }
                        else {
                            console.error("Error texture unit");
                        }
                        break;
                }
            }
        };
        WebGLRenderSystem.prototype._updateAttributes = function (program, mesh, subMeshIndex, technique, forceUpdate) {
            var needUpdate = forceUpdate || this._cacheSubMeshIndex !== subMeshIndex || this._cacheMesh !== mesh;
            if (!needUpdate) {
                return;
            }
            this._cacheSubMeshIndex = subMeshIndex;
            this._cacheMesh = mesh;
            var webgl = egret3d.WebGLCapabilities.webgl;
            var primitive = mesh.glTFMesh.primitives[subMeshIndex];
            // vbo.
            var webglAttributes = program.attributes;
            var attributes = technique.attributes;
            webgl.bindBuffer(webgl.ARRAY_BUFFER, mesh._vbo);
            for (var _i = 0, webglAttributes_1 = webglAttributes; _i < webglAttributes_1.length; _i++) {
                var glAttribute = webglAttributes_1[_i];
                var attribute = attributes[glAttribute.name];
                var location_5 = glAttribute.location;
                var accessorIndex = primitive.attributes[attribute.semantic];
                if (accessorIndex !== undefined) {
                    var accessor = mesh.getAccessor(accessorIndex);
                    var bufferOffset = mesh.getBufferOffset(accessor);
                    var typeCount = mesh.getAccessorTypeCount(accessor.type);
                    webgl.vertexAttribPointer(location_5, typeCount, accessor.componentType, accessor.normalized ? true : false, 0, bufferOffset); //TODO normalized应该来源于mesh，应该还没有
                    webgl.enableVertexAttribArray(location_5);
                }
                else {
                    webgl.disableVertexAttribArray(location_5);
                }
            }
            // ibo.
            var ibo = mesh._ibos[subMeshIndex];
            if (ibo) {
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
            }
        };
        WebGLRenderSystem.prototype.onUpdate = function () {
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (!webgl) {
                return;
            }
            egret3d.Performance.startCounter("render");
            var lightCountDirty = false;
            var isPlayerMode = paper.Application.playerMode === 0 /* Player */;
            var renderState = this._renderState;
            var cameras = this._camerasAndLights.cameras;
            var lights = this._camerasAndLights.lights;
            var editorScene = paper.Application.sceneManager.editorScene;
            this._drawCalls.drawCallCount = 0;
            // Render lights.
            if (lights.length > 0) {
                lightCountDirty = true;
                this._cacheLightCount = 0;
                for (var _i = 0, lights_3 = lights; _i < lights_3.length; _i++) {
                    var light = lights_3[_i];
                    this._cacheLightCount++;
                    if (!light.castShadows) {
                        continue;
                    }
                    this._renderLightShadow(light);
                }
            }
            else if (this._cacheLightCount > 0) {
                lightCountDirty = true;
                this._cacheLightCount = 0;
            }
            // Render cameras.
            if (cameras.length > 0) {
                for (var _a = 0, cameras_2 = cameras; _a < cameras_2.length; _a++) {
                    var camera = cameras_2[_a];
                    var renderEnabled = isPlayerMode ? camera.gameObject.scene !== editorScene : camera.gameObject.scene === editorScene;
                    if (renderEnabled && lightCountDirty) {
                        camera.context.updateLights(lights, camera.gameObject.scene.ambientColor); // TODO 性能优化
                    }
                    if (camera.postQueues.length === 0) {
                        if (renderEnabled) {
                            renderState.targetAndViewport(camera.viewport, camera.renderTarget);
                            renderState.clear(camera.clearOption_Color, camera.clearOption_Depth, camera.backgroundColor);
                        }
                        this._renderCamera(camera, renderEnabled);
                        if (renderEnabled && camera.renderTarget) {
                            if (camera.renderTarget.generateMipmap()) {
                                renderState.clearState(); // Fixed there is no texture bound to the unit 0 error.
                            }
                        }
                    }
                    else {
                        for (var _b = 0, _c = camera.postQueues; _b < _c.length; _b++) {
                            var item = _c[_b];
                            // TODO
                        }
                    }
                }
            }
            else {
                renderState.clear(true, true, egret3d.Color.BLACK);
            }
            egret3d.Performance.endCounter("render");
        };
        return WebGLRenderSystem;
    }(paper.BaseSystem));
    egret3d.WebGLRenderSystem = WebGLRenderSystem;
    __reflect(WebGLRenderSystem.prototype, "egret3d.WebGLRenderSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    //最大允许合并的顶点数，超过就是下一批次
    egret3d.MAX_VERTEX_COUNT_PER_BUFFER = 50000;
    //
    var helpVec3_1 = egret3d.Vector3.create();
    var helpVec3_2 = egret3d.Vector3.create();
    var helpInverseMatrix = egret3d.Matrix4.create();
    //缓存已经校验过的对象，用于过滤
    var cacheInstances = [];
    var beforeCombineCount = 0;
    /**
     * 尝试对场景内所有静态对象合并
     */
    function autoCombine(scene) {
        combine(scene.gameObjects);
    }
    egret3d.autoCombine = autoCombine;
    /**
     * 尝试合并静态对象列表。
     * @param instances
     * @param root
     */
    function combine(instances) {
        cacheInstances.length = 0;
        beforeCombineCount = 0;
        var allCombines = {};
        //1.通过材质填充合并列表
        for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
            var obj = instances_1[_i];
            _colletCombineInstance(obj, allCombines);
        }
        console.log("合并前:" + beforeCombineCount);
        var afterCombineCount = 0;
        //2.相同材质的合并
        for (var key in allCombines) {
            var combines = allCombines[key];
            for (var _a = 0, combines_1 = combines; _a < combines_1.length; _a++) {
                var combine_1 = combines_1[_a];
                _combineInstance(combine_1);
                afterCombineCount++;
            }
        }
        console.log("合并后:" + afterCombineCount + "节省:" + (beforeCombineCount - afterCombineCount));
        cacheInstances.length = 0;
    }
    egret3d.combine = combine;
    /**
     * TODO(root暂时不支持)尝试合并静态对象列表，如果root有值，合并后可以操作root对象的transform，来实现整体移动，旋转，缩放；反之，相同材质列表的第一个对象为合并节点。
     * @param instances
     * @param root
     */
    function _colletCombineInstance(target, out, root) {
        //过滤重复的对象
        if (cacheInstances.indexOf(target.uuid) >= 0) {
            return;
        }
        cacheInstances.push(target.uuid);
        //
        for (var _i = 0, _a = target.transform.children; _i < _a.length; _i++) {
            var child = _a[_i];
            if (child) {
                _colletCombineInstance(child.gameObject, out, root);
            }
        }
        //不是静态的不考虑合并
        if (!target.isStatic) {
            return;
        }
        var meshFilter = target.getComponent(egret3d.MeshFilter);
        var meshRenderer = target.getComponent(egret3d.MeshRenderer);
        //合并条件判断
        if (!meshFilter || !meshFilter.mesh || !meshRenderer || !meshRenderer.materials || meshRenderer.materials.length < 1) {
            return;
        }
        beforeCombineCount++;
        var materials = meshRenderer.materials;
        var meshData = meshFilter.mesh;
        //合并筛选的条件:光照贴图_材质0_材质1... ：0_234_532...
        var key = meshRenderer.lightmapIndex + "_";
        materials.forEach(function (element) { key = key + "_" + element.uuid; });
        if (!out[key]) {
            out[key] = [];
            out[key].push(new CombineInstance());
        }
        var combines = out[key];
        //找相同材质合成列表的最后一个，如果最后一个顶点超过允许最大数了，就新建一个，下个批次处理
        var combine = combines[combines.length - 1];
        if (combine.vertexCount + meshData.vertexCount > egret3d.MAX_VERTEX_COUNT_PER_BUFFER) {
            combine = new CombineInstance();
            out[key].push(combine);
        }
        //合并节点以传入的对象为优先，如果没有传入，那么以每种材质的第一个对象为准
        if (!combine.root) {
            combine.root = root ? root : target;
            combine.lightmapIndex = meshRenderer.lightmapIndex;
        }
        //适配最大格式
        var primitives = meshData.glTFMesh.primitives;
        for (var i = 0; i < primitives.length; i++) {
            var primitive = primitives[i];
            for (var attStr in primitives[i].attributes) {
                var attrType = attStr;
                if (!combine.meshAttribute[attrType]) {
                    combine.vertexBufferSize += meshData.getAccessorTypeCount(meshData.getAccessor(primitive.attributes[attStr]).type);
                }
                combine.meshAttribute[attrType] = attrType;
            }
            combine.indexBufferTotalSize += meshData.getBufferLength(meshData.getAccessor(primitive.indices)) / Uint16Array.BYTES_PER_ELEMENT;
        }
        //
        combine.vertexCount += meshData.vertexCount;
        combine.instances.push(target);
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     */
    function _combineInstance(combineInstance) {
        var combineMesh = _combineMesh(combineInstance);
        var combineRoot = combineInstance.root;
        //把合成好的放入root中，重新绘制
        var meshFilter = combineRoot.getComponent(egret3d.MeshFilter);
        meshFilter.mesh = combineMesh;
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     * @param root
     */
    function _combineMesh(combineInstance) {
        //
        helpInverseMatrix.inverse(combineInstance.root.transform.getWorldMatrix());
        var meshAttribute = combineInstance.meshAttribute;
        var newAttribute = [];
        var tempIndexBuffers = [];
        var tempVertexBuffers = {};
        for (var key in meshAttribute) {
            tempVertexBuffers[key] = [];
            newAttribute.push(key);
        }
        //
        var startIndex = 0;
        var endIndex = 0;
        for (var _i = 0, _a = combineInstance.instances; _i < _a.length; _i++) {
            var instance = _a[_i];
            var meshFilter = instance.getComponent(egret3d.MeshFilter);
            var meshRenderer = instance.getComponent(egret3d.MeshRenderer);
            var worldMatrix = instance.transform.getWorldMatrix();
            var mesh = meshFilter.mesh;
            var primitives = mesh.glTFMesh.primitives;
            //共享一个的buffer，vbo只处理一个submesh就可以了
            var combineOnce = true;
            for (var i = 0; i < primitives.length; i++) {
                var primitive = primitives[i];
                if (combineOnce) {
                    combineOnce = false;
                    var orginVertexCount = mesh.vertexCount;
                    var orginAttributes = primitives[i].attributes;
                    var positionBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.POSITION));
                    //vertexBuffers
                    for (var j = 0; j < positionBuffer.length; j += 3) {
                        helpVec3_1.x = positionBuffer[j + 0];
                        helpVec3_1.y = positionBuffer[j + 1];
                        helpVec3_1.z = positionBuffer[j + 2];
                        //转换成世界坐标后在转换为合并节点的本地坐标
                        worldMatrix.transformVector3(helpVec3_1, helpVec3_2);
                        helpInverseMatrix.transformVector3(helpVec3_2, helpVec3_1);
                        //
                        tempVertexBuffers["POSITION" /* POSITION */].push(helpVec3_1.x, helpVec3_1.y, helpVec3_1.z);
                    }
                    //
                    if (meshAttribute["NORMAL" /* NORMAL */]) {
                        if (orginAttributes.NORMAL) {
                            var normalBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.NORMAL));
                            var target = tempVertexBuffers["NORMAL" /* NORMAL */];
                            var count = normalBuffer.length;
                            var startIndex_1 = target.length;
                            target.length += count;
                            for (var j = 0; j < count; j += 3) {
                                helpVec3_1.x = normalBuffer[j + 0];
                                helpVec3_1.y = normalBuffer[j + 1];
                                helpVec3_1.z = normalBuffer[j + 2];
                                worldMatrix.transformNormal(helpVec3_1);
                                helpInverseMatrix.transformNormal(helpVec3_1);
                                helpVec3_1.normalize();
                                target[startIndex_1 + j] = helpVec3_1.x;
                                target[startIndex_1 + j + 1] = helpVec3_1.y;
                                target[startIndex_1 + j + 2] = helpVec3_1.z;
                            }
                            // _copyAccessorBufferArray(glTFAsset, orginAttributes.NORMAL, tempVertexBuffers[gltf.MeshAttributeType.NORMAL]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["NORMAL" /* NORMAL */], orginVertexCount, [0, 0, 0]);
                        }
                    }
                    if (meshAttribute["TANGENT" /* TANGENT */]) {
                        if (orginAttributes.TANGENT) {
                            var tangentBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.TANGENT));
                            var target = tempVertexBuffers["TANGENT" /* TANGENT */];
                            var count = tangentBuffer.length;
                            var startIndex_2 = target.length;
                            target.length += count;
                            for (var j = 0; j < count; j += 4) {
                                helpVec3_1.x = tangentBuffer[j + 0];
                                helpVec3_1.y = tangentBuffer[j + 1];
                                helpVec3_1.z = tangentBuffer[j + 2];
                                worldMatrix.transformNormal(helpVec3_1);
                                helpInverseMatrix.transformNormal(helpVec3_1);
                                helpVec3_1.normalize();
                                target[startIndex_2 + j] = helpVec3_1.x;
                                target[startIndex_2 + j + 1] = helpVec3_1.y;
                                target[startIndex_2 + j + 2] = helpVec3_1.z;
                                target[startIndex_2 + j + 3] = tangentBuffer[j + 3];
                            }
                            // _copyAccessorBufferArray(glTFAsset, orginAttributes.TANGENT, tempVertexBuffers[gltf.MeshAttributeType.TANGENT]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["TANGENT" /* TANGENT */], orginVertexCount, [0, 0, 0, 1]);
                        }
                    }
                    if (meshAttribute["COLOR_0" /* COLOR_0 */]) {
                        if (orginAttributes.COLOR_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.COLOR_0, tempVertexBuffers["COLOR_0" /* COLOR_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["COLOR_0" /* COLOR_0 */], orginVertexCount, [1, 1, 1, 1]);
                        }
                    }
                    if (meshAttribute["TEXCOORD_0" /* TEXCOORD_0 */]) {
                        if (orginAttributes.TEXCOORD_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_0, tempVertexBuffers["TEXCOORD_0" /* TEXCOORD_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["TEXCOORD_0" /* TEXCOORD_0 */], orginVertexCount, [0, 0]);
                        }
                    }
                    if (meshAttribute["TEXCOORD_1" /* TEXCOORD_1 */]) {
                        if (combineInstance.lightmapIndex >= 0) {
                            // //如果有lightmap,那么将被合并的uv1的坐标转换为root下的坐标,有可能uv1没有，那用uv0来算
                            // const uvBuffer = orginAttributes.TEXCOORD_1 ?
                            //     mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.TEXCOORD_1)) as Float32Array :
                            //     mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.TEXCOORD_0!)) as Float32Array;
                            // //
                            // for (let j = 0; j < uvBuffer.length; j += 2) {
                            //     let u = uvBuffer[j + 0];
                            //     let v = uvBuffer[j + 1];
                            //     // u = ((u * orginLightmapScaleOffset[0] + orginLightmapScaleOffset[2]) - lightmapScaleOffset[2]) / lightmapScaleOffset[0];
                            //     // v = ((v * orginLightmapScaleOffset[1] - orginLightmapScaleOffset[1] - orginLightmapScaleOffset[3]) + lightmapScaleOffset[3] + lightmapScaleOffset[1]) / lightmapScaleOffset[1];
                            //     tempVertexBuffers[gltf.MeshAttributeType.TEXCOORD_1].push(u, v);
                            // }
                            if (orginAttributes.TEXCOORD_1 !== undefined) {
                                _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_1, tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */]);
                            }
                            else {
                                _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_0, tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */]);
                            }
                        }
                        else {
                            if (orginAttributes.TEXCOORD_1 !== undefined) {
                                _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_1, tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */]);
                            }
                            else {
                                _fillDefaultArray(tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */], orginVertexCount, [0, 0]);
                            }
                        }
                    }
                    if (meshAttribute["JOINTS_0" /* JOINTS_0 */]) {
                        if (orginAttributes.JOINTS_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.JOINTS_0, tempVertexBuffers["JOINTS_0" /* JOINTS_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["JOINTS_0" /* JOINTS_0 */], orginVertexCount, [0, 0, 0, 0]);
                        }
                    }
                    if (meshAttribute["WEIGHTS_0" /* WEIGHTS_0 */]) {
                        if (orginAttributes.WEIGHTS_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.WEIGHTS_0, tempVertexBuffers["WEIGHTS_0" /* WEIGHTS_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["WEIGHTS_0" /* WEIGHTS_0 */], orginVertexCount, [1, 0, 0, 0]);
                        }
                    }
                    if (meshAttribute["COLOR_1" /* COLOR_1 */]) {
                        if (orginAttributes.COLOR_1) {
                            _copyAccessorBufferArray(mesh, orginAttributes.COLOR_1, tempVertexBuffers["COLOR_1" /* COLOR_1 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["COLOR_1" /* COLOR_1 */], orginVertexCount, [1, 1, 1, 1]);
                        }
                    }
                }
                var subIndexBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(primitive.indices));
                // //indexBuffers
                if (!tempIndexBuffers[i]) {
                    tempIndexBuffers[i] = [];
                }
                for (var j = 0; j < subIndexBuffer.length; j++) {
                    var index = subIndexBuffer[j] + startIndex;
                    tempIndexBuffers[i].push(index);
                    endIndex = index > endIndex ? index : endIndex;
                }
            }
            startIndex = endIndex + 1;
            meshFilter.mesh = null;
        }
        var combineMesh = new egret3d.Mesh(combineInstance.vertexCount, combineInstance.indexBufferTotalSize, newAttribute, undefined, 35048 /* Dynamic */);
        var newVertexBuffers = combineMesh.buffers[0];
        var newIndexBuffers = combineMesh.buffers[1];
        var iv = 0;
        for (var key in tempVertexBuffers) {
            var arr = tempVertexBuffers[key];
            for (var _b = 0, arr_1 = arr; _b < arr_1.length; _b++) {
                var v = arr_1[_b];
                newVertexBuffers[iv++] = v;
            }
        }
        var ii = 0;
        for (var key in tempIndexBuffers) {
            var arr = tempIndexBuffers[key];
            for (var _c = 0, arr_2 = arr; _c < arr_2.length; _c++) {
                var v = arr_2[_c];
                newIndexBuffers[ii++] = v;
            }
        }
        var indicesCount = 0;
        for (var i = 0; i < tempIndexBuffers.length; i++) {
            var subLen = tempIndexBuffers[i].length;
            //第一个submesh在构造函数中已经添加，需要手动添加后续的
            combineMesh.addSubMesh(indicesCount, subLen, i);
            indicesCount += subLen;
        }
        return combineMesh;
    }
    function _copyAccessorBufferArray(gltf, accessor, target) {
        var buffer = gltf.createTypeArrayFromAccessor(gltf.getAccessor(accessor));
        var count = buffer.length;
        var startIndex = target.length;
        target.length += count;
        for (var i = 0; i < count; i++) {
            target[startIndex + i] = buffer[i];
        }
    }
    function _fillDefaultArray(target, count, defaultValue) {
        var startIndex = target.length;
        var defaultValueCount = defaultValue.length;
        target.length += count * defaultValueCount;
        for (var i = 0; i < count; i++) {
            for (var j = 0; j < defaultValueCount; j++) {
                target[startIndex++] = defaultValue[j];
            }
        }
    }
    var CombineInstance = (function () {
        function CombineInstance() {
            this.vertexCount = 0;
            this.vertexBufferSize = 0;
            this.indexBufferTotalSize = 0;
            this.lightmapIndex = -1;
            this.meshAttribute = {};
            this.root = null;
            this.instances = [];
        }
        return CombineInstance;
    }());
    __reflect(CombineInstance.prototype, "CombineInstance");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var PerformanceType;
    (function (PerformanceType) {
        PerformanceType["All"] = "all";
    })(PerformanceType = egret3d.PerformanceType || (egret3d.PerformanceType = {}));
    /**
     * Performance
     * 数据收集
     */
    var Performance = (function () {
        function Performance() {
        }
        Performance.getEntity = function (key) {
            return this._entities[key];
        };
        Performance.getFPS = function () {
            var entity = this.getEntity("fps");
            return (entity && entity.averageDelta) ? Math.floor(1000 / entity.averageDelta) : 0;
        };
        Performance.updateFPS = function () {
            if (!this.enable) {
                return;
            }
            this.endCounter("fps");
            this.startCounter("fps", 60);
        };
        Performance._getNow = function () {
            if (window.performance) {
                return window.performance.now();
            }
            return new Date().getTime();
        };
        Performance.startCounter = function (key, averageRange) {
            if (averageRange === void 0) { averageRange = 1; }
            if (!this.enable) {
                return;
            }
            var entity = this._entities[key];
            if (!entity) {
                entity = {
                    start: 0,
                    end: 0,
                    delta: 0,
                    _cache: [],
                    averageRange: 1,
                    averageDelta: 0
                };
                this._entities[key] = entity;
            }
            entity.start = this._getNow();
            entity.averageRange = averageRange;
        };
        Performance.endCounter = function (key) {
            if (!this.enable) {
                return;
            }
            var entity = this._entities[key];
            if (entity) {
                entity.end = this._getNow();
                entity.delta = entity.end - entity.start;
                if (entity.averageRange > 1) {
                    entity._cache.push(entity.delta);
                    var length = entity._cache.length;
                    if (length >= entity.averageRange) {
                        if (length > entity.averageRange) {
                            entity._cache.shift();
                            length--;
                        }
                        var sum = 0;
                        for (var i = 0; i < length; i++) {
                            sum += entity._cache[i];
                        }
                        entity.averageDelta = sum / length;
                    }
                }
            }
        };
        Performance._entities = {};
        Performance.enable = false;
        return Performance;
    }());
    egret3d.Performance = Performance;
    __reflect(Performance.prototype, "egret3d.Performance");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Profile = (function () {
        function Profile() {
        }
        Profile._getNow = function () {
            // if (window.performance) {
            //     return window.performance.now();
            // }
            // return Date.now() * 0.001;
            return new Date().getTime();
        };
        Profile._print = function (list) {
            var totalTime = 0.0;
            for (var _a = 0, list_1 = list; _a < list_1.length; _a++) {
                var item = list_1[_a];
                totalTime += item.time;
            }
            console.log("------------------------");
            for (var _b = 0, list_2 = list; _b < list_2.length; _b++) {
                var item = list_2[_b];
                console.log(item.key + ":用时" + item.time + "平均:" + (item.time / item.count) + "最大值:" + item.maxTime + " 权重:" + (Math.round(item.time / totalTime * 100)) + "%");
            }
        };
        Profile.clear = function () {
            this.profileList.keys.length = 0;
            this.profileList.values.length = 0;
        };
        Profile.startTime = function (key, group) {
            if (group === void 0) { group = 0; }
            if (!this.debug) {
                return;
            }
            var index = this.profileList.keys.indexOf(key);
            if (index < 0) {
                this.profileList.keys.push(key);
                index = this.profileList.values.length;
                this.profileList.values.push({ key: key, count: 0, startTime: 0, time: 0, group: group, maxTime: 0 });
            }
            var item = this.profileList.values[index];
            item.count++;
            item.startTime = this._getNow();
        };
        Profile.endTime = function (key) {
            if (!this.debug) {
                return;
            }
            var index = this.profileList.keys.indexOf(key);
            if (index < 0) {
                console.log("invalid key error.", this);
            }
            else {
                var item = this.profileList.values[index];
                var d = this._getNow() - item.startTime;
                item.time += d;
                item.maxTime = item.maxTime > d ? item.maxTime : d;
            }
        };
        Profile.printAll = function () {
            if (!this.debug) {
                return;
            }
            var groups = {};
            for (var _a = 0, _b = this.profileList.values; _a < _b.length; _a++) {
                var item = _b[_a];
                if (!groups[item.group]) {
                    groups[item.group] = [];
                }
                groups[item.group].push(item);
            }
            for (var key in groups) {
                this._print(groups[key]);
            }
        };
        Profile.print = function (group) {
            if (group === void 0) { group = 0; }
            if (!this.debug) {
                return;
            }
            var list = [];
            for (var _a = 0, _b = this.profileList.values; _a < _b.length; _a++) {
                var item = _b[_a];
                if (item.group === group) {
                    list.push(item);
                }
            }
            this._print(list);
        };
        Profile.test = function () {
            var list0 = [];
            var map = {};
            for (var i = 0; i < 1000; i++) {
                list0.push(i);
                map[i] = i;
            }
            var old = this._getNow();
            for (var _a = 0, list0_1 = list0; _a < list0_1.length; _a++) {
                var _i = list0_1[_a];
                console.log("list:");
            }
            console.log("list of用时:" + (this._getNow() - old));
            old = this._getNow();
            for (var _i in list0) {
                console.log("list:");
            }
            console.log("list in用时:" + (this._getNow() - old));
            old = this._getNow();
            for (var _i in map) {
                console.log("map:");
            }
            console.log("map用时:" + (this._getNow() - old));
        };
        Profile.debug = false;
        Profile.profileList = { keys: [], values: [] };
        return Profile;
    }());
    egret3d.Profile = Profile;
    __reflect(Profile.prototype, "egret3d.Profile");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Triangle = (function (_super) {
        __extends(Triangle, _super);
        /**
         * 请使用 `egret3d.Triangle.create()` 创建实例。
         * @see egret3d.Triangle.create()
         */
        function Triangle() {
            var _this = _super.call(this) || this;
            _this.a = egret3d.Vector3.create();
            _this.b = egret3d.Vector3.create();
            _this.c = egret3d.Vector3.create();
            return _this;
        }
        Triangle.create = function (a, b, c) {
            if (a === void 0) { a = egret3d.Vector3.ZERO; }
            if (b === void 0) { b = egret3d.Vector3.ZERO; }
            if (c === void 0) { c = egret3d.Vector3.ZERO; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(a, b, c);
                instance._released = false;
                return instance;
            }
            return new Triangle().set(a, b, c);
        };
        Triangle.prototype.serialize = function () {
            return [
                this.a.x, this.a.y, this.a.z,
                this.b.x, this.b.y, this.b.z,
                this.c.x, this.c.y, this.c.z,
            ];
        };
        Triangle.prototype.deserialize = function (element) {
            return this.fromArray(element);
        };
        Triangle.prototype.copy = function (value) {
            return this.set(value.a, value.b, value.c);
        };
        Triangle.prototype.clone = function () {
            return Triangle.create(this.a, this.b, this.c);
        };
        Triangle.prototype.set = function (a, b, c) {
            if (a === void 0) { a = egret3d.Vector3.ZERO; }
            if (b === void 0) { b = egret3d.Vector3.ZERO; }
            if (c === void 0) { c = egret3d.Vector3.ZERO; }
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this;
        };
        Triangle.prototype.fromArray = function (value, offsetA, offsetB, offsetC) {
            if (offsetA === void 0) { offsetA = 0; }
            if (offsetB === void 0) { offsetB = -1; }
            if (offsetC === void 0) { offsetC = -1; }
            this.a.fromArray(value, offsetA);
            this.b.fromArray(value, offsetB >= 0 ? offsetB : offsetA + 3);
            this.c.fromArray(value, offsetC >= 0 ? offsetC : offsetA + 6);
        };
        Triangle.prototype.getCenter = function (value) {
            return value.add(this.a, this.b).add(this.c).multiplyScalar(1.0 / 3.0);
        };
        Triangle.prototype.getNormal = function (value) {
            return egret3d.getNormal(this.a, this.b, this.c, value);
        };
        Triangle.prototype.getArea = function () {
            egret3d.helpVector3A.subtract(this.c, this.b);
            egret3d.helpVector3B.subtract(this.a, this.b);
            return egret3d.helpVector3A.cross(egret3d.helpVector3B).length * 0.5;
        };
        Triangle._instances = [];
        return Triangle;
    }(paper.BaseRelease));
    egret3d.Triangle = Triangle;
    __reflect(Triangle.prototype, "egret3d.Triangle", ["paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
/// <reference path="./EventDispatcher.ts" />
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 编辑器事件
         */
        var EditorEvent = (function (_super) {
            __extends(EditorEvent, _super);
            function EditorEvent(type, data) {
                return _super.call(this, type, data) || this;
            }
            EditorEvent.CHANGE_SCENE = "changeScene";
            return EditorEvent;
        }(editor.BaseEvent));
        editor.EditorEvent = EditorEvent;
        __reflect(EditorEvent.prototype, "paper.editor.EditorEvent");
        /**
         * 编辑器
         **/
        var Editor = (function () {
            function Editor() {
            }
            /**初始化 */
            Editor.init = function () {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                this.eventDispatcher = new editor.EventDispatcher();
                                //覆盖生成 uuid 的方式。
                                paper.createUUID = editor.generateUuid;
                                //初始化编辑环境
                                this.initEditEnvironment();
                                //允许重新加载
                                RES.FEATURE_FLAG.FIX_DUPLICATE_LOAD = 0;
                                //初始化资源
                                return [4 /*yield*/, RES.loadConfig("resource/default.res.json", "resource/")];
                            case 1:
                                //初始化资源
                                _a.sent();
                                //初始化编辑场景
                                this.editorSceneModel = new editor.EditorSceneModel();
                                this.editorSceneModel.init();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            Object.defineProperty(Editor, "activeEditorModel", {
                /**
                 * 当前激活的编辑模型
                 */
                get: function () {
                    return this._activeEditorModel;
                },
                enumerable: true,
                configurable: true
            });
            //设置激活模型
            Editor.setActiveModel = function (model) {
                this.activeScene(model.scene);
                this._activeEditorModel = model;
                this.editorSceneModel.editorModel = model;
                this.dispatchEvent(new EditorEvent(EditorEvent.CHANGE_SCENE));
            };
            Editor.activeScene = function (scene) {
                if (paper.Application.sceneManager.activeScene) {
                    var objs_1 = paper.Application.sceneManager.activeScene.getRootGameObjects();
                    objs_1.forEach(function (obj) {
                        obj.activeSelf = false;
                    });
                }
                paper.Application.sceneManager.activeScene = scene;
                var objs = paper.Application.sceneManager.activeScene.getRootGameObjects();
                objs.forEach(function (obj) {
                    obj.activeSelf = true;
                });
            };
            /**
             * 编辑场景
             * @param sceneUrl 场景资源URL
             */
            Editor.editScene = function (sceneUrl) {
                return __awaiter(this, void 0, void 0, function () {
                    var rawScene, scene, sceneEditorModel;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, RES.getResAsync(sceneUrl)];
                            case 1:
                                rawScene = _a.sent();
                                if (rawScene) {
                                    if (this.activeEditorModel) {
                                        this.activeEditorModel.scene.destroy();
                                    }
                                    scene = rawScene.createInstance(true);
                                    sceneEditorModel = new editor.EditorModel();
                                    sceneEditorModel.init(scene, 'scene', sceneUrl);
                                    this.setActiveModel(sceneEditorModel);
                                    this.currentEditInfo = { url: sceneUrl, type: 'scene' };
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * 编辑预置体
             * @param prefabUrl 预置体资源URL
             */
            Editor.editPrefab = function (prefabUrl) {
                return __awaiter(this, void 0, void 0, function () {
                    var prefab, scene, prefabInstance, prefabEditorModel_1, clearPrefabInfo_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, RES.getResAsync(prefabUrl)];
                            case 1:
                                prefab = _a.sent();
                                if (prefab) {
                                    if (this.activeEditorModel) {
                                        this.activeEditorModel.scene.destroy();
                                    }
                                    scene = paper.Scene.createEmpty('prefabEditScene', false);
                                    prefabInstance = prefab.createInstance(scene, true);
                                    prefabEditorModel_1 = new editor.EditorModel();
                                    prefabEditorModel_1.init(scene, 'prefab', prefabUrl);
                                    clearPrefabInfo_1 = function (obj) {
                                        obj.extras = {};
                                        for (var _i = 0, _a = obj.components; _i < _a.length; _i++) {
                                            var comp = _a[_i];
                                            comp.extras = {};
                                        }
                                        for (var i = 0; i < obj.transform.children.length; i++) {
                                            var child = obj.transform.children[i].gameObject;
                                            if (prefabEditorModel_1.isPrefabChild(child))
                                                clearPrefabInfo_1(child);
                                        }
                                    };
                                    clearPrefabInfo_1(prefabInstance);
                                    this.setActiveModel(prefabEditorModel_1);
                                    this.currentEditInfo = { url: prefabUrl, type: 'prefab' };
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * 刷新
             */
            Editor.refresh = function () {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (this.activeEditorModel) {
                                    this.activeEditorModel.scene.destroy();
                                }
                                //初始化资源
                                return [4 /*yield*/, RES.loadConfig("resource/default.res.json", "resource/")];
                            case 1:
                                //初始化资源
                                _a.sent();
                                if (this.currentEditInfo) {
                                    switch (this.currentEditInfo.type) {
                                        case 'scene':
                                            this.editScene(this.currentEditInfo.url);
                                            break;
                                        case 'prefab':
                                            this.editPrefab(this.currentEditInfo.url);
                                            break;
                                    }
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * 撤销
             */
            Editor.undo = function () {
                if (this.activeEditorModel)
                    this.activeEditorModel.history.back();
            };
            /**
             * 重做
             */
            Editor.redo = function () {
                if (this.activeEditorModel)
                    this.activeEditorModel.history.forward();
            };
            Editor.deserializeHistory = function (data) {
                this.activeEditorModel.history.deserialize(data);
            };
            Editor.serializeHistory = function () {
                var historyData = this.activeEditorModel.history.serialize();
                return JSON.stringify(historyData);
            };
            Editor.addEventListener = function (type, fun, thisObj, level) {
                if (level === void 0) { level = 0; }
                this.eventDispatcher.addEventListener(type, fun, thisObj, level);
            };
            Editor.removeEventListener = function (type, fun, thisObj) {
                this.eventDispatcher.removeEventListener(type, fun, thisObj);
            };
            Editor.dispatchEvent = function (event) {
                this.eventDispatcher.dispatchEvent(event);
            };
            Editor.initEditEnvironment = function () {
                egret3d.runEgret({
                    antialias: false,
                    playerMode: 2 /* Editor */,
                });
            };
            return Editor;
        }());
        editor.Editor = Editor;
        __reflect(Editor.prototype, "paper.editor.Editor");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 平面。
     */
    var Plane = (function (_super) {
        __extends(Plane, _super);
        /**
         * 请使用 `egret3d.Plane.create()` 创建实例。
         * @see egret3d.Plane.create()
         */
        function Plane() {
            var _this = _super.call(this) || this;
            /**
             *
             */
            _this.constant = 0.0;
            /**
             *
             */
            _this.normal = egret3d.Vector3.create();
            return _this;
        }
        /**
         *
         */
        Plane.create = function (normal, constant) {
            if (normal === void 0) { normal = egret3d.Vector3.ZERO; }
            if (constant === void 0) { constant = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(normal, constant);
                instance._released = false;
                return instance;
            }
            return new Plane().set(normal, constant);
        };
        Plane.prototype.serialize = function () {
            return [this.normal.x, this.normal.y, this.normal.z, this.constant];
        };
        Plane.prototype.deserialize = function (value) {
            this.constant = value[3];
            this.normal.fromArray(value);
            return this;
        };
        Plane.prototype.clone = function () {
            return Plane.create(this.normal, this.constant);
        };
        Plane.prototype.copy = function (value) {
            return this.set(value.normal, value.constant);
        };
        Plane.prototype.set = function (normal, constant) {
            this.constant = constant;
            this.normal.copy(normal);
            return this;
        };
        Plane.prototype.fromPoint = function (value, normal) {
            if (normal === void 0) { normal = egret3d.Vector3.UP; }
            this.constant = -egret3d.helpVector3A.dot(normal, value);
            this.normal.copy(normal);
            return this;
        };
        Plane.prototype.fromPoints = function (valueA, valueB, valueC) {
            var normal = egret3d.helpVector3A.subtract(valueC, valueB).cross(egret3d.helpVector3B.subtract(valueA, valueB)).normalize();
            this.fromPoint(valueA, normal);
            return this;
        };
        Plane.prototype.normalize = function (source) {
            if (!source) {
                source = this;
            }
            var inverseNormalLength = source.normal.length;
            this.constant = source.constant * (1.0 / inverseNormalLength);
            this.normal.multiplyScalar(inverseNormalLength, source.normal);
            return this;
        };
        Plane.prototype.negate = function (source) {
            if (!source) {
                source = this;
            }
            this.constant = -source.constant;
            this.normal.negate(source.normal);
            return this;
        };
        Plane.prototype.getDistance = function (value) {
            return this.normal.dot(value) + this.constant;
        };
        Plane.prototype.raycast = function (ray, raycastInfo) {
            var t = ray.getDistanceToPlane(this);
            if (t > 0.0) {
                if (raycastInfo) {
                    raycastInfo.distance = t;
                    ray.at(t, raycastInfo.position);
                }
                return true;
            }
            return false;
        };
        Plane._instances = [];
        return Plane;
    }(paper.BaseRelease));
    egret3d.Plane = Plane;
    __reflect(Plane.prototype, "egret3d.Plane", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
/// <reference path="./EventDispatcher.ts" />
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        editor.context = new editor.EventDispatcher();
        var selectItemType;
        (function (selectItemType) {
            selectItemType[selectItemType["GAMEOBJECT"] = 0] = "GAMEOBJECT";
            selectItemType[selectItemType["ASSET"] = 1] = "ASSET";
        })(selectItemType = editor.selectItemType || (editor.selectItemType = {}));
        /**
         * 编辑模型事件
         */
        var EditorModelEvent = (function (_super) {
            __extends(EditorModelEvent, _super);
            function EditorModelEvent(type, data) {
                return _super.call(this, type, data) || this;
            }
            EditorModelEvent.ADD_GAMEOBJECTS = "addGameObject";
            EditorModelEvent.DELETE_GAMEOBJECTS = "deleteGameObject";
            EditorModelEvent.SELECT_GAMEOBJECTS = "selectGame";
            EditorModelEvent.CHANGE_DIRTY = 'change_dirty';
            EditorModelEvent.CHANGE_PROPERTY = "changeProperty";
            EditorModelEvent.CHANGE_EDIT_MODE = "changeEditMode";
            EditorModelEvent.CHANGE_EDIT_TYPE = "changeEditType";
            EditorModelEvent.ADD_COMPONENT = "addComponent";
            EditorModelEvent.REMOVE_COMPONENT = "removeComponent";
            EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY = "updateGameObjectsHierarchy";
            EditorModelEvent.SAVE_ASSET = "saveAsset";
            return EditorModelEvent;
        }(editor.BaseEvent));
        editor.EditorModelEvent = EditorModelEvent;
        __reflect(EditorModelEvent.prototype, "paper.editor.EditorModelEvent");
        var ModifyObjectType;
        (function (ModifyObjectType) {
            ModifyObjectType[ModifyObjectType["GAMEOBJECT"] = 0] = "GAMEOBJECT";
            ModifyObjectType[ModifyObjectType["BASECOMPONENT"] = 1] = "BASECOMPONENT";
        })(ModifyObjectType = editor.ModifyObjectType || (editor.ModifyObjectType = {}));
        /**
         * 编辑模型
         */
        var EditorModel = (function (_super) {
            __extends(EditorModel, _super);
            function EditorModel() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._dirty = false;
                _this._cacheIds = [];
                return _this;
            }
            Object.defineProperty(EditorModel.prototype, "history", {
                get: function () {
                    return this._history;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorModel.prototype, "scene", {
                get: function () {
                    return this._scene;
                },
                set: function (value) {
                    this._scene = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorModel.prototype, "contentType", {
                get: function () {
                    return this._contentType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorModel.prototype, "contentUrl", {
                get: function () {
                    return this._contentUrl;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorModel.prototype, "dirty", {
                get: function () {
                    return this._dirty;
                },
                set: function (v) {
                    if (this._dirty !== v) {
                        this._dirty = v;
                        this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_DIRTY));
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
             * 初始化
             * @param history
             */
            EditorModel.prototype.init = function (scene, contentType, contentUrl) {
                this._history = new editor.History();
                this._scene = scene;
                this._contentType = contentType;
                this._contentUrl = contentUrl;
            };
            EditorModel.prototype.addState = function (state) {
                if (state) {
                    state.editorModel = this;
                    this.history.add(state);
                }
            };
            EditorModel.prototype.getEditType = function (propName, target) {
                var editInfoList = editor.getEditInfo(target);
                for (var index = 0; index < editInfoList.length; index++) {
                    var element = editInfoList[index];
                    if (element.name === propName) {
                        return element.editType;
                    }
                }
                return null;
            };
            EditorModel.prototype.setTransformProperty = function (propName, propOldValue, propNewValue, target) {
                var valueEditType = this.getEditType(propName, target);
                if (valueEditType !== null) {
                    var newPropertyData = {
                        propName: propName,
                        copyValue: this.serializeProperty(propNewValue, valueEditType),
                        valueEditType: valueEditType
                    };
                    var prePropertyData = {
                        propName: propName,
                        copyValue: this.serializeProperty(propOldValue, valueEditType),
                        valueEditType: valueEditType
                    };
                    this.createModifyComponent(target.gameObject.uuid, target.uuid, [newPropertyData], [prePropertyData]);
                }
            };
            EditorModel.prototype.createModifyGameObjectPropertyState = function (gameObjectUUid, newValueList, preValueCopylist) {
                var state = editor.ModifyGameObjectPropertyState.create(gameObjectUUid, newValueList, preValueCopylist);
                this.addState(state);
            };
            EditorModel.prototype.createModifyComponent = function (gameObjectUUid, componentUUid, newValueList, preValueCopylist) {
                var state = editor.ModifyComponentPropertyState.create(gameObjectUUid, componentUUid, newValueList, preValueCopylist);
                this.addState(state);
            };
            EditorModel.prototype.createPrefabState = function (prefab, parent) {
                var state = editor.CreatePrefabState.create(prefab, parent);
                this.addState(state);
            };
            EditorModel.prototype.serializeProperty = function (value, editType) {
                switch (editType) {
                    case 0 /* UINT */:
                    case 1 /* INT */:
                    case 2 /* FLOAT */:
                    case 3 /* TEXT */:
                    case 4 /* CHECKBOX */:
                        return value;
                    case 5 /* VECTOR2 */:
                    case 6 /* VECTOR3 */:
                    case 7 /* VECTOR4 */:
                    case 8 /* QUATERNION */:
                    case 9 /* COLOR */:
                    case 11 /* RECT */:
                        var className = egret.getQualifiedClassName(value);
                        var serializeData = value.serialize(value);
                        return { className: className, serializeData: serializeData };
                    case 19 /* SHADER */:
                        return value.name;
                    case 10 /* LIST */:
                        return value;
                    case 13 /* MATERIAL_ARRAY */:
                        var data = value.map(function (item) {
                            return { name: item.name, url: item.name };
                        });
                        return data;
                    case 18 /* MESH */:
                        if (!value)
                            return '';
                        var url = value.name;
                        return url;
                    case 12 /* MATERIAL */:
                    case 14 /* GAMEOBJECT */:
                    case 15 /* TRANSFROM */:
                    case 17 /* SOUND */:
                    case 20 /* ARRAY */:
                        //TODO
                        console.error("not supported!");
                        break;
                    default:
                        break;
                }
            };
            EditorModel.prototype.deserializeProperty = function (serializeData, editType) {
                switch (editType) {
                    case 0 /* UINT */:
                    case 1 /* INT */:
                    case 2 /* FLOAT */:
                    case 3 /* TEXT */:
                    case 4 /* CHECKBOX */:
                        return serializeData;
                    case 5 /* VECTOR2 */:
                    case 6 /* VECTOR3 */:
                    case 7 /* VECTOR4 */:
                    case 8 /* QUATERNION */:
                    case 9 /* COLOR */:
                    case 11 /* RECT */:
                        var clazz = egret.getDefinitionByName(serializeData.className);
                        var target = null;
                        if (clazz) {
                            target = new clazz();
                            target.deserialize(serializeData.serializeData);
                        }
                        return target;
                    case 19 /* SHADER */:
                        var url = serializeData;
                        var asset = paper.Asset.find(url);
                        return asset;
                    case 10 /* LIST */:
                        return serializeData;
                    case 13 /* MATERIAL_ARRAY */:
                        var materials = [];
                        for (var _i = 0, serializeData_1 = serializeData; _i < serializeData_1.length; _i++) {
                            var matrial = serializeData_1[_i];
                            var asset_1 = paper.Asset.find(matrial.url);
                            materials.push(asset_1);
                        }
                        return materials;
                    case 18 /* MESH */:
                        var meshAsset = paper.Asset.find(serializeData);
                        return meshAsset;
                    case 12 /* MATERIAL */:
                    case 14 /* GAMEOBJECT */:
                    case 15 /* TRANSFROM */:
                    case 17 /* SOUND */:
                    case 20 /* ARRAY */:
                        //TODO
                        console.error("not supported!");
                        return null;
                    default:
                        break;
                }
            };
            EditorModel.prototype.createGameObject = function (parentList, createType, mesh) {
                if (mesh === void 0) { mesh = null; }
                var state = editor.CreateGameObjectState.create(parentList, createType, mesh);
                this.addState(state);
            };
            EditorModel.prototype.addComponent = function (gameObjectUUid, compClzName) {
                var data = {
                    gameObjectUUid: gameObjectUUid,
                    compClzName: compClzName
                };
                var state = editor.AddComponentState.create(gameObjectUUid, compClzName);
                this.addState(state);
            };
            EditorModel.prototype.removeComponent = function (gameObjectUUid, componentUUid) {
                var obj = this.getGameObjectByUUid(gameObjectUUid);
                if (!obj) {
                    return;
                }
                var removeComponent = this.getComponentById(obj, componentUUid);
                if (!removeComponent) {
                    return;
                }
                var serializeData = paper.serialize(removeComponent);
                var state = editor.RemoveComponentState.create(gameObjectUUid, componentUUid, serializeData);
                this.addState(state);
            };
            EditorModel.prototype.getComponentById = function (gameObject, componentId) {
                for (var i = 0; i < gameObject.components.length; i++) {
                    var comp = gameObject.components[i];
                    if (comp.uuid === componentId) {
                        return comp;
                    }
                }
                return null;
            };
            EditorModel.prototype.getComponentByAssetId = function (gameObject, assetId) {
                for (var i = 0; i < gameObject.components.length; i++) {
                    var comp = gameObject.components[i];
                    if (comp.extras.linkedID === assetId) {
                        return comp;
                    }
                }
                return null;
            };
            /**
             * 复制游戏对象
             * @param objs
             */
            EditorModel.prototype.copyGameObject = function (objs) {
                var clipboard = __global.runtimeModule.getClipborad();
                var content = [];
                //过滤
                this.filtTopHierarchyGameObjects(objs);
                //排序
                objs = this.sortGameObjectsForHierarchy(objs);
                for (var i = 0; i < objs.length; i++) {
                    var obj = objs[i];
                    content.push({
                        type: "gameObject",
                        serializeData: paper.serialize(obj)
                    });
                }
                clipboard.writeText(JSON.stringify(content), "paper");
            };
            /**
             * 粘贴游戏对象
             * @param parent
             */
            EditorModel.prototype.pasteGameObject = function (parent) {
                var clipboard = __global.runtimeModule.getClipborad();
                var msg = clipboard.readText("paper");
                var content = JSON.parse(msg);
                if (content && content.length > 0) {
                    var objData = [];
                    for (var i = 0; i < content.length; i++) {
                        objData.push(content[i].serializeData);
                    }
                    var state = editor.PasteGameObjectsState.create(objData, parent);
                    this.addState(state);
                }
            };
            /**
             * 克隆游戏对象
             * @param gameObjects
             */
            EditorModel.prototype.duplicateGameObjects = function (gameObjects) {
                var state = editor.DuplicateGameObjectsState.create(gameObjects, this);
                this.addState(state);
            };
            /**
             * 删除游戏对象
             * @param gameObjects
             */
            EditorModel.prototype.deleteGameObject = function (gameObjects) {
                var _this = this;
                var deleteState = editor.DeleteGameObjectsState.create(gameObjects, this);
                var breakList = [];
                gameObjects.forEach(function (obj) {
                    if (_this.isPrefabChild(obj) && !_this.isPrefabRoot(obj)) {
                        breakList.push(obj);
                    }
                });
                if (breakList.length > 0) {
                    var breakState = editor.BreakPrefabStructState.create(breakList);
                    var stateGroup = editor.StateGroup.create([breakState, deleteState]);
                    this.addState(stateGroup);
                }
                else {
                    this.addState(deleteState);
                }
            };
            /**
             * 解除预置体联系
             * @param gameObjects
             */
            EditorModel.prototype.breakPrefab = function (gameObjects) {
                var _this = this;
                var breakList = [];
                gameObjects.forEach(function (obj) {
                    if (_this.isPrefabChild(obj) || _this.isPrefabRoot(obj)) {
                        breakList.push(obj);
                    }
                });
                if (breakList.length > 0) {
                    var breakState = editor.BreakPrefabStructState.create(breakList);
                    this.addState(breakState);
                }
            };
            /**
             * 更改层级
             * */
            EditorModel.prototype.updateGameObjectsHierarchy = function (gameObjects, targetGameobjcet, dir) {
                var _this = this;
                var gameObjectHierarchyState = editor.GameObjectHierarchyState.create(gameObjects, targetGameobjcet, dir, this);
                var breakList = [];
                gameObjects.forEach(function (obj) {
                    if (_this.isPrefabChild(obj) &&
                        !_this.isPrefabRoot(obj) &&
                        (obj.transform.parent !== targetGameobjcet.transform.parent || dir === 'inner')) {
                        breakList.push(obj);
                    }
                });
                if (breakList.length > 0) {
                    var breakPrefabStructState = editor.BreakPrefabStructState.create(breakList);
                    var stateGroup = editor.StateGroup.create([breakPrefabStructState, gameObjectHierarchyState]);
                    this.addState(stateGroup);
                }
                else {
                    this.addState(gameObjectHierarchyState);
                }
            };
            /**
             * 设置对象的层级
             */
            EditorModel.prototype.setGameObjectsHierarchy = function (objects, targetObject, dir) {
                objects = objects.concat();
                //剔除所有父级
                objects.forEach(function (obj) { obj.transform.parent = null; });
                objects.reverse();
                if (dir === 'inner') {
                    var index = targetObject.transform.children.length;
                    for (var i = 0; i < objects.length; i++) {
                        var obj = objects[i];
                        obj.transform.parent = targetObject.transform;
                        var transform = targetObject.transform.children.pop();
                        targetObject.transform.children.splice(index, 0, transform);
                    }
                }
                else {
                    if (targetObject.transform.parent) {
                        var index = void 0;
                        switch (dir) {
                            case 'top':
                                index = targetObject.transform.parent.children.indexOf(targetObject.transform);
                                break;
                            case 'bottom':
                                index = targetObject.transform.parent.children.indexOf(targetObject.transform) + 1;
                                break;
                        }
                        for (var i = 0; i < objects.length; i++) {
                            var obj = objects[i];
                            obj.transform.parent = targetObject.transform.parent;
                            var transform = targetObject.transform.parent.children.pop();
                            targetObject.transform.parent.children.splice(index, 0, transform);
                        }
                    }
                    else {
                        var all = this.scene.gameObjects;
                        for (var i = 0; i < objects.length; i++) {
                            all.splice(all.indexOf(objects[i]), 1);
                        }
                        var index = void 0;
                        switch (dir) {
                            case 'top':
                                index = all.indexOf(targetObject);
                                break;
                            case 'bottom':
                                index = all.indexOf(targetObject) + 1;
                                break;
                        }
                        for (var i = 0; i < objects.length; i++) {
                            var obj = objects[i];
                            all.splice(index, 0, obj);
                        }
                    }
                }
            };
            /**
             * 筛选层级中的顶层游戏对象
             * @param gameObjects
             */
            EditorModel.prototype.filtTopHierarchyGameObjects = function (gameObjects) {
                var findParent = false;
                var parent = null;
                for (var index = gameObjects.length - 1; index >= 0; index--) {
                    var element = gameObjects[index];
                    findParent = false;
                    parent = element.transform.parent;
                    while (parent) {
                        for (var i = 0; i < gameObjects.length; i++) {
                            var element_1 = gameObjects[i];
                            if (element_1.transform === parent) {
                                gameObjects.splice(index, 1);
                                findParent = true;
                                break;
                            }
                        }
                        if (findParent) {
                            break;
                        }
                        parent = parent.parent;
                    }
                }
            };
            EditorModel.prototype.getGameObjectByUUid = function (uuid) {
                var objects = this.scene.gameObjects;
                for (var i = 0; i < objects.length; i++) {
                    if (objects[i].uuid === uuid) {
                        return objects[i];
                    }
                }
                return null;
            };
            EditorModel.prototype.getGameObjectsByUUids = function (uuids) {
                var objects = this.scene.gameObjects;
                var obj;
                var result = [];
                var idIndex;
                var cloneIds = uuids.concat();
                for (var i = 0; i < objects.length; i++) {
                    if (cloneIds.length === 0) {
                        return result;
                    }
                    obj = objects[i];
                    idIndex = cloneIds.indexOf(obj.uuid);
                    if (idIndex !== -1) {
                        result.push(obj);
                        cloneIds.splice(idIndex, 1);
                    }
                }
                return result;
            };
            EditorModel.prototype.setTargetProperty = function (propName, target, value, editType) {
                if (editType !== 5 /* VECTOR2 */ &&
                    editType !== 6 /* VECTOR3 */ &&
                    editType !== 7 /* VECTOR4 */ &&
                    editType !== 9 /* COLOR */) {
                    target[propName] = value;
                    return;
                }
                if (this.propertyHasGetterSetter(propName, target)) {
                    target[propName] = value;
                }
                else {
                    switch (editType) {
                        case 5 /* VECTOR2 */:
                            var vec2 = target[propName];
                            vec2.x = value.x;
                            vec2.y = value.y;
                            break;
                        case 6 /* VECTOR3 */:
                            var vec3 = target[propName];
                            vec3.x = value.x;
                            vec3.y = value.y;
                            vec3.z = value.z;
                            break;
                        case 7 /* VECTOR4 */:
                            var vec4 = target[propName];
                            vec4.x = value.x;
                            vec4.y = value.y;
                            vec4.z = value.z;
                            vec4.w = value.w;
                            break;
                        case 9 /* COLOR */:
                            var color = target[propName];
                            color.r = value.r;
                            color.g = value.g;
                            color.b = value.b;
                            color.a = value.a;
                            break;
                        default:
                            break;
                    }
                }
            };
            EditorModel.prototype.propertyHasGetterSetter = function (propName, target) {
                var prototype = Object.getPrototypeOf(target);
                var descriptror;
                while (prototype) {
                    descriptror = Object.getOwnPropertyDescriptor(prototype, propName);
                    if (descriptror && descriptror.get && descriptror.set) {
                        return true;
                    }
                    prototype = Object.getPrototypeOf(prototype);
                }
                return false;
            };
            /**
             * 选择游戏对象
             *  */
            EditorModel.prototype.selectGameObject = function (objs) {
                this.currentSelected = objs;
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.SELECT_GAMEOBJECTS, objs));
            };
            /**
             * 切换编辑模式
             */
            EditorModel.prototype.changeEditMode = function (mode) {
                this.currentEditMode = mode;
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_EDIT_MODE, mode));
            };
            /**
             * 切换编辑类型
             */
            EditorModel.prototype.changeEditType = function (type) {
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_EDIT_TYPE, type));
            };
            EditorModel.prototype.isPrefabRoot = function (gameObj) {
                if (gameObj.extras.prefab) {
                    return true;
                }
                return false;
            };
            EditorModel.prototype.isPrefabChild = function (gameObj) {
                if (gameObj.extras.rootID) {
                    return true;
                }
                return false;
            };
            /**将对象按照层级进行排序
             */
            EditorModel.prototype.sortGameObjectsForHierarchy = function (gameobjects) {
                var _this = this;
                gameobjects = gameobjects.concat();
                if (gameobjects.length < 2) {
                    return gameobjects;
                }
                //生成每个对象的显示索引路径列表
                var displayPathList = [];
                gameobjects.forEach(function (obj) {
                    var result = [];
                    var currentObj = obj;
                    while (currentObj.transform.parent) {
                        result.unshift(currentObj.transform.parent.children.indexOf(currentObj.transform));
                        currentObj = currentObj.transform.parent.gameObject;
                    }
                    //追加一个根部索引
                    result.unshift(_this.scene.gameObjects.indexOf(currentObj));
                    displayPathList.push({ gameObject: obj, path: result });
                });
                function getPath(gameObject) {
                    for (var i_1 = 0; i_1 < displayPathList.length; i_1++) {
                        if (displayPathList[i_1].gameObject === gameObject) {
                            return displayPathList[i_1].path;
                        }
                    }
                }
                var length = gameobjects.length - 1;
                while (length > 0) {
                    for (var i = 0; i < length; i++) {
                        var A = getPath(gameobjects[i]);
                        var B = getPath(gameobjects[i + 1]);
                        var needChangeIndex = false;
                        var minLength = Math.min(A.length, B.length);
                        var k = 0;
                        b: for (k; k < minLength; k++) {
                            if (A[k] === B[k]) {
                                continue;
                            }
                            else if (A[k] > B[k]) {
                                needChangeIndex = true;
                                break b;
                            }
                            else if (A[k] < B[k]) {
                                needChangeIndex = false;
                                break b;
                            }
                        }
                        if (k === minLength && !needChangeIndex && A.length > B.length) {
                            needChangeIndex = true;
                        }
                        if (needChangeIndex) {
                            var tmpv = gameobjects[i];
                            gameobjects[i] = gameobjects[i + 1];
                            gameobjects[i + 1] = tmpv;
                        }
                    }
                    length--;
                }
                return gameobjects;
            };
            EditorModel.prototype.createApplyPrefabState = function (applyData, applyPrefabInstanceId, prefab) {
                var state = editor.ApplyPrefabInstanceState.create(applyData, applyPrefabInstanceId, prefab);
                this.addState(state);
            };
            EditorModel.prototype.createRevertPrefabState = function (revertData, revertPrefabInstanceId) {
                var state = editor.RevertPrefabInstanceState.create(revertData, revertPrefabInstanceId);
                this.addState(state);
            };
            EditorModel.prototype.deepClone = function (obj) {
                var _this = this;
                if (!obj || typeof obj !== 'object') {
                    return obj;
                }
                if (obj instanceof RegExp) {
                    return obj;
                }
                var result = Array.isArray(obj) ? [] : {};
                Object.keys(obj).forEach(function (key) {
                    if (obj[key] && typeof obj[key] === 'object') {
                        result[key] = _this.deepClone(obj[key]);
                    }
                    else {
                        result[key] = obj[key];
                    }
                });
                return result;
            };
            EditorModel.prototype.updateAsset = function (asset, prefabInstance) {
                if (prefabInstance === void 0) { prefabInstance = null; }
                var refs = this.findAssetRefs(this.scene, asset);
                var serializeData;
                if (asset instanceof paper.Prefab) {
                    serializeData = paper.serialize(prefabInstance);
                }
                else {
                }
                //save asset
                //destory asset,getRes
                //update refrence (paper.assets[])
                this._cacheIds.length = 0;
            };
            EditorModel.prototype.findAssetRefs = function (target, as, refs) {
                if (refs === void 0) { refs = null; }
                if (this._cacheIds.indexOf(target.uuid) >= 0) {
                    return;
                }
                this._cacheIds.push(target.uuid);
                refs = refs || [];
                for (var key in target) {
                    var source = target[key];
                    if ((typeof source) === "object") {
                        this.findFromChildren(source, as, refs, target, key);
                    }
                }
                return refs;
            };
            EditorModel.prototype.findFromChildren = function (source, as, refs, parent, key) {
                if ((typeof source) !== "object") {
                    return;
                }
                if (Array.isArray(source) || ArrayBuffer.isView(source)) {
                    for (var index = 0; index < source.length; index++) {
                        var element = source[index];
                        this.findFromChildren(element, as, refs, source, index);
                    }
                }
                if (source.constructor === Object) {
                    for (var key_1 in source) {
                        var element = source[key_1];
                        this.findFromChildren(element, as, refs, source, key_1);
                    }
                }
                if (source instanceof paper.BaseObject) {
                    if (source instanceof paper.Asset && source === as) {
                        refs.push({ p: parent, k: key });
                        return;
                    }
                    this.findAssetRefs(source, as, refs);
                }
            };
            EditorModel.prototype.getAllGameObjectsFromPrefabInstance = function (gameObj, objs) {
                if (objs === void 0) { objs = null; }
                if (gameObj) {
                    objs = objs || [];
                    if (gameObj.extras.linkedID) {
                        objs.push(gameObj);
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        this.getAllGameObjectsFromPrefabInstance(obj, objs);
                    }
                }
                return objs;
            };
            EditorModel.prototype.modifyMaterialPropertyValues = function (target, valueList) {
                return __awaiter(this, void 0, void 0, function () {
                    var _i, valueList_1, propertyValue, propName, copyValue, uniformType, _glTFMaterial, gltfUnifromMap, uniformMap, key, value;
                    return __generator(this, function (_a) {
                        for (_i = 0, valueList_1 = valueList; _i < valueList_1.length; _i++) {
                            propertyValue = valueList_1[_i];
                            propName = propertyValue.propName, copyValue = propertyValue.copyValue, uniformType = propertyValue.uniformType;
                            if (!copyValue) {
                                continue;
                            }
                            switch (uniformType) {
                                case 35670 /* BOOL */:
                                    target.setBoolean(propName, copyValue);
                                    break;
                                case 5124 /* INT */:
                                    target.setInt(propName, copyValue);
                                case 5126 /* FLOAT */:
                                    target.setFloat(propName, copyValue);
                                    break;
                                case 35671 /* BOOL_VEC2 */:
                                case 35667 /* INT_VEC2 */:
                                case 35664 /* FLOAT_VEC2 */:
                                    target.setVector2v(propName, copyValue);
                                    break;
                                case 35672 /* BOOL_VEC3 */:
                                case 35668 /* INT_VEC3 */:
                                case 35665 /* FLOAT_VEC3 */:
                                    target.setVector3v(propName, copyValue);
                                    break;
                                case 35673 /* BOOL_VEC4 */:
                                case 35669 /* INT_VEC4 */:
                                case 35666 /* FLOAT_VEC4 */:
                                    target.setVector4v(propName, copyValue);
                                    break;
                                case 35678 /* SAMPLER_2D */:
                                    target._glTFTechnique.uniforms[propName].value = copyValue;
                                    break;
                                case 35674 /* FLOAT_MAT2 */:
                                case 35675 /* FLOAT_MAT3 */:
                                case 35676 /* FLOAT_MAT4 */:
                                    target.setMatrixv(propName, copyValue);
                                    break;
                                default:
                                    break;
                            }
                            if (propName === "renderQueue") {
                                target.config.materials[0].extensions.paper.renderQueue = copyValue;
                            }
                            this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_PROPERTY, { target: target, propName: propName, propValue: copyValue }));
                        }
                        _glTFMaterial = target.config.materials[0];
                        gltfUnifromMap = _glTFMaterial.extensions.KHR_techniques_webgl.values;
                        uniformMap = target._glTFTechnique.uniforms;
                        for (key in uniformMap) {
                            if (uniformMap[key].semantic === undefined) {
                                value = uniformMap[key].value;
                                if (Array.isArray(value)) {
                                    gltfUnifromMap[key] = value.concat();
                                }
                                else if (value instanceof egret3d.GLTexture2D) {
                                    gltfUnifromMap[key] = value.name;
                                }
                                else {
                                    gltfUnifromMap[key] = value;
                                }
                            }
                        }
                        return [2 /*return*/];
                    });
                });
            };
            return EditorModel;
        }(editor.EventDispatcher));
        editor.EditorModel = EditorModel;
        __reflect(EditorModel.prototype, "paper.editor.EditorModel");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var EditorSceneModel = (function () {
            function EditorSceneModel() {
                this.viewCache = {};
            }
            Object.defineProperty(EditorSceneModel.prototype, "editorScene", {
                get: function () {
                    return paper.Application.sceneManager.editorScene;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorSceneModel.prototype, "editorModel", {
                set: function (v) {
                    if (this.currentModel) {
                        this.viewCache[this.currentModel.contentUrl] = {
                            position: this.cameraObject.transform.getPosition().clone(),
                            rotation: this.cameraObject.transform.getRotation().clone()
                        };
                    }
                    // this.pickGameScript.clearSelected();
                    // this.geoController.clearSelected();//TODO:应在controller里新增清空状态函数
                    // this.editorCameraScript.editorModel = v;
                    // this.pickGameScript.editorModel = v;
                    // this.geoController.editorModel = v;
                    this.currentModel = v;
                    if (v && this.viewCache[v.contentUrl]) {
                        this.cameraObject.transform.setPosition(this.viewCache[v.contentUrl].position);
                        this.cameraObject.transform.setRotation(this.viewCache[v.contentUrl].rotation);
                    }
                    else {
                        this.cameraObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                        this.cameraObject.transform.lookAt(egret3d.Vector3.ZERO);
                    }
                },
                enumerable: true,
                configurable: true
            });
            EditorSceneModel.prototype.init = function () {
                this.cameraObject = egret3d.Camera.editor.gameObject;
                // this.cameraObject = GameObject.create("EditorCamera", DefaultTags.EditorOnly, Application.sceneManager.editorScene);
                var camera = this.cameraObject.getOrAddComponent(egret3d.Camera);
                camera.near = 0.1;
                camera.far = 500.0;
                camera.backgroundColor.set(0.13, 0.28, 0.51, 1.00);
                this.cameraObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                this.cameraObject.transform.lookAt(egret3d.Vector3.ZERO);
                paper.GameObject.globalGameObject.sendMessage("bootstrap");
                // this.editorCameraScript = this.cameraObject.addComponent(EditorCameraScript);
                // this.editorCameraScript.moveSpeed = 10;
                // this.editorCameraScript.rotateSpeed = 0.5;
                // this.pickGameScript = this.cameraObject.addComponent(PickGameObjectScript);
                // this.geoController = this.cameraObject.addComponent(Controller)
            };
            return EditorSceneModel;
        }());
        editor.EditorSceneModel = EditorSceneModel;
        __reflect(EditorSceneModel.prototype, "paper.editor.EditorSceneModel");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        editor.EventType = {
            HistoryState: "HistoryState",
            HistoryAdd: "HistoryAdd",
            HistoryFree: "HistoryFree"
        };
        var History = (function () {
            function History() {
                this.dispatcher = null;
                this._locked = 0;
                this._index = -1;
                this._batchIndex = 0;
                this._states = [];
                this._batchStates = [];
                this._events = [];
            }
            History.prototype._free = function () {
                if (this._states.length > this._index + 1) {
                    this._states.length = this._index + 1; // TODO release.
                    if (this.dispatcher) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryFree, null));
                    }
                }
            };
            History.prototype._doState = function (state, isUndo) {
                if (isUndo) {
                    state.undo();
                }
                else {
                    state.redo();
                }
                var d = isUndo ? "undo" : "redo";
                if (this.dispatcher) {
                    var data = { isUndo: isUndo };
                    this._events.push(data);
                }
                return state.batchIndex > 0 && (isUndo ? this._index >= 0 : this._index < this._states.length - 1);
            };
            History.prototype.back = function () {
                if (this._index < 0 || this._batchIndex > 0) {
                    return false;
                }
                this._locked |= 1;
                while (this._doState(this._states[this._index--], true)) {
                }
                if (this.dispatcher && this._events.length > 0) {
                    for (var _i = 0, _a = this._events; _i < _a.length; _i++) {
                        var event_1 = _a[_i];
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryState, event_1));
                    }
                    this._events.length = 0;
                }
                this._locked &= 2;
                return true;
            };
            History.prototype.forward = function () {
                if (this._index >= this._states.length - 1 || this._batchIndex > 0) {
                    return false;
                }
                this._locked |= 1;
                while (this._doState(this._states[++this._index], false)) {
                }
                if (this.dispatcher && this._events.length > 0) {
                    for (var _i = 0, _a = this._events; _i < _a.length; _i++) {
                        var event_2 = _a[_i];
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryState, event_2));
                    }
                    this._events.length = 0;
                }
                this._locked &= 2;
                return true;
            };
            History.prototype.go = function (index) {
                if (this._batchIndex > 0) {
                    return false;
                }
                var result = false;
                if (this._index < index) {
                    while (this._index !== index && this.forward()) {
                        result = true;
                    }
                }
                else {
                    while (this._index !== index && this.back()) {
                        result = true;
                    }
                }
                return result;
            };
            History.prototype.add = function (state) {
                if (this._locked !== 0) {
                    return;
                }
                if (this._batchIndex > 0) {
                    state.batchIndex = this._batchIndex;
                    this._batchStates.push(state);
                }
                else {
                    this._states[this._index + 1] = state;
                    if (this.dispatcher !== null) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryAdd, event));
                    }
                    this.forward();
                    this._free();
                }
            };
            History.prototype.beginBatch = function () {
                this._batchIndex++;
            };
            History.prototype.endBatch = function () {
                if (this._batchIndex === 0) {
                    return;
                }
                this._batchIndex--;
                if (this._batchIndex === 0) {
                    var index = this._index + 1;
                    for (var _i = 0, _a = this._batchStates; _i < _a.length; _i++) {
                        var state = _a[_i];
                        this._states[index++] = state;
                    }
                    if (this.dispatcher !== null) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryAdd, event));
                    }
                    this._batchStates.length = 0;
                    this.go(this._states.length - 1);
                }
            };
            History.prototype.getState = function (index) {
                return this._states[index];
            };
            Object.defineProperty(History.prototype, "enabled", {
                get: function () {
                    return this._locked === 0;
                },
                set: function (value) {
                    if (value) {
                        this._locked &= 1;
                    }
                    else {
                        this._locked |= 2;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "count", {
                get: function () {
                    return this._states.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "index", {
                get: function () {
                    return this._index;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "batchIndex", {
                get: function () {
                    return this._batchIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "locked", {
                get: function () {
                    return this._locked;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "states", {
                get: function () {
                    return this._states;
                },
                enumerable: true,
                configurable: true
            });
            History.prototype.serialize = function () {
                var states = this.states;
                var statesData = [];
                for (var index = 0; index < states.length; index++) {
                    var element = states[index];
                    var className = egret.getQualifiedClassName(element);
                    var data = {
                        className: className,
                        batchIndex: element.batchIndex,
                        data: element.hasOwnProperty('deserialize') ? element['serialize']() : element.data,
                        autoClear: element.autoClear,
                        isDone: element.isDone,
                    };
                    statesData.push(data);
                }
                var serializeHistory = {
                    index: this.index,
                    batchIndex: this.batchIndex,
                    locked: this.locked,
                    statesData: statesData,
                };
                return serializeHistory;
            };
            History.prototype.deserialize = function (serializeHistory) {
                var states = [];
                var statesData = serializeHistory.statesData;
                for (var index = 0; index < statesData.length; index++) {
                    var element = statesData[index];
                    var clazz = egret.getDefinitionByName(element.className);
                    var state = void 0;
                    if (clazz) {
                        state = new clazz();
                        state.batchIndex = element.batchIndex;
                        state.data = element.hasOwnProperty('deserialize') ? element['deserialize'](element.data) : element.data;
                        state.autoClear = element.autoClear;
                        state.isDone = element.isDone;
                        states.push(state);
                    }
                }
                var initData = {
                    states: states,
                    index: serializeHistory.index,
                    batchIndex: serializeHistory.batchIndex,
                    locked: serializeHistory.locked,
                };
                this._index = initData ? initData.index : -1;
                this._locked = initData ? initData.locked : 0;
                this._batchIndex = initData ? initData.batchIndex : 0;
                this._states = initData ? initData.states : [];
            };
            return History;
        }());
        editor.History = History;
        __reflect(History.prototype, "paper.editor.History");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 3×3矩阵
     */
    var Matrix3 = (function (_super) {
        __extends(Matrix3, _super);
        /**
         * @deprecated
         */
        function Matrix3(rawData) {
            if (rawData === void 0) { rawData = null; }
            var _this = _super.call(this) || this;
            /**
             * 矩阵原始数据
             * @readonly
             */
            _this.rawData = null;
            if (rawData) {
                _this.rawData = rawData;
            }
            else {
                _this.rawData = new Float32Array([
                    1.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                    0.0, 0.0, 1.0,
                ]);
            }
            return _this;
        }
        Matrix3.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new Matrix3();
        };
        /**
         * 序列化
         * @returns 序列化后的数据
         */
        Matrix3.prototype.serialize = function () {
            return this.rawData;
        };
        /**
         * 反序列化
         * @param value 序列化后的数据
         */
        Matrix3.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Matrix3.prototype.copy = function (value) {
            this.fromArray(value.rawData);
            return this;
        };
        Matrix3.prototype.clone = function () {
            var value = new Matrix3();
            value.copy(this);
            return value;
        };
        Matrix3.prototype.set = function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            this.rawData[0] = n11;
            this.rawData[3] = n12;
            this.rawData[6] = n13;
            this.rawData[1] = n21;
            this.rawData[4] = n22;
            this.rawData[7] = n23;
            this.rawData[2] = n31;
            this.rawData[5] = n32;
            this.rawData[8] = n33;
            return this;
        };
        Matrix3.prototype.identity = function () {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this;
        };
        Matrix3.prototype.inverse = function (matrix) {
            var me = matrix.rawData, te = this.rawData, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
            if (det === 0) {
                // TODO
                // var msg = "can't invert matrix, determinant is 0";
                // console.warn(msg);
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n31 * n23 - n33 * n21) * detInv;
            te[2] = (n32 * n21 - n31 * n22) * detInv;
            te[3] = t12 * detInv;
            te[4] = (n33 * n11 - n31 * n13) * detInv;
            te[5] = (n31 * n12 - n32 * n11) * detInv;
            te[6] = t13 * detInv;
            te[7] = (n21 * n13 - n23 * n11) * detInv;
            te[8] = (n22 * n11 - n21 * n12) * detInv;
            return this;
        };
        Matrix3.prototype.getNormalMatrix = function (matrix4) {
            return this.setFromMatrix4(matrix4).inverse(this).transpose();
        };
        Matrix3.prototype.transpose = function () {
            var tmp, m = this.rawData;
            tmp = m[1];
            m[1] = m[3];
            m[3] = tmp;
            tmp = m[2];
            m[2] = m[6];
            m[6] = tmp;
            tmp = m[5];
            m[5] = m[7];
            m[7] = tmp;
            return this;
        };
        Matrix3.prototype.setFromMatrix4 = function (m) {
            var me = m.rawData;
            this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
            // this.set(
            //     me[0], me[1], me[2],
            //     me[4], me[5], me[6],
            //     me[8], me[9], me[10]
            // );
            return this;
        };
        Matrix3.prototype.determinant = function () {
            var te = this.rawData;
            var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        };
        Matrix3.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            for (var i = 0; i < 9; ++i) {
                this.rawData[i] = value[i + offset];
            }
            return this;
        };
        Matrix3.prototype.fromBuffer = function (value, byteOffset) {
            if (byteOffset === void 0) { byteOffset = 0; }
            this.rawData = new Float32Array(value, byteOffset, 9);
            return this;
        };
        Matrix3._instances = [];
        return Matrix3;
    }(paper.BaseRelease));
    egret3d.Matrix3 = Matrix3;
    __reflect(Matrix3.prototype, "egret3d.Matrix3", ["paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 状态组
         * @author 杨宁
         */
        var StateGroup = (function (_super) {
            __extends(StateGroup, _super);
            function StateGroup() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            StateGroup.create = function (stateList) {
                var instance = new StateGroup();
                instance.stateList = stateList;
                return instance;
            };
            StateGroup.prototype.redo = function () {
                for (var i = 0; i < this.stateList.length; i++) {
                    this.stateList[i].redo();
                }
                return true;
            };
            StateGroup.prototype.undo = function () {
                for (var i = this.stateList.length - 1; i >= 0; i--) {
                    this.stateList[i].undo();
                }
                return true;
            };
            StateGroup.prototype.serialize = function () {
                var states = this.stateList;
                var statesData = [];
                for (var index = 0; index < states.length; index++) {
                    var element = states[index];
                    var className = egret.getQualifiedClassName(element);
                    var data = {
                        className: className,
                        batchIndex: element.batchIndex,
                        data: element['serialize'] ? element['serialize']() : element.data,
                        autoClear: element.autoClear,
                        isDone: element.isDone,
                    };
                    statesData.push(data);
                }
                return states;
            };
            StateGroup.prototype.deserialize = function (data) {
                this.stateList = [];
                var statesData = data;
                for (var index = 0; index < statesData.length; index++) {
                    var element = statesData[index];
                    var clazz = egret.getDefinitionByName(element.className);
                    var state = null;
                    if (clazz) {
                        state = new clazz();
                        state.batchIndex = element.batchIndex;
                        state.data = element['deserialize'] ? element['deserialize'](element.data) : element.data;
                        state.autoClear = element.autoClear;
                        state.isDone = element.isDone;
                        this.stateList.push(state);
                    }
                }
            };
            return StateGroup;
        }(editor.BaseState));
        editor.StateGroup = StateGroup;
        __reflect(StateGroup.prototype, "paper.editor.StateGroup");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var ModifyGameObjectPropertyState = (function (_super) {
            __extends(ModifyGameObjectPropertyState, _super);
            function ModifyGameObjectPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyGameObjectPropertyState.create = function (gameObjectUUid, newValueList, preValueCopylist) {
                var state = new ModifyGameObjectPropertyState();
                var data = {
                    gameObjectUUid: gameObjectUUid,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(ModifyGameObjectPropertyState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            ModifyGameObjectPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    this.modifyProperty(this.stateData.preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyGameObjectPropertyState.prototype.modifyProperty = function (valueList) {
                var _this = this;
                var uuid = this.stateData.gameObjectUUid;
                var modifyObj = this.editorModel.getGameObjectByUUid(uuid);
                if (modifyObj !== null) {
                    valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                        var propName, copyValue, valueEditType, newValue;
                        return __generator(this, function (_a) {
                            propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                            newValue = this.editorModel.deserializeProperty(copyValue, valueEditType);
                            this.editorModel.setTargetProperty(propName, modifyObj, newValue, valueEditType);
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
                            return [2 /*return*/];
                        });
                    }); });
                }
            };
            ModifyGameObjectPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.modifyProperty(this.stateData.newValueList);
                    return true;
                }
                return false;
            };
            return ModifyGameObjectPropertyState;
        }(editor.BaseState));
        editor.ModifyGameObjectPropertyState = ModifyGameObjectPropertyState;
        __reflect(ModifyGameObjectPropertyState.prototype, "paper.editor.ModifyGameObjectPropertyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //修改组件属性属性
        var ModifyComponentPropertyState = (function (_super) {
            __extends(ModifyComponentPropertyState, _super);
            function ModifyComponentPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyComponentPropertyState.toString = function () {
                return "[class common.ModifyComponentPropertyState]";
            };
            ModifyComponentPropertyState.create = function (gameObjUUid, componentUUid, newValueList, preValueCopylist) {
                var state = new ModifyComponentPropertyState();
                var data = {
                    gameObjUUid: gameObjUUid,
                    componentUUid: componentUUid,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(ModifyComponentPropertyState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            ModifyComponentPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    this.modifyProperty(this.stateData.preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyComponentPropertyState.prototype.modifyProperty = function (valueList) {
                var _this = this;
                var gameObjectUUid = this.stateData.gameObjUUid;
                var componentUUid = this.stateData.componentUUid;
                var gameObj = this.editorModel.getGameObjectByUUid(gameObjectUUid);
                var modifyObj;
                if (gameObj) {
                    modifyObj = this.editorModel.getComponentById(gameObj, componentUUid);
                    if (modifyObj) {
                        valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                            var propName, copyValue, valueEditType, newValue;
                            return __generator(this, function (_a) {
                                propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                newValue = this.editorModel.deserializeProperty(copyValue, valueEditType);
                                this.editorModel.setTargetProperty(propName, modifyObj, newValue, valueEditType);
                                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
                                return [2 /*return*/];
                            });
                        }); });
                    }
                }
            };
            ModifyComponentPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.modifyProperty(this.stateData.newValueList);
                    return true;
                }
                return false;
            };
            return ModifyComponentPropertyState;
        }(editor.BaseState));
        editor.ModifyComponentPropertyState = ModifyComponentPropertyState;
        __reflect(ModifyComponentPropertyState.prototype, "paper.editor.ModifyComponentPropertyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //创建游戏对象
        var CreateGameObjectState = (function (_super) {
            __extends(CreateGameObjectState, _super);
            function CreateGameObjectState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.isFirst = true;
                return _this;
            }
            CreateGameObjectState.toString = function () {
                return "[class common.AddGameObjectState]";
            };
            CreateGameObjectState.create = function (parentList, createType, mesh) {
                var infos = parentList.map(function (obj) { return { parentUUID: obj.uuid, serializeData: null }; });
                var state = new CreateGameObjectState();
                state.infos = infos;
                state.createType = createType;
                state.mesh = mesh;
                return state;
            };
            CreateGameObjectState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var objs = this.editorModel.getGameObjectsByUUids(this.addList);
                    for (var index = 0; index < objs.length; index++) {
                        var element = objs[index];
                        element.destroy();
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            CreateGameObjectState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.addList = [];
                    //一条信息都没有则添加到场景根
                    if (this.infos.length === 0) {
                        this.infos.push({ parentUUID: null, serializeData: null });
                    }
                    for (var i = 0; i < this.infos.length; i++) {
                        var obj = void 0;
                        if (this.isFirst) {
                            obj = this.createGameObjectByType(this.createType);
                            this.infos[i].serializeData = paper.serialize(obj);
                        }
                        else {
                            obj = new paper.Deserializer().deserialize(this.infos[i].serializeData, true, false, this.editorModel.scene);
                        }
                        var parent_3 = this.editorModel.getGameObjectByUUid(this.infos[i].parentUUID);
                        if (parent_3)
                            obj.transform.parent = parent_3.transform;
                        this.addList.push(obj.uuid);
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.addList);
                    this.isFirst = false;
                    return true;
                }
                return false;
            };
            CreateGameObjectState.prototype.createGameObjectByType = function (createType) {
                var obj = new paper.GameObject();
                var meshFilter;
                obj.name = createType.toLowerCase();
                if (this.mesh) {
                    meshFilter = obj.addComponent(egret3d.MeshFilter);
                    meshFilter.mesh = this.mesh;
                    obj.addComponent(egret3d.MeshRenderer);
                }
                return obj;
            };
            return CreateGameObjectState;
        }(editor.BaseState));
        editor.CreateGameObjectState = CreateGameObjectState;
        __reflect(CreateGameObjectState.prototype, "paper.editor.CreateGameObjectState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //删除游戏对象
        var DeleteGameObjectsState = (function (_super) {
            __extends(DeleteGameObjectsState, _super);
            function DeleteGameObjectsState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            DeleteGameObjectsState.toString = function () {
                return "[class common.deleteGameObjectsState]";
            };
            DeleteGameObjectsState.create = function (gameObjects, editorModel) {
                gameObjects = gameObjects.concat();
                //筛选
                editorModel.filtTopHierarchyGameObjects(gameObjects);
                //排序
                gameObjects = editorModel.sortGameObjectsForHierarchy(gameObjects);
                var infos = [];
                for (var i = 0; i < gameObjects.length; i++) {
                    var obj = gameObjects[i];
                    var oldParentUUID = void 0;
                    var oldIndex = void 0;
                    var serializeData = paper.serialize(obj);
                    if (obj.transform.parent) {
                        oldParentUUID = obj.transform.parent.gameObject.uuid;
                        oldIndex = obj.transform.parent.children.indexOf(obj.transform);
                    }
                    else {
                        oldParentUUID = undefined;
                        oldIndex = editorModel.scene.gameObjects.indexOf(obj);
                    }
                    infos.push({ UUID: obj.uuid, oldParentUUID: oldParentUUID, oldIndex: oldIndex, serializeData: serializeData });
                }
                var state = new DeleteGameObjectsState();
                state.deleteInfo = infos;
                return state;
            };
            DeleteGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    for (var i = 0; i < this.deleteInfo.length; i++) {
                        var info = this.deleteInfo[i];
                        var obj = new paper.Deserializer().deserialize(info.serializeData, true, false, this.editorModel.scene);
                        var oldParentObj = this.editorModel.getGameObjectByUUid(info.oldParentUUID);
                        if (oldParentObj) {
                            var oldTargetTransform = oldParentObj.transform.children[info.oldIndex];
                            if (oldTargetTransform) {
                                this.editorModel.setGameObjectsHierarchy([obj], oldTargetTransform.gameObject, 'top');
                            }
                            else {
                                this.editorModel.setGameObjectsHierarchy([obj], oldParentObj, 'inner');
                            }
                        }
                        else {
                            obj.transform.parent = null;
                            var all = this.editorModel.scene.gameObjects;
                            var currentIndex = all.indexOf(obj);
                            all.splice(currentIndex, 1);
                            all.splice(info.oldIndex, 0, obj);
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.deleteInfo.map(function (info) { return info.UUID; }));
                    return true;
                }
                return false;
            };
            DeleteGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var ids = this.deleteInfo.map(function (info) { return info.UUID; });
                    var objs = this.editorModel.getGameObjectsByUUids(ids);
                    for (var index = 0; index < objs.length; index++) {
                        var element = objs[index];
                        element.destroy();
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, ids);
                    return true;
                }
                return false;
            };
            DeleteGameObjectsState.prototype.serialize = function () {
                return this.deleteInfo;
            };
            DeleteGameObjectsState.prototype.deserialize = function (data) {
                this.deleteInfo = data;
            };
            return DeleteGameObjectsState;
        }(editor.BaseState));
        editor.DeleteGameObjectsState = DeleteGameObjectsState;
        __reflect(DeleteGameObjectsState.prototype, "paper.editor.DeleteGameObjectsState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //克隆游戏对象
        var DuplicateGameObjectsState = (function (_super) {
            __extends(DuplicateGameObjectsState, _super);
            function DuplicateGameObjectsState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.firstDo = true;
                return _this;
            }
            DuplicateGameObjectsState.toString = function () {
                return "[class common.DuplicateGameObjectsState]";
            };
            DuplicateGameObjectsState.create = function (objs, editorModel) {
                //过滤
                editorModel.filtTopHierarchyGameObjects(objs);
                //排序
                objs = editorModel.sortGameObjectsForHierarchy(objs);
                var duplicateInfo = [];
                for (var i = 0; i < objs.length; i++) {
                    var obj = objs[i];
                    var UUID = obj.uuid;
                    var parentUUID = obj.transform.parent ? obj.transform.parent.gameObject.uuid : null;
                    var serializeData = paper.serialize(obj);
                    duplicateInfo.push({ UUID: UUID, parentUUID: parentUUID, serializeData: serializeData });
                }
                var state = new DuplicateGameObjectsState();
                state.duplicateInfo = duplicateInfo;
                return state;
            };
            DuplicateGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var objs = this.editorModel.getGameObjectsByUUids(this.addList);
                    for (var index = 0; index < objs.length; index++) {
                        var element = objs[index];
                        element.destroy();
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            DuplicateGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.addList = [];
                    for (var i = 0; i < this.duplicateInfo.length; i++) {
                        var info = this.duplicateInfo[i];
                        var obj = new paper.Deserializer().deserialize(info.serializeData, !this.firstDo, false, this.editorModel.scene);
                        var parent_4 = this.editorModel.getGameObjectByUUid(info.parentUUID);
                        if (parent_4) {
                            obj.transform.parent = parent_4.transform;
                        }
                        //清理预置体信息
                        this.clearPrefabInfo(obj);
                        this.addList.push(obj.uuid);
                        if (this.firstDo) {
                            info.serializeData = paper.serialize(obj);
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.addList);
                    this.firstDo = false;
                    return true;
                }
                return false;
            };
            DuplicateGameObjectsState.prototype.clearPrefabInfo = function (obj) {
                if (this.editorModel.isPrefabChild(obj)) {
                    obj.extras.linkedID = undefined;
                    obj.extras.prefab = undefined;
                    obj.extras.rootID = undefined;
                    for (var i = 0; i < obj.transform.children.length; i++) {
                        this.clearPrefabInfo(obj.transform.children[i].gameObject);
                    }
                }
            };
            DuplicateGameObjectsState.prototype.serialize = function () {
                return { duplicateInfo: this.duplicateInfo, addList: this.addList };
            };
            DuplicateGameObjectsState.prototype.deserialize = function (data) {
                this.duplicateInfo = data.duplicateInfo;
                this.addList = data.addList;
            };
            return DuplicateGameObjectsState;
        }(editor.BaseState));
        editor.DuplicateGameObjectsState = DuplicateGameObjectsState;
        __reflect(DuplicateGameObjectsState.prototype, "paper.editor.DuplicateGameObjectsState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //粘贴游戏对象
        var PasteGameObjectsState = (function (_super) {
            __extends(PasteGameObjectsState, _super);
            function PasteGameObjectsState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            PasteGameObjectsState.toString = function () {
                return "[class common.PasteGameObjectsState]";
            };
            PasteGameObjectsState.create = function (serializeData, parent) {
                var state = new PasteGameObjectsState();
                var parentUUID = parent ? parent.uuid : null;
                state.pasteInfo = { parentUUID: parentUUID, serializeData: serializeData };
                return state;
            };
            PasteGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var objs = this.editorModel.getGameObjectsByUUids(this.addList);
                    for (var index = 0; index < objs.length; index++) {
                        var element = objs[index];
                        element.destroy();
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            PasteGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.addList = [];
                    var parent_5 = this.editorModel.getGameObjectByUUid(this.pasteInfo.parentUUID);
                    var serializeDataList = this.cacheSerializeData ? this.cacheSerializeData : this.pasteInfo.serializeData;
                    var keepUID = this.cacheSerializeData ? true : false;
                    for (var i = 0; i < serializeDataList.length; i++) {
                        var info = serializeDataList[i];
                        var obj = new paper.Deserializer().deserialize(info, keepUID, false, this.editorModel.scene);
                        if (obj && parent_5) {
                            obj.transform.parent = parent_5.transform;
                        }
                        //清理预置体信息
                        this.clearPrefabInfo(obj);
                        this.addList.push(obj.uuid);
                        if (serializeDataList === this.pasteInfo.serializeData) {
                            if (!this.cacheSerializeData)
                                this.cacheSerializeData = [];
                            this.cacheSerializeData.push(paper.serialize(obj));
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            PasteGameObjectsState.prototype.clearPrefabInfo = function (obj) {
                if (this.editorModel.isPrefabChild(obj)) {
                    obj.extras.linkedID = undefined;
                    obj.extras.prefab = undefined;
                    obj.extras.rootID = undefined;
                    for (var i = 0; i < obj.transform.children.length; i++) {
                        this.clearPrefabInfo(obj.transform.children[i].gameObject);
                    }
                }
            };
            PasteGameObjectsState.prototype.serialize = function () {
                return { pasteInfo: this.pasteInfo, addList: this.addList };
            };
            PasteGameObjectsState.prototype.deserialize = function (data) {
                this.addList = data.addList;
                this.pasteInfo = data.pasteInfo;
            };
            return PasteGameObjectsState;
        }(editor.BaseState));
        editor.PasteGameObjectsState = PasteGameObjectsState;
        __reflect(PasteGameObjectsState.prototype, "paper.editor.PasteGameObjectsState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //添加组件
        var AddComponentState = (function (_super) {
            __extends(AddComponentState, _super);
            function AddComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            AddComponentState.toString = function () {
                return "[class common.AddComponentState]";
            };
            AddComponentState.create = function (gameObjectUUid, compClzName) {
                var state = new AddComponentState();
                var data = { gameObjectUUid: gameObjectUUid, compClzName: compClzName };
                state.data = data;
                return state;
            };
            Object.defineProperty(AddComponentState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            AddComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var gameObjectUUid = this.stateData.gameObjectUUid;
                    var componentId = this.stateData.cacheComponentId;
                    var gameObject = this.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (gameObject) {
                        var component = this.editorModel.getComponentById(gameObject, componentId);
                        if (component) {
                            gameObject.removeComponent(component);
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                        }
                    }
                    return true;
                }
                return false;
            };
            AddComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUid = this.stateData.gameObjectUUid;
                    var compClzName = this.stateData.compClzName;
                    var gameObject = this.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (gameObject) {
                        if (this.stateData.serializeData) {
                            new paper.Deserializer().deserialize(this.data.serializeData, true, false, gameObject);
                        }
                        else {
                            var compClz = egret.getDefinitionByName(compClzName);
                            var addComponent = gameObject.addComponent(compClz);
                            this.stateData.serializeData = paper.serialize(addComponent);
                            this.stateData.cacheComponentId = addComponent.uuid;
                        }
                        this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                    }
                    return true;
                }
                return false;
            };
            return AddComponentState;
        }(editor.BaseState));
        editor.AddComponentState = AddComponentState;
        __reflect(AddComponentState.prototype, "paper.editor.AddComponentState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //移除组件
        var RemoveComponentState = (function (_super) {
            __extends(RemoveComponentState, _super);
            function RemoveComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            RemoveComponentState.toString = function () {
                return "[class common.RemoveComponentState]";
            };
            RemoveComponentState.create = function (gameObjectUUid, componentUUid, cacheSerializeData) {
                var state = new RemoveComponentState();
                var data = {
                    gameObjectUUid: gameObjectUUid,
                    componentUUid: componentUUid,
                    cacheSerializeData: cacheSerializeData
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(RemoveComponentState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            RemoveComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var gameObject = this.editorModel.getGameObjectByUUid(this.stateData.gameObjectUUid);
                    if (gameObject) {
                        new paper.Deserializer().deserialize(this.stateData.cacheSerializeData, true, false, gameObject);
                        this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                    }
                    return true;
                }
                return false;
            };
            RemoveComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUid = this.stateData.gameObjectUUid;
                    var componentUUid = this.stateData.componentUUid;
                    var obj = this.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (obj) {
                        var component = this.editorModel.getComponentById(obj, componentUUid);
                        if (component) {
                            obj.removeComponent(component);
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                        }
                    }
                    return true;
                }
                return false;
            };
            return RemoveComponentState;
        }(editor.BaseState));
        editor.RemoveComponentState = RemoveComponentState;
        __reflect(RemoveComponentState.prototype, "paper.editor.RemoveComponentState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 游戏对象层级
         * @author 杨宁
         */
        var GameObjectHierarchyState = (function (_super) {
            __extends(GameObjectHierarchyState, _super);
            function GameObjectHierarchyState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.gameObjectsInfo = [];
                return _this;
            }
            GameObjectHierarchyState.create = function (gameObjects, targetGameObj, dir, editorModel) {
                //筛选
                gameObjects = gameObjects.concat();
                editorModel.filtTopHierarchyGameObjects(gameObjects);
                //必须进行层级排序
                var objs = editorModel.sortGameObjectsForHierarchy(gameObjects);
                //整理对象信息
                var objInfos = [];
                for (var i = 0; i < objs.length; i++) {
                    var obj = objs[i];
                    var oldTargetUUID = void 0;
                    var oldDir = void 0;
                    if (obj.transform.parent) {
                        var index = obj.transform.parent.children.indexOf(obj.transform);
                        if (++index < obj.transform.parent.children.length) {
                            oldTargetUUID = obj.transform.parent.children[index].gameObject.uuid;
                            oldDir = 'top';
                        }
                        else {
                            oldTargetUUID = obj.transform.parent.gameObject.uuid;
                            oldDir = 'inner';
                        }
                    }
                    else {
                        var all = editorModel.scene.gameObjects;
                        var index = all.indexOf(obj);
                        if (++index < all.length) {
                            oldTargetUUID = all[index].uuid;
                            oldDir = 'top';
                        }
                        else {
                            oldTargetUUID = 'scene'; //特殊标记，用来标记最外层最后一个
                            oldDir = 'inner';
                        }
                    }
                    objInfos.push({ UUID: obj.uuid, oldTargetUUID: oldTargetUUID, oldDir: oldDir });
                }
                var instance = new GameObjectHierarchyState();
                instance.gameObjectsInfo = objInfos;
                instance.targetDir = dir;
                instance.targetObject = targetGameObj.uuid;
                return instance;
            };
            GameObjectHierarchyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var tmpList = this.gameObjectsInfo.concat();
                    tmpList.reverse();
                    for (var index = 0; index < tmpList.length; index++) {
                        var info = tmpList[index];
                        var obj = this.editorModel.getGameObjectByUUid(info.UUID);
                        var oldTarget = this.editorModel.getGameObjectByUUid(info.oldTargetUUID);
                        var oldDir = info.oldDir;
                        if (info.oldTargetUUID === 'scene') {
                            var all = this.editorModel.scene.gameObjects;
                            oldTarget = all[all.length - 1];
                            oldDir = 'bottom';
                        }
                        this.editorModel.setGameObjectsHierarchy([obj], oldTarget, oldDir);
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                    return true;
                }
                return false;
            };
            GameObjectHierarchyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUids = this.gameObjectsInfo.map(function (v) { return v.UUID; });
                    var gameObjs = this.editorModel.getGameObjectsByUUids(gameObjectUUids);
                    var targetGameObj = this.editorModel.getGameObjectByUUid(this.targetObject);
                    gameObjs = this.editorModel.sortGameObjectsForHierarchy(gameObjs);
                    this.editorModel.setGameObjectsHierarchy(gameObjs, targetGameObj, this.targetDir);
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                    return true;
                }
                return false;
            };
            return GameObjectHierarchyState;
        }(editor.BaseState));
        editor.GameObjectHierarchyState = GameObjectHierarchyState;
        __reflect(GameObjectHierarchyState.prototype, "paper.editor.GameObjectHierarchyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var CreatePrefabState = (function (_super) {
            __extends(CreatePrefabState, _super);
            function CreatePrefabState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            CreatePrefabState.toString = function () {
                return "[class common.CreatePrefabState]";
            };
            CreatePrefabState.create = function (prefab, parent) {
                var state = new CreatePrefabState();
                var parentUUID = parent ? parent.uuid : undefined;
                var data = {
                    prefab: prefab,
                    parentUUID: parentUUID
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(CreatePrefabState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            CreatePrefabState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var deleteUUid = this.stateData.cachePrefabUUid;
                    if (deleteUUid) {
                        var gameObj = this.editorModel.getGameObjectByUUid(deleteUUid);
                        if (gameObj) {
                            gameObj.destroy();
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, [deleteUUid]);
                        }
                    }
                    return true;
                }
                return false;
            };
            CreatePrefabState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var prefab = this.stateData.prefab;
                    if (prefab) {
                        var instance = this.stateData.prefab.createInstance(this.editorModel.scene);
                        this.stateData.cachePrefabUUid = instance.uuid;
                        var parent_6 = this.editorModel.getGameObjectByUUid(this.stateData.parentUUID);
                        if (parent_6) {
                            instance.transform.parent = parent_6.transform;
                        }
                        this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS);
                    }
                    return true;
                }
                return false;
            };
            return CreatePrefabState;
        }(editor.BaseState));
        editor.CreatePrefabState = CreatePrefabState;
        __reflect(CreatePrefabState.prototype, "paper.editor.CreatePrefabState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 预置体结构状态
         * @author 杨宁
         */
        var BreakPrefabStructState = (function (_super) {
            __extends(BreakPrefabStructState, _super);
            function BreakPrefabStructState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.prefabInfos = [];
                return _this;
            }
            BreakPrefabStructState.create = function (prefabInstanceList) {
                var _this = this;
                var instance = new BreakPrefabStructState();
                instance.prefabInfos = [];
                prefabInstanceList.forEach(function (obj) {
                    for (var _i = 0, _a = instance.prefabInfos; _i < _a.length; _i++) {
                        var info = _a[_i];
                        if (info.uuid === obj.uuid)
                            return;
                    }
                    instance.prefabInfos = instance.prefabInfos.concat(_this.makePrefabInfo(obj));
                });
                return instance;
            };
            BreakPrefabStructState.makePrefabInfo = function (gameOjbect) {
                var isPrefabRoot = function (gameObj) {
                    if (gameObj.extras.prefab) {
                        return true;
                    }
                    return false;
                };
                var isPrefabChild = function (gameObj) {
                    if (gameObj.extras.rootID) {
                        return true;
                    }
                    return false;
                };
                var makeInfo = function (target, result) {
                    if (result === void 0) { result = []; }
                    result.push({ uuid: target.uuid, linkid: target.extras.linkedID, rootid: target.extras.rootID, prefab: target.extras.prefab.name });
                    target.transform.children.forEach(function (transform) {
                        var obj = transform.gameObject;
                        if (isPrefabChild(obj) && !isPrefabRoot(obj)) {
                            makeInfo(obj, result);
                        }
                    });
                };
                var target = gameOjbect;
                var infos = [];
                while (target) {
                    if (isPrefabRoot(target)) {
                        makeInfo(target, infos);
                        break;
                    }
                    if (target.transform.parent)
                        target = target.transform.parent.gameObject;
                    else
                        break;
                }
                return infos;
            };
            BreakPrefabStructState.prototype.redo = function () {
                var _this = this;
                var ids = this.prefabInfos.map(function (prefabInfos) { return prefabInfos.uuid; });
                var objs = this.editorModel.getGameObjectsByUUids(ids);
                objs.forEach(function (obj) {
                    obj.extras.linkedID = undefined;
                    obj.extras.prefab = undefined;
                    obj.extras.rootID = undefined;
                    _this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: obj, propName: 'prefab', propValue: null });
                });
                return true;
            };
            BreakPrefabStructState.prototype.undo = function () {
                var all = this.editorModel.scene.gameObjects;
                for (var i = 0; i < all.length; i++) {
                    var obj = all[i];
                    b: for (var k = 0; k < this.prefabInfos.length; k++) {
                        var info = this.prefabInfos[k];
                        if (obj.uuid === info.uuid) {
                            obj.extras.linkedID = info.linkid;
                            obj.extras.prefab = paper.Asset.find(info.prefab);
                            obj.extras.rootID = info.rootid;
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: obj, propName: 'prefab', propValue: obj.extras.prefab });
                            break b;
                        }
                    }
                }
                return true;
            };
            BreakPrefabStructState.prototype.serialize = function () {
                return this.prefabInfos;
            };
            BreakPrefabStructState.prototype.deserialize = function (data) {
                this.prefabInfos = data;
            };
            return BreakPrefabStructState;
        }(editor.BaseState));
        editor.BreakPrefabStructState = BreakPrefabStructState;
        __reflect(BreakPrefabStructState.prototype, "paper.editor.BreakPrefabStructState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var ApplyPrefabInstanceState = (function (_super) {
            __extends(ApplyPrefabInstanceState, _super);
            function ApplyPrefabInstanceState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.firstRedo = true;
                return _this;
            }
            ApplyPrefabInstanceState.toString = function () {
                return "[class common.ApplyPrefabInstanceState]";
            };
            ApplyPrefabInstanceState.create = function (applyData, applyPrefabRootId, prefab) {
                var state = new ApplyPrefabInstanceState();
                var cachePrefabSerializedData = editor.Editor.activeEditorModel.deepClone(prefab._raw);
                var data = {
                    applyPrefabRootId: applyPrefabRootId,
                    prefab: prefab,
                    applyData: applyData,
                    cachePrefabSerializedData: cachePrefabSerializedData
                };
                data.cacheGameObjetsIds = [];
                data.cacheComponentsIds = {};
                state.data = data;
                return state;
            };
            Object.defineProperty(ApplyPrefabInstanceState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            ApplyPrefabInstanceState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var applyGameObject = editor.Editor.activeEditorModel.getGameObjectByUUid(this.stateData.applyPrefabRootId);
                    var objects = this.editorModel.scene.gameObjects;
                    for (var index = objects.length - 1; index >= 0; index--) {
                        if (this.stateData.cacheGameObjetsIds.length === 0 && Object.keys(this.stateData.cacheComponentsIds).length === 0) {
                            break;
                        }
                        var gameObj = objects[index];
                        var gIndex = this.stateData.cacheGameObjetsIds.indexOf(gameObj.uuid);
                        if (gIndex >= 0) {
                            gameObj.destroy();
                            this.stateData.cacheGameObjetsIds.splice(gIndex, 1);
                        }
                        else if (this.stateData.cacheComponentsIds[gameObj.uuid] && this.stateData.cacheComponentsIds[gameObj.uuid].length > 0) {
                            var comIds = this.stateData.cacheComponentsIds[gameObj.uuid];
                            for (var comIndex = gameObj.components.length - 1; comIndex >= 0; comIndex--) {
                                var com = gameObj.components[comIndex];
                                var cIndex = comIds.indexOf(com.uuid);
                                if (cIndex >= 0) {
                                    gameObj.removeComponent(com);
                                    comIds.splice(cIndex, 1);
                                    if (comIds.length === 0) {
                                        delete this.stateData.cacheComponentsIds[gameObj.uuid];
                                    }
                                }
                            }
                        }
                    }
                    var tempPrefabObject = this.stateData.prefab.createInstance(paper.Application.sceneManager.globalScene, true);
                    for (var linkedId in this.stateData.applyData) {
                        var applyData = this.stateData.applyData[linkedId];
                        if (applyData.addGameObjects && applyData.addGameObjects.length > 0) {
                            for (var index = 0; index < applyData.addGameObjects.length; index++) {
                                var obj = applyData.addGameObjects[index];
                                var originalObj = this.getGameObjectByUUid(applyGameObject, obj.id);
                                if (originalObj) {
                                    this.clearLinkedId(originalObj);
                                }
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                        }
                        if (applyData.addComponents && applyData.addComponents.length > 0) {
                            for (var index = 0; index < applyData.addComponents.length; index++) {
                                var element = applyData.addComponents[index];
                                var id = element.id, gameObjId = element.gameObjId;
                                var originalObj = this.getGameObjectByUUid(applyGameObject, gameObjId);
                                if (originalObj) {
                                    var originalComponent = editor.Editor.activeEditorModel.getComponentById(originalObj, id);
                                    if (originalComponent) {
                                        originalComponent.extras = {};
                                    }
                                }
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                        }
                        if (applyData.modifyGameObjectPropertyList && applyData.modifyGameObjectPropertyList.length > 0) {
                            for (var _i = 0, _a = applyData.modifyGameObjectPropertyList; _i < _a.length; _i++) {
                                var obj = _a[_i];
                                this.modifyPrefabGameObjectPropertyValues(linkedId, tempPrefabObject, obj.preValueCopylist);
                            }
                        }
                        if (applyData.modifyComponentPropertyList && applyData.modifyComponentPropertyList.length > 0) {
                            for (var _b = 0, _c = applyData.modifyComponentPropertyList; _b < _c.length; _b++) {
                                var obj = _c[_b];
                                this.modifyPrefabComponentPropertyValues(linkedId, obj.componentId, tempPrefabObject, obj.preValueCopylist);
                            }
                        }
                    }
                    //reset prefab serrializedata,save prefab
                    // (this.stateData.prefab as any)._raw = this.stateData.cachePrefabSerializedData;
                    var prefabJson = this.stateData.cachePrefabSerializedData;
                    this.stateData.prefab._raw = prefabJson;
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.SAVE_ASSET, { name: this.stateData.prefab.name, raw: prefabJson });
                    tempPrefabObject.destroy();
                    tempPrefabObject = null;
                    return true;
                }
                return false;
            };
            ApplyPrefabInstanceState.prototype.getAllUUidFromGameObject = function (gameObj, uuids) {
                if (uuids === void 0) { uuids = null; }
                if (gameObj) {
                    uuids = uuids || [];
                    uuids.push(gameObj.uuid);
                    for (var _i = 0, _a = gameObj.components; _i < _a.length; _i++) {
                        var com = _a[_i];
                        uuids.push(com.uuid);
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        this.getAllUUidFromGameObject(obj, uuids);
                    }
                }
                return uuids;
            };
            ApplyPrefabInstanceState.prototype.setLinkedId = function (gameObj, ids) {
                if (gameObj) {
                    var linkedId = ids.shift();
                    if (linkedId === undefined) {
                        console.error("linkedId error");
                    }
                    gameObj.extras.linkedID = linkedId;
                    for (var _i = 0, _a = gameObj.components; _i < _a.length; _i++) {
                        var com = _a[_i];
                        linkedId = ids.shift();
                        if (linkedId === undefined) {
                            console.error("linkedId error");
                        }
                        com.extras.linkedID = linkedId;
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        if (obj.hideFlags === 3 /* HideAndDontSave */) {
                            continue;
                        }
                        this.setLinkedId(obj, ids);
                    }
                }
            };
            ApplyPrefabInstanceState.prototype.clearLinkedId = function (gameObj) {
                if (gameObj) {
                    gameObj.extras = {};
                    for (var index = 0; index < gameObj.components.length; index++) {
                        var element = gameObj.components[index];
                        element.extras = {};
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        this.clearLinkedId(obj);
                    }
                }
            };
            ApplyPrefabInstanceState.prototype.dispathPropertyEvent = function (modifyObj, propName, newValue) {
                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
            };
            ApplyPrefabInstanceState.prototype.modifyPrefabGameObjectPropertyValues = function (linkedId, tempObj, valueList) {
                var _this = this;
                var prefabObj = this.getGameObjectByLinkedId(tempObj, linkedId);
                var objects = this.getGameObjectsByLinkedId(linkedId, this.stateData.applyPrefabRootId);
                valueList.forEach(function (propertyValue) {
                    var propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                    var newValue = _this.editorModel.deserializeProperty(copyValue, valueEditType);
                    objects.forEach(function (object) {
                        if (paper.equal(object[propName], prefabObj[propName])) {
                            _this.editorModel.setTargetProperty(propName, object, newValue, valueEditType);
                            _this.dispathPropertyEvent(object, propName, newValue);
                        }
                    });
                    _this.editorModel.setTargetProperty(propName, prefabObj, newValue, valueEditType);
                });
                this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
            };
            ApplyPrefabInstanceState.prototype.modifyPrefabComponentPropertyValues = function (linkedId, componentUUid, tempObj, valueList) {
                var _this = this;
                var prefabObj = this.getGameObjectByLinkedId(tempObj, linkedId);
                var objects = this.getGameObjectsByLinkedId(linkedId, this.stateData.applyPrefabRootId);
                var _loop_1 = function (k) {
                    var prefabComp = prefabObj.components[k];
                    if (prefabComp.uuid === componentUUid) {
                        valueList.forEach(function (propertyValue) {
                            var propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                            var newValue = _this.editorModel.deserializeProperty(copyValue, valueEditType);
                            objects.forEach(function (object) {
                                var objectComp = _this.editorModel.getComponentByAssetId(object, prefabComp.extras.linkedID);
                                if (objectComp !== null) {
                                    if (paper.equal(objectComp[propName], prefabComp[propName])) {
                                        _this.editorModel.setTargetProperty(propName, objectComp, newValue, valueEditType);
                                        _this.dispathPropertyEvent(objectComp, propName, newValue);
                                    }
                                }
                            });
                            _this.editorModel.setTargetProperty(propName, prefabComp, newValue, valueEditType);
                        });
                    }
                };
                for (var k = 0; k < prefabObj.components.length; k++) {
                    _loop_1(k);
                }
            };
            ApplyPrefabInstanceState.prototype.setGameObjectPrefabRootId = function (gameObj, rootID) {
                if (gameObj.extras.prefab === undefined) {
                    gameObj.extras.rootID = rootID;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    this.setGameObjectPrefabRootId(obj, rootID);
                }
            };
            ApplyPrefabInstanceState.prototype.getGameObjectsByLinkedId = function (linkedId, filterApplyRootId) {
                var objects = this.editorModel.scene.gameObjects;
                var result = [];
                for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {
                    var obj = objects_1[_i];
                    if ((obj.extras && obj.extras.linkedID && obj.extras.linkedID === linkedId) && (obj.extras.prefab || (obj.extras.rootID && obj.extras.rootID !== filterApplyRootId)) && obj.uuid !== filterApplyRootId) {
                        result.push(obj);
                    }
                }
                return result;
            };
            ApplyPrefabInstanceState.prototype.getGameObjectByLinkedId = function (gameObj, linkedID) {
                if (!gameObj) {
                    return null;
                }
                var result;
                if (gameObj.extras.linkedID === linkedID) {
                    result = gameObj;
                    return gameObj;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    result = this.getGameObjectByLinkedId(obj, linkedID);
                    if (result) {
                        break;
                    }
                }
                return result;
            };
            ApplyPrefabInstanceState.prototype.getGameObjectByUUid = function (gameObj, uuid) {
                if (!gameObj) {
                    return null;
                }
                var result;
                if (gameObj.uuid === uuid) {
                    result = gameObj;
                    return gameObj;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    result = this.getGameObjectByUUid(obj, uuid);
                    if (result) {
                        break;
                    }
                }
                return result;
            };
            ApplyPrefabInstanceState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var tempPrefabObject = this.stateData.prefab.createInstance(paper.Application.sceneManager.globalScene, true);
                    var tempGameObjects = editor.Editor.activeEditorModel.getAllGameObjectsFromPrefabInstance(tempPrefabObject);
                    var applyGameObject = editor.Editor.activeEditorModel.getGameObjectByUUid(this.stateData.applyPrefabRootId);
                    for (var _i = 0, _a = tempGameObjects; _i < _a.length; _i++) {
                        var gameObj = _a[_i];
                        if (!(this.stateData.applyData[gameObj.extras.linkedID])) {
                            continue;
                        }
                        var applyData = this.stateData.applyData[gameObj.extras.linkedID];
                        if (applyData.addGameObjects && applyData.addGameObjects.length > 0) {
                            for (var index = 0; index < applyData.addGameObjects.length; index++) {
                                var obj = applyData.addGameObjects[index];
                                var ids = [];
                                var newObj = void 0;
                                if (this.firstRedo) {
                                    newObj = new paper.Deserializer().deserialize(obj.serializeData, false, false, paper.Application.sceneManager.globalScene);
                                    newObj.parent = gameObj;
                                    ids = this.getAllUUidFromGameObject(newObj);
                                    obj.cacheSerializeData = Object.create(null);
                                    obj.cacheSerializeData[gameObj.uuid] = [];
                                    obj.cacheSerializeData[gameObj.uuid][index] = paper.serialize(newObj);
                                }
                                else {
                                    var cacheData = obj.cacheSerializeData[gameObj.uuid][index];
                                    newObj = new paper.Deserializer().deserialize(cacheData, true, false, paper.Application.sceneManager.globalScene);
                                    newObj.parent = gameObj;
                                    ids = this.getAllUUidFromGameObject(newObj);
                                }
                                var linkedId = gameObj.extras.linkedID;
                                var instanceGameObjects = this.getGameObjectsByLinkedId(linkedId, this.stateData.applyPrefabRootId);
                                for (var _b = 0, instanceGameObjects_1 = instanceGameObjects; _b < instanceGameObjects_1.length; _b++) {
                                    var instanceGameObject = instanceGameObjects_1[_b];
                                    var addObj = void 0;
                                    if (this.firstRedo) {
                                        addObj = new paper.Deserializer().deserialize(obj.serializeData, false, false, this.editorModel.scene);
                                        addObj.parent = instanceGameObject;
                                        var rootId = instanceGameObject.extras.prefab ? instanceGameObject.uuid : instanceGameObject.extras.rootID;
                                        this.setGameObjectPrefabRootId(addObj, rootId);
                                        this.setLinkedId(addObj, ids.concat());
                                        obj.cacheSerializeData[instanceGameObject.uuid] = [];
                                        obj.cacheSerializeData[instanceGameObject.uuid][index] = this.clearExtrasFromSerilizeData(paper.serialize(addObj));
                                    }
                                    else {
                                        var cacheData = obj.cacheSerializeData[instanceGameObject.uuid][index];
                                        addObj = new paper.Deserializer().deserialize(cacheData, true, false, this.editorModel.scene);
                                        addObj.parent = instanceGameObject;
                                        var rootId = instanceGameObject.extras.prefab ? instanceGameObject.uuid : instanceGameObject.extras.rootID;
                                        this.setGameObjectPrefabRootId(addObj, rootId);
                                        this.setLinkedId(addObj, ids.concat());
                                    }
                                    if (addObj) {
                                        this.stateData.cacheGameObjetsIds.push(addObj.uuid);
                                    }
                                }
                                var originalGameObj = this.getGameObjectByUUid(applyGameObject, obj.id);
                                if (originalGameObj) {
                                    this.setGameObjectPrefabRootId(originalGameObj, this.stateData.applyPrefabRootId);
                                    this.setLinkedId(originalGameObj, ids.concat());
                                }
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS);
                        }
                        if (applyData.addComponents && applyData.addComponents.length > 0) {
                            for (var _c = 0, _d = applyData.addComponents; _c < _d.length; _c++) {
                                var obj = _d[_c];
                                var newComponent = void 0;
                                if (this.firstRedo) {
                                    newComponent = new paper.Deserializer().deserialize(obj.serializeData, false, false, gameObj);
                                    obj.cacheSerializeData = Object.create(null);
                                    obj.cacheSerializeData[gameObj.uuid] = paper.serialize(newComponent);
                                }
                                else {
                                    var cacheData = obj.cacheSerializeData[gameObj.uuid];
                                    newComponent = new paper.Deserializer().deserialize(cacheData, true, false, gameObj);
                                }
                                var linkedId = gameObj.extras.linkedID;
                                var instanceGameObjects = this.getGameObjectsByLinkedId(linkedId, this.stateData.applyPrefabRootId);
                                for (var _e = 0, instanceGameObjects_2 = instanceGameObjects; _e < instanceGameObjects_2.length; _e++) {
                                    var instanceGameObject = instanceGameObjects_2[_e];
                                    var addComponent = void 0;
                                    if (this.firstRedo) {
                                        addComponent = new paper.Deserializer().deserialize(obj.serializeData, false, false, instanceGameObject);
                                        addComponent.extras.linkedID = newComponent.uuid;
                                        obj.cacheSerializeData[instanceGameObject.uuid] = this.clearExtrasFromSerilizeData(paper.serialize(addComponent));
                                    }
                                    else {
                                        var cacheData = obj.cacheSerializeData[instanceGameObject.uuid];
                                        addComponent = new paper.Deserializer().deserialize(cacheData, true, false, instanceGameObject);
                                        addComponent.extras.linkedID = newComponent.uuid;
                                    }
                                    this.stateData.cacheComponentsIds[instanceGameObject.uuid] = this.stateData.cacheComponentsIds[instanceGameObject.uuid] || [];
                                    if (addComponent) {
                                        this.stateData.cacheComponentsIds[instanceGameObject.uuid].push(addComponent.uuid);
                                    }
                                }
                                var originalGameObj = this.getGameObjectByUUid(applyGameObject, obj.gameObjId);
                                if (originalGameObj) {
                                    var originalComponent = editor.Editor.activeEditorModel.getComponentById(originalGameObj, obj.id);
                                    originalComponent.extras.linkedID = newComponent.uuid;
                                }
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                        }
                        if (applyData.modifyGameObjectPropertyList && applyData.modifyGameObjectPropertyList.length > 0) {
                            for (var _f = 0, _g = applyData.modifyGameObjectPropertyList; _f < _g.length; _f++) {
                                var obj = _g[_f];
                                this.modifyPrefabGameObjectPropertyValues(gameObj.extras.linkedID, tempPrefabObject, obj.newValueList);
                            }
                        }
                        if (applyData.modifyComponentPropertyList && applyData.modifyComponentPropertyList.length > 0) {
                            for (var _h = 0, _j = applyData.modifyComponentPropertyList; _h < _j.length; _h++) {
                                var obj = _j[_h];
                                this.modifyPrefabComponentPropertyValues(gameObj.extras.linkedID, obj.componentId, tempPrefabObject, obj.newValueList);
                            }
                        }
                    }
                    this.clearGameObjectExtrasInfo(tempPrefabObject);
                    // (this.stateData.prefab as any)._raw = this.clearExtrasFromSerilizeData(paper.serialize(tempPrefabObject));
                    var prefabJson = this.clearExtrasFromSerilizeData(paper.serialize(tempPrefabObject));
                    this.stateData.prefab._raw = prefabJson;
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.SAVE_ASSET, { name: this.stateData.prefab.name, raw: prefabJson });
                    tempPrefabObject.destroy();
                    this.firstRedo = false;
                    return true;
                }
                return false;
            };
            ApplyPrefabInstanceState.prototype.clearGameObjectExtrasInfo = function (gameObj) {
                if (gameObj) {
                    delete gameObj.extras;
                    for (var _i = 0, _a = gameObj.components; _i < _a.length; _i++) {
                        var comp = _a[_i];
                        delete comp.extras;
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        this.clearGameObjectExtrasInfo(obj);
                    }
                }
            };
            ApplyPrefabInstanceState.prototype.clearExtrasFromSerilizeData = function (data) {
                var objects = data.objects;
                var components = data.components;
                for (var _i = 0, objects_2 = objects; _i < objects_2.length; _i++) {
                    var obj = objects_2[_i];
                    delete obj["extras"];
                }
                for (var _a = 0, components_6 = components; _a < components_6.length; _a++) {
                    var comp = components_6[_a];
                    delete comp["extras"];
                }
                return data;
            };
            return ApplyPrefabInstanceState;
        }(editor.BaseState));
        editor.ApplyPrefabInstanceState = ApplyPrefabInstanceState;
        __reflect(ApplyPrefabInstanceState.prototype, "paper.editor.ApplyPrefabInstanceState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var RevertPrefabInstanceState = (function (_super) {
            __extends(RevertPrefabInstanceState, _super);
            function RevertPrefabInstanceState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            RevertPrefabInstanceState.toString = function () {
                return "[class common.RevertPrefabInstanceState]";
            };
            RevertPrefabInstanceState.create = function (revertData, revertPrefabRootId) {
                var state = new RevertPrefabInstanceState();
                var data = { revertData: revertData, revertPrefabRootId: revertPrefabRootId };
                state.data = data;
                return state;
            };
            Object.defineProperty(RevertPrefabInstanceState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            RevertPrefabInstanceState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var revertRoot = editor.Editor.activeEditorModel.getGameObjectByUUid(this.stateData.revertPrefabRootId);
                    var gameObjects = editor.Editor.activeEditorModel.getAllGameObjectsFromPrefabInstance(revertRoot);
                    var removeGameObjIds = [];
                    for (var _i = 0, gameObjects_3 = gameObjects; _i < gameObjects_3.length; _i++) {
                        var gameObj = gameObjects_3[_i];
                        if (!(this.stateData.revertData[gameObj.extras.linkedID])) {
                            continue;
                        }
                        var revertData = this.stateData.revertData[gameObj.extras.linkedID];
                        if (revertData.revertGameObjects && revertData.revertGameObjects.length > 0) {
                            for (var _a = 0, _b = revertData.revertGameObjects; _a < _b.length; _a++) {
                                var obj = _b[_a];
                                var serializeData = obj.serializeData;
                                var newObj = new paper.Deserializer().deserialize(serializeData, true, false, this.editorModel.scene);
                                newObj.parent = gameObj;
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS);
                        }
                        if (revertData.revertComponents && revertData.revertComponents.length > 0) {
                            for (var _c = 0, _d = revertData.revertComponents; _c < _d.length; _c++) {
                                var com = _d[_c];
                                var serializeData = com.serializeData;
                                new paper.Deserializer().deserialize(serializeData, true, false, gameObj);
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                        }
                        if (revertData.modifyGameObjectPropertyList && revertData.modifyGameObjectPropertyList.length > 0) {
                            for (var _e = 0, _f = revertData.modifyGameObjectPropertyList; _e < _f.length; _e++) {
                                var obj = _f[_e];
                                var preValueCopylist = obj.newValueList;
                                this.modifyPrefabGameObjectPropertyValues(gameObj, preValueCopylist);
                            }
                        }
                        if (revertData.modifyComponentPropertyList && revertData.modifyComponentPropertyList.length > 0) {
                            for (var _g = 0, _h = revertData.modifyComponentPropertyList; _g < _h.length; _g++) {
                                var obj = _h[_g];
                                var componentId = obj.componentId, preValueCopylist = obj.preValueCopylist;
                                this.modifyPrefabComponentPropertyValues(gameObj, componentId, preValueCopylist);
                            }
                        }
                    }
                    return true;
                }
                return false;
            };
            RevertPrefabInstanceState.prototype.dispathPropertyEvent = function (modifyObj, propName, newValue) {
                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
            };
            RevertPrefabInstanceState.prototype.modifyPrefabGameObjectPropertyValues = function (gameObj, valueList) {
                var _this = this;
                valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                    var propName, copyValue, valueEditType, newValue;
                    return __generator(this, function (_a) {
                        propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                        newValue = this.editorModel.deserializeProperty(copyValue, valueEditType);
                        this.editorModel.setTargetProperty(propName, gameObj, newValue, valueEditType);
                        this.dispathPropertyEvent(gameObj, propName, newValue);
                        return [2 /*return*/];
                    });
                }); });
            };
            RevertPrefabInstanceState.prototype.modifyPrefabComponentPropertyValues = function (gameObj, componentUUid, valueList) {
                var _this = this;
                var _loop_2 = function (k) {
                    var prefabComp = gameObj.components[k];
                    if (prefabComp.uuid === componentUUid) {
                        valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                            var propName, copyValue, valueEditType, newValue;
                            return __generator(this, function (_a) {
                                propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                newValue = this.editorModel.deserializeProperty(copyValue, valueEditType);
                                this.editorModel.setTargetProperty(propName, prefabComp, newValue, valueEditType);
                                this.dispathPropertyEvent(prefabComp, propName, newValue);
                                return [2 /*return*/];
                            });
                        }); });
                    }
                };
                for (var k = 0; k < gameObj.components.length; k++) {
                    _loop_2(k);
                }
            };
            RevertPrefabInstanceState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var revertRoot = editor.Editor.activeEditorModel.getGameObjectByUUid(this.stateData.revertPrefabRootId);
                    var gameObjects = editor.Editor.activeEditorModel.getAllGameObjectsFromPrefabInstance(revertRoot);
                    var removeGameObjIds_1 = [];
                    var _loop_3 = function (gameObj) {
                        if (!(this_1.stateData.revertData[gameObj.extras.linkedID])) {
                            return "continue";
                        }
                        var revertData = this_1.stateData.revertData[gameObj.extras.linkedID];
                        if (revertData.revertGameObjects && revertData.revertGameObjects.length > 0) {
                            revertData.revertGameObjects.forEach(function (element) {
                                removeGameObjIds_1.push(element.id);
                            });
                        }
                        if (revertData.revertComponents && revertData.revertComponents.length > 0) {
                            var revertComponentIds_1 = [];
                            revertData.revertComponents.forEach(function (element) {
                                revertComponentIds_1.push(element.id);
                            });
                            var components = gameObj.components;
                            for (var index = components.length - 1; index >= 0; index--) {
                                var element = components[index];
                                if (revertComponentIds_1.indexOf(element.uuid) >= 0) {
                                    gameObj.removeComponent(element.constructor);
                                }
                            }
                            this_1.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                        }
                        if (revertData.modifyGameObjectPropertyList && revertData.modifyGameObjectPropertyList.length > 0) {
                            for (var _i = 0, _a = revertData.modifyGameObjectPropertyList; _i < _a.length; _i++) {
                                var obj = _a[_i];
                                var newValueList = obj.newValueList;
                                this_1.modifyPrefabGameObjectPropertyValues(gameObj, newValueList);
                            }
                        }
                        if (revertData.modifyComponentPropertyList && revertData.modifyComponentPropertyList.length > 0) {
                            for (var _b = 0, _c = revertData.modifyComponentPropertyList; _b < _c.length; _b++) {
                                var obj = _c[_b];
                                var componentId = obj.componentId, newValueList = obj.newValueList;
                                this_1.modifyPrefabComponentPropertyValues(gameObj, componentId, newValueList);
                            }
                        }
                    };
                    var this_1 = this;
                    for (var _i = 0, gameObjects_4 = gameObjects; _i < gameObjects_4.length; _i++) {
                        var gameObj = gameObjects_4[_i];
                        _loop_3(gameObj);
                    }
                    var gameObjs = editor.Editor.activeEditorModel.getGameObjectsByUUids(removeGameObjIds_1);
                    gameObjs.forEach(function (element) { return element.destroy(); });
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, removeGameObjIds_1);
                    return true;
                }
                return false;
            };
            return RevertPrefabInstanceState;
        }(editor.BaseState));
        editor.RevertPrefabInstanceState = RevertPrefabInstanceState;
        __reflect(RevertPrefabInstanceState.prototype, "paper.editor.RevertPrefabInstanceState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var ValueUUID = (function () {
            function ValueUUID(_value) {
                this._value = _value;
                // empty
            }
            ValueUUID.prototype.asHex = function () {
                return this._value;
            };
            return ValueUUID;
        }());
        __reflect(ValueUUID.prototype, "ValueUUID", ["paper.editor.UUID"]);
        var V4UUID = (function (_super) {
            __extends(V4UUID, _super);
            function V4UUID() {
                return _super.call(this, [
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    '4',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._oneOf(V4UUID._timeHighBits),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                ].join('')) || this;
            }
            V4UUID._oneOf = function (array) {
                return array[Math.floor(array.length * Math.random())];
            };
            V4UUID._randomHex = function () {
                return V4UUID._oneOf(V4UUID._chars);
            };
            V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
            V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
            return V4UUID;
        }(ValueUUID));
        __reflect(V4UUID.prototype, "V4UUID");
        function v4() {
            return new V4UUID();
        }
        editor.v4 = v4;
        var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        function isUUID(value) {
            return _UUIDPattern.test(value);
        }
        editor.isUUID = isUUID;
        /**
         * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
         * @param value A uuid string.
         */
        function parse(value) {
            if (!isUUID(value)) {
                throw new Error('invalid uuid');
            }
            return new ValueUUID(value);
        }
        editor.parse = parse;
        function generateUuid() {
            return v4().asHex();
        }
        editor.generateUuid = generateUuid;
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * @deprecated
     */
    egret3d.Matrix = egret3d.Matrix4;
    /**
     * @deprecated
     */
    egret3d.Prefab = paper.Prefab;
    /**
     * @deprecated
     */
    egret3d.RawScene = paper.RawScene;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 引擎启动入口
     */
    function runEgret(options) {
        if (options === void 0) { options = { antialias: false }; }
        console.info("Egret version:", paper.Application.version);
        console.info("Egret start.");
        egret.Sound = egret.web ? egret.web.HtmlSound : egret['wxgame']['HtmlSound']; //TODO:Sound
        egret.Capabilities["renderMode" + ""] = "webgl";
        var requiredOptions = getOptions(options);
        var canvas = getMainCanvas(options);
        //TODO
        options.canvas = canvas;
        options.option = requiredOptions;
        options.webgl = canvas.getContext('webgl', options) || canvas.getContext("experimental-webgl", options);
        egret3d.WebGLCapabilities.canvas = options.canvas;
        egret3d.WebGLCapabilities.webgl = options.webgl;
        egret3d.InputManager.init(canvas);
        egret3d.stage.init(canvas, requiredOptions);
        paper.Application.init(options);
        var systemManager = paper.Application.systemManager;
        systemManager.register(egret3d.BeginSystem, 0 /* Begin */);
        systemManager.register(egret3d.AnimationSystem, 5000 /* Animation */);
        systemManager.register(egret3d.MeshRendererSystem, 7000 /* Renderer */);
        systemManager.register(egret3d.SkinnedMeshRendererSystem, 7000 /* Renderer */);
        systemManager.register(egret3d.particle.ParticleSystem, 7000 /* Renderer */);
        systemManager.register(egret3d.Egret2DRendererSystem, 7000 /* Renderer */);
        systemManager.register(egret3d.CameraAndLightSystem, 8000 /* Draw */ - 1);
        systemManager.register(egret3d.WebGLRenderSystem, 8000 /* Draw */);
        systemManager.register(egret3d.EndSystem, 10000 /* End */);
        systemManager._preRegisterSystems();
        console.info("Egret start complete.");
    }
    egret3d.runEgret = runEgret;
    function getMainCanvas(options) {
        if (window.canvas) {
            return window.canvas;
        }
        else if (options.canvas) {
            return options.canvas;
        }
        else {
            var div = document.getElementsByClassName("egret-player")[0];
            var canvas = document.createElement("canvas");
            div.appendChild(canvas);
            return canvas;
        }
    }
    function getOptions(options) {
        if (window.canvas) {
            return {
                antialias: options.antialias,
                antialiasSamples: 4,
                contentWidth: options.contentWidth || 640,
                contentHeight: options.contentHeight || 1136
            };
        }
        else {
            var div = document.getElementsByClassName("egret-player")[0];
            return {
                antialias: options.antialias,
                antialiasSamples: 4,
                contentWidth: parseInt(div.getAttribute("data-content-width")),
                contentHeight: parseInt(div.getAttribute("data-content-height"))
            };
        }
    }
})(egret3d || (egret3d = {}));
window.paper = paper;
window.egret3d = egret3d;
